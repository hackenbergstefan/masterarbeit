\lstMakeShortInline[
  basicstyle = \small\normalfont\ttfamily,
  frame = none,
% numbers = left,
  numberstyle = \tiny,
% numbersep = 5pt,
  breaklines = true,
  %xleftmargin = 0.1\linewidth,
  %xrightmargin = 0.1\linewidth,
  escapeinside = {(*}{*)},
  tabsize=3,
  language=C,
  mathescape=true,
  breaklines=true]@

\lstMakeShortInline[
  basicstyle = \small\normalfont\ttfamily,
  frame = none,
% numbers = left,
  numberstyle = \tiny,
% numbersep = 5pt,
  breaklines = true,
  %xleftmargin = 0.1\linewidth,
  %xrightmargin = 0.1\linewidth,
  escapeinside = {(*}{*)},
  tabsize=3,
  language=Python,
  mathescape=true,
  breaklines=true]"

\newcommand{\ttgray}{\color{gray}\ttfamily}


\section{Implementierung endlicher Körper und Körpererweiterungen}
\label{sec:impl_endl_körper}
Grundsätzlich wurde zur konkreten Suche und Enumeration primitiver und
vollständig normaler Elemente das Computeralgebrasystem \sage verwendet.
\sage bietet bereits die Möglichkeit in endlichen Körpern zu rechnen. Jedoch
hat sich herausgestellt, dass die zugrunde liegenden \Clang-Bibliotheken 
(im Allgemeinen Fall ist dies das \texttt{Pari C library}%
\footnote{vgl. \url{http://www.sagemath.org/doc/reference/%
rings_standard/sage/rings/finite_rings/constructor.html}}) 
zu langsam sind. Dies ist sicherlich auf die Allgemeinheit ihrer
Anwendungsgebiete zurückzuführen. Beispielsweise arbeitet die 
\texttt{Pari}-Bibliothek stets mit Ganzzahlen beliebiger Größe. Deren
Arithmetik ist selbstredend aufwendiger und langsamer, als maschineninterne
\texttt{Integer}-Arithmetik. Daher haben wir uns entschlossen eigene 
\Clang-Bibliotheken anzulegen, die auf einfacher (jedoch begrenzter) 
\texttt{Integer}-Arithmetik basieren.

\subsection{Beschreibung von Elementen endlicher Körper}
\label{sub:beschreibung_endliche_koerper}
Die Implementierung von Primkörpern ist freilich kanonisch. Daher brauchen wir
an dieser Stelle nicht viele Worte verlieren, da wir auf der Suche nach
primitiv und vollständig normalen Elementen ohnehin nur in Erweiterungen von
Graden größer $1$ zu rechnen haben.

Sei also $\F_q$ ein endlicher Körper von Charakteristik $p$ und $q = p^r$
für $r>1$.
Wie auch in \sage üblich, haben wir uns entschieden, bei der programmatischen
Beschreibung die Isomorphie
\[ \F_q \speq\cong \F_p[x] \big/ (f(x))\]
mit $f(x) \in F_p[x]$ irreduzibel, monisch von Grad $r$ zu nutzen. 
Also wird ein Element $w \in \F_q$ als Array der Länge $r+1$ beschrieben,
wobei die nullte Stelle des Arrays auch den Koeffizienten von $x^0$ meint, und
alle Berechnungen (insb. Multiplikation) modulo $f(x)$ ausgeführt.

Es hat sich herausgestellt, dass es von Vorteil ist, neben dem Koeffizienten
tragenden Array ein weiteres Array mitzuführen, welches die
Indizes speichert, deren zugehörige Koeffizienten nicht verschwinden. Letztlich
fehlt noch, wie es in \Clang üblich und notwendig ist, die Länge des
Indexarrays zu speichern und wir erhalten den Datentyp @struct FFElem@.

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=15]
/**
 * Finite Field Element. 
 * 
 * !! idcs must be in desc order !!
 *
 * Uses int arrays, i.e. you must not consider 
 * PrimeFields of order p with  (p-1)*(p-1) > INT_MAX
 */
struct FFElem{
    int *el;
    int *idcs;
    int len;
};
\end{ccode}

@len@ gibt immer die Länge von @idcs@ an. Zusätzlich fordern wir noch folgende
Eigenschaften, die den Umgang mit @struct FFElem@ erleichtern.

\begin{invariante}
  \label{invariante:desc_order}
  Für das Indexarray @idcs@ eines @struct FFElem@ sei sichergestellt, 
  dass die Werte stets in absteigender Reihenfolge sortiert sind. 
\end{invariante}

\begin{invariante}
  \label{invariante:array_len}
  Bei der Benutzung von @struct FFElem@ sei sichergestellt, 
  dass die Länge aller auftretenden Arrays dem Grade der 
  Körpererweiterung über dem jeweiligen Primkörper entspricht
\end{invariante}

\thref{invariante:desc_order} erleichtert den Zugriff auf
den Grad des Elements (also seinen Grad als Polynom in
$\F_p[x]\big/(f(x))$). Letztere Invariante stellt sicher, dass durch
Veränderung eines @struct FFElem@ (beispielsweise Arithmetik) kein 
Speicherzugriffsfehler auftritt.

\begin{beispiel}
  Wollen wir das Element 
  \[ w := x^8 + 2*x^6 + x^2 + 2 \in \F_3[x]\]
  des endlichen Körpers $\F_{3^{10}}$ 
  (wir verzichten auf Angabe eines Minimalpolynoms, da es hier keine
  Rolle spielt) in obiger Darstellung beschreiben, so müssen wir \Clang-üblich
  Speicher allokieren und die Arrays in passender Länge anlegen:
  \begin{cexample}
    struct FFElem *w = malloc(sizeof(struct FFElem));
    w->el = (int[]) {2, (*\ttgray 0*), 1, (*\ttgray 0, 0, 0,*) 2, (*\ttgray 0,*) 1, (*\ttgray 0*)};
    w->idcs = (int[]) {8, 6, 2, 0, (*\ttgray 0, 0, 0, 0, 0, 0*)};
    w->len = 4;
  \end{cexample}
  Der besseren Lesbarkeit zu Gute haben wir die ungenutzten Indizes und die 
  verschwindenden Koeffizienten mit @0@ aufgefüllt und ausgegraut. 
  Man überlege sich jedoch,
  dass lediglich eine einzige @0@ notwendig ist und alle anderen 
  beliebig ersetzt werden könnten. Beispielsweise ist
  \begin{cexample}
    struct FFElem *w = malloc(sizeof(struct FFElem));
    w->el = (int[]) {2, (*\ttgray -10*), 1, (*\ttgray 100, -2, -3,*) 2, (*\ttgray -4,*) 1, (*\ttgray -8*)};
    w->idcs = (int[]) {8, 6, 2, 0, (*\ttgray -3, -2, -5, -1, -1, -1*)};
    w->len = 4;
  \end{cexample}
  mit obiger Beschreibung identisch.
\end{beispiel}


\subsubsection{Hilfsfunktionen zum Anlegen und Löschen}

Da \Clang ohne \emph{Garbage-Collection} auskommt, muss man selbst für die
entsprechende Speicherverwaltung sorgen. Dies erleichtern die Funktionen
@mallocFFElem@ und @freeFFElem@.

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=30]
inline struct FFElem *mallocFFElem(int m){
    struct FFElem *ff = malloc(sizeof(struct FFElem));
    ff->el = malloc(m*sizeof(int));
    ff->idcs = malloc(m*sizeof(int));
    ff->len = 0;
    return ff;
}
\end{ccode}

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=37]
inline void freeFFElem(struct FFElem *ff){
    free(ff->el);
    free(ff->idcs);
    free(ff);
}
\end{ccode}

Schließlich führen wir noch eine Funktion ein, die den Inhalt eines
@struct FFElem@s in ein neues kopiert. Dieses muss aber bereits allokiert sein!


\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=50]
/**
 * Copies the content of ff1 into ff2
 *
 * !! ff2 must be malloced!
 */
inline void copyFFElem(struct FFElem *ff1, struct FFElem *ff2){
    if(ff1 == ff2) return;
    int i;
    for(i=0;i < ff1->len;i++){
        ff2->idcs[i] = ff1->idcs[i];
        ff2->el[ ff1->idcs[i] ] = ff1->el[ ff1->idcs[i] ];
    }
    ff2->len = ff1->len;
}
\end{ccode}

\subsection{Arithmetik in endlichen Körpern}
\label{sub:arithmetik_in_endlichen_körpern}


\subsubsection{Additions- und Multiplikationstabellen}
Will man Arithmetik mit @struct FFElems@ betreiben, so stellt sich sicherlich
am Anfang die Frage, wie die Arithmetik im Primkörper 
$\F_p = \{0,1,\ldots,p-1\}$
aussehen möge. Da
die @FFElem@s auf @int@-Arrays basieren liegt es nahe, die Addition bzw.
Multiplikation zweier Elemente $a,b\in \F_p$ durch die integrierten Funktionen
@($a$+$b$) % $p$@ 
und @($a$*$b$) % $p$@
zu implementieren. Es hat sich jedoch herausgestellt, dass dies vergleichsweise
langsam ist. Insbesondere bei kleinen Primzahlen 
(die hier betrachteten Primzahlen waren kleiner gleich 11) 
hat sich das Anlegen einer
Additions- und einer Multiplikationstabelle bewährt. Diese sind @int@-Arrays,
sodass die @($a$+$b$)@-te Stelle der Additions- und die 
@($a$*$b$)@-te Stelle der Multiplikationstabelle gerade das Ergebnis der
jeweiligen Rechnung in $\F_p$ liefert.

\begin{bemerkung}
  Um sich nicht um vorzeichenbehaftete Werte kümmern zu müssen, überdecken die
  Tabellen auch negative Bereiche und daher ist eine Additionstabelle in $\F_p$
  stets von Länge $4(p-1)+1$ und eine Multiplikationstabelle von
  Länge $2(p-1)^2+1$.
\end{bemerkung}

\begin{beispiel}
  Betreiben wir Arithmetik in $\F_3$, so legen wir eine Additions- bzw.
  Multiplikationstabelle wie folgt an und stellen durch eine Verschiebung des
  Pointers sicher, dass auch vorzeichenbehaftete Rechnungen richtig erfasst
  werden können.
  \begin{cexample}
    int addTableRaw[] = {2, 0, 1, 2, 0, 1, 2, 0, 1};
    int initialAddShift = 4;
    int *addTable = addTableRaw+initialAddShift;
    int multTableRaw[] = {2, 0, 1, 2, 0, 1, 2, 0, 1};
    int initialMultShift = 4;
    int *multTable = multTableRaw+initialMultShift;
  \end{cexample}
  Führen wir nun Rechnungen durch können wir diese nutzen:
  \begin{cexample}
    addTable[ 2+1 ]  // == 0 
    addTable[ 0-2 ]  // == 1
    multTable[ 2*2 ]  // == 1
  \end{cexample}
\end{beispiel}


\subsubsection{Addition}
Aufgrund der effizienteren Darstellung der Elemente endlicher Körper durch
Speicherung ihrer Indizes, ist die Addition nicht lediglich gegeben durch
komponentenweise Betrachtung, sondern erfordert etwas mehr Aufwand.

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=226]
/**
 * Adds two FFElems.
 *
 * !! ff1 may be same as ret !!
 * !! ff2 must not be same as ret !!
 */
inline void addFFElem(struct FFElem *ff1, struct FFElem *ff2,
        struct FFElem *ret,
        int *tmp,
        int *multTable, int *addTable){
    int i=0,j=0,k=0, i2;
    bool end = false;
    //handle trivial cases
    if(ff1->len == 0){
        copyFFElem(ff2,ret);
        return;
    }
    if(ff2->len == 0){
        copyFFElem(ff1,ret);
        return;
    }
    copyArray(ff1->idcs,tmp,ff1->len);
    while( end == false ){
        while( tmp[i] != ff2->idcs[j] ){
            if( tmp[i] > ff2->idcs[j] ){
                ret->el[ tmp[i] ] = ff1->el[ tmp[i] ];
                ret->idcs[k] = tmp[i];
                i++; k++;
            }else if( tmp[i] < ff2->idcs[j] ){
                ret->el[ ff2->idcs[j] ] = ff2->el[ ff2->idcs[j] ];
                ret->idcs[k] = ff2->idcs[j];
                j++; k++;
            }
            if(i == ff1->len || j == ff2->len){
                end = true;
                break;
            }

        }
        if(end == true) break;
        //tmp[i] == ff2->idcs[j]
        i2 = tmp[i];
        ret->el[i2] = addTable[ ff1->el[i2] + ff2->el[i2] ];
        if(ret->el[i2] != 0){
            ret->idcs[k] = i2;
            k++;
        }
        i++; j++;
        if(i == ff1->len || j == ff2->len) end = true;
    }
    //add rest of ff1 or ff2
    if(i != ff1->len ){
        while(i<ff1->len){
            ret->el[ tmp[i] ] = ff1->el[ tmp[i] ];
            ret->idcs[k] = tmp[i];
            i++; k++;
        }
    }else if(j != ff2->len){
        while(j<ff2->len){
            ret->el[ ff2->idcs[j] ] = ff2->el[ ff2->idcs[j] ];
            ret->idcs[k] = ff2->idcs[j];
            j++; k++;
        }
    }
    ret->len = k;
}
\end{ccode}  

Wie später aus der Beschreibung anderer Algorithmen hervorgeht, ist es von
Vorteil, wenn das Ergebnis einer Addition bereits eines der beiden addierten
Elemente ist. Auf diese Weise spart man das Anlegen unnötiger Hilfs-@FFElem@s.
Wie man schnell einsieht, werden jeweils nur die beiden Indexarrays durchlaufen
und lediglich wenn diese gleich sind, muss eine Addition ausgeführt werden;
ansonsten reicht es den jeweiligen Koeffizienten zu übernehmen.


\subsubsection{Multiplikation}
Wir haben uns entschieden, keine speziellen Multiplikationsalgorithmen 
(wie Karatsuba oder FFT-basierte Algorithmen) zu implementieren, da
die hier betrachteten Erweiterungen nicht von Graden sind, in denen jene
Algorithmen ihre Vorteile ausspielen könnten.

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=302]
/**
 * Multiplies two FFElems and reduces the result by mipo.
 *
 * !! tmp must have at least length m!
 * !! ret must be malloced!
 */
inline void multiplyFFElem(struct FFElem *ff1, struct FFElem *ff2, 
        struct FFElem *ret, 
        struct FFElem *mipo, int *tmp, int m,
        int *multTable, int *addTable){
    /* 
     * catch trivial cases
     */
    if(ff1->len == 0 || ff2->len == 0){
        ret->len = 0;
        return;
    }
    if(ff1->len == 1 && ff1->idcs[0] == 0 && ff1->el[0] == 1){
        copyFFElem(ff2, ret);
        return;
    }
    if(ff2->len == 1 && ff2->idcs[0] == 0 && ff2->el[0] == 1){
        copyFFElem(ff1, ret);
        return;
    }

    /*
     * Do multiplication
     */
    int maxlen = ff1->idcs[0] + ff2->idcs[0] + 1;
    int i,j,i2,j2,k;
    int max2 = maxlen;
    if( maxlen > m ){
        max2 = m;
        initPoly(tmp,maxlen-m);
    }
    initPoly(ret->el,max2);
    //multiply 
    for(i=0;i<(ff1->len);i++){
        for(j=0;j<(ff2->len);j++){
            i2 = ff1->idcs[i];
            j2 = ff2->idcs[j];
            k = i2+j2;
            if(k<m){
                ret->el[k] = addTable[ ret->el[k] + 
                    multTable[ ff1->el[i2] * ff2->el[j2] ] ];
            }else{
                tmp[k-m] = addTable[ tmp[k-m] +
                    multTable[ ff1->el[i2] * ff2->el[j2] ] ];
            }
        }
    }
    
    /*
     * Reduce mod mipo
     */
    if(maxlen > m){
        int quo;
        for(i=maxlen-m-1;i>=0;i--){
            quo = tmp[i];
            if(quo == 0) continue;
            for(j=0;j<(mipo->len); j++){
                j2 = mipo->idcs[j];
                k = i+j2;
                if(k>=m){
                    tmp[k-m] = addTable[ tmp[k-m] - 
                        multTable[ mipo->el[j2]*quo ] ];
                }else{
                    ret->el[k] = addTable[ ret->el[k] - 
                        multTable[ mipo->el[j2]*quo ] ];
                }
            }
        }
    }

    /*
     * Recalc indices
     */
    i2 = 0;
    for(i=max2-1;i>=0;i--){
        if(ret->el[i] != 0){
            ret->idcs[i2] = i;
            i2++;
        }
    }
    ret->len = i2;
}
\end{ccode}
Außer den beiden zu multiplizierenden @FFElem@s muss man natürlich das
Minimalpolynom des zu Grunde liegenden Körpers und dessen Grad über dem
Primkörper -- hier mit @int m@ bezeichnet -- mit übergeben.
Leider war es an dieser Stelle im Gegensatz zur Addition nicht 
möglich, die Indizes des Produkts direkt zu berechnen, da es sich bei den
Koeffizienten des Produkts ja Summen von Produkten von Koeffizienten der beiden
Faktoren handelt. Daher muss nach der
Reduktion modulo Minimalpolynoms eine Neuberechnung der Indizes erfolgen.

\subsubsection{Quadratur}
Im Hinblick auf das Testen von @struct FFElem@s auf Primitivität und dem damit
verbundenen Potenzieren, existiert eine separate Funktion zur Quadrierung eines 
@FFElem@s. Es ist klar, dass beim Quadrieren weniger Produkte und Summen
berechnet werden müssen als bei einer allgemeinen Multiplikation.
\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=404]
/**
 * Squares an FFElem
 *
 * !! ff is not modified !!
 * !! tmp must have at least length m !!
 */
inline void squareFFElem(struct FFElem *ff, struct FFElem *mipo,
        struct FFElem *ret, int *tmp, int m,
        int *multTable, int *addTable){
    /* 
     * catch trivial cases
     */
    if(ff->len == 0){
        copyFFElem(ff,ret);
        return;
    }
    if(ff->len == 1 && ff->idcs[0] == 0 && ff->el[0] == 1){
        copyFFElem(ff,ret);
        return;
    }

    /*
     * Do multiplication
     */
    int maxlen = 2*ff->idcs[0] + 1;
    int i,j,i2,j2,k;
    int max2 = maxlen;
    if( maxlen > m ){
        max2 = m;
        initPoly(tmp,maxlen-m);
    }
    initPoly(ret->el,max2);
    for(i=0;i<(ff->len);i++){
        // same index must be squared
        i2 = ff->idcs[i];
        k = 2*i2;
        if(k<m){
            ret->el[k] = addTable[ ret->el[k] + 
                multTable[ ff->el[i2]*ff->el[i2] ] ];
        }else{
            tmp[k-m] = addTable[ tmp[k-m] +
                multTable[ ff->el[i2]*ff->el[i2] ] ];
        }
        // other indices only multipied and doubled
        for(j=i+1;j<(ff->len);j++){
            i2 = ff->idcs[i];
            j2 = ff->idcs[j];
            k = i2+j2;
            if(k<m){
                ret->el[k] = addTable[ ret->el[k] + 
                    multTable[ 2 * multTable[ ff->el[i2] * ff->el[j2] ] ] ];
            }else{
                tmp[k-m] = addTable[ tmp[k-m] +
                    multTable[ 2 * multTable[ ff->el[i2] * ff->el[j2] ] ]];
            }
        }
    }
    /*
     * Reduce mod mipo
     */
    if(maxlen > m){
        int quo;
        for(i=maxlen-m-1;i>=0;i--){
            quo = tmp[i];
            if(quo == 0) continue;
            for(j=0;j<(mipo->len); j++){
                j2 = mipo->idcs[j];
                k = i+j2;
                if(k>=m){
                    tmp[k-m] = addTable[ tmp[k-m] - 
                        multTable[ mipo->el[j2]*quo ] ];
                }else{
                    ret->el[k] = addTable[ ret->el[k] - 
                        multTable[ mipo->el[j2]*quo ] ];
                }
            }
        }
    }

    /*
     * Recalc indices
     */
    i2 = 0;
    for(i=max2-1;i>=0;i--){
        if(ret->el[i] != 0){
            ret->idcs[i2] = i;
            i2++;
        }
    }
    ret->len = i2;
}
\end{ccode}


\subsection{Matrizen und Polynome über endlichen Körpern}

\subsubsection{Matrizen und Matrixmultiplikation}

Nach \thref{satz:frob_auto} ist das Potenzieren mit der Charakteristik in
endlichen Körpern eine lineare Abbildung. Dies wollen wir Nutzen und haben
daher als Darstellung von Matrizen über endlichen Körpern naheliegenderweise
ein Array aus @FFElem@s gewählt.

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=515]
/**
 * Matrix multiplication
 *
 * !! tmp must have at least length m!
 */
inline void matmul(struct FFElem **mat, struct FFElem *ff,
        struct FFElem *ret, 
        int m, int *multTable, int *addTable){
    int i,j,i2, row;
    bool end;
    for(row=0;row<m;row++){
        ret->el[row] = 0;
        i=0; j=0;
        end = false;
        while(end == false){
            while(ff->idcs[i] != mat[row]->idcs[j]){
                if(ff->idcs[i] > mat[row]->idcs[j]) i++;
                else if(ff->idcs[i] < mat[row]->idcs[j]) j++;
                if(i == ff->len || j == mat[row]->len){
                    end = true;
                    break;
                }
            }
            if(end == true) break;
            i2 = ff->idcs[i]; // == mat[row]->idcs[j]
            ret->el[row] = addTable[ ret->el[row] 
                + multTable[ mat[row]->el[i2]*ff->el[i2] ] ];
            i++;
            j++;
            if(i==ff->len || j==mat[row]->len) end = true;
        }
    }
    i2 = 0;
    for(i=m-1;i>=0;i--){
        if(ret->el[i] != 0){
            ret->idcs[i2] = i;
            i2++;
        }
    }
    ret->len = i2;
}
\end{ccode}

Hier wird -- anders als bei der Addition -- nur nach den gemeinsamen Indizes
gesucht (alle anderen Produkte sind schließlich 0). 
\thref{invariante:desc_order} stellt dabei wiederum sicher, dass das hier
aufgeführte Verfahren funktioniert.

Ferner existiert eine Funktion, die das Freigeben von Matrizen erleichtert.

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=43]
inline void freeFFElemMatrix(struct FFElem **mat, int len){
    if(mat==0) return;
    int i;
    for(i=0;i<len;i++) freeFFElem(mat[i]);
    free(mat);
}
\end{ccode}


\subsubsection{Polynome}
Im Hinblick auf das Testen von @FFElem@s auf vollständige Normalität 
(bzw. vollständige Erzeuger-Eigenschaft) müssen wir einen Weg wählen, Polynome
über endlichen Körpern darzustellen; also Polynome deren Koeffizienten 
@FFElem@s sind. Dazu führen wir ein eigenes @struct@ ein.

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=144]
struct FFPoly{
    struct FFElem **poly;
    int lenPoly;
};
\end{ccode}


\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=149]
inline struct FFPoly *mallocFFPoly(int m, int lenPoly){
    struct FFPoly *poly = malloc(lenPoly*sizeof(struct FFElem*));
    poly->lenPoly = lenPoly;
    int i;
    for(i=0;i<lenPoly;i++) poly->poly[i] = mallocFFElem(m);
    return poly;
}
\end{ccode}  

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=157]
inline void freeFFPoly(struct FFPoly *poly){
    int i;
    for(i=0;i<poly->lenPoly;i++) freeFFElem(poly->poly[i]);
    free(poly->poly);
    free(poly);
}
\end{ccode}  


\section{Potenzieren und Primitivitätstest}

\subsection{Potenzieren}
Für das Potenzieren von @FFElem@s wurde stets ein Square-and-Multiply-Ansatz
verwendet. Da in endlichen Körpern jedoch das Potenzieren mit der
Charakteristik eine lineare Abbildung darstellt, ist es a priori nicht unklug
eine $p$-adische Square-and-Multiply-Variante zu wählen. Es hat sich jedoch
herausgestellt, dass in den meisten Fällen normales Square-and-Multiply
schneller ist als sein $p$-adisches Pendant. Dies veranschaulicht auch
nachstehendes Beispiel.

\begin{beispiel}
  Sei $u \in E := \F_{3^4}$ und zu berechnen sei $u^{16}$, so stellen wir zunächst
  $16$ binär und $3$-adisch da:
  \[ 16 \speq= 10000_2 \speq= 121_3 \,.\]
  Damit gilt
  \[ u^{16} \speq= ((u^2)^2)^2)^2 \speq= (u^3\cdot u\cdot u)^3\cdot u\,.\]
  In einer Implementierung sehen wir also, dass die binäre Exponentiation 
  $4$ Quadrierungen „kostet“, die $3$-adische Version 
  hingegen $2$ Matrixmultiplikationen und $3$ Multiplikationen.
  Da in der Regel allgemeine Multiplikationen teuer sind, wäre in diesem Fall
  die binäre Variante wohl die bessere Wahl.\\
  Wollen wir $u^{10}$ berechnen, so sehen wir aus
  \[ 10 \speq= 1010_2 \speq= 101_3\,,\]
  dass in diesem Fall die binäre Exponentiation 4 Quadierungen und eine
  allgemeine Multiplikation erfordert, die $3$-adische Variante jedoch nur 
  $2$ Matrixmultiplikationen und $1$ allgemeine Multiplikation. Letzteres lässt
  sich sogar auf eine Matrixmultiplikation reduzieren, berechnet man die
  Darstellungsmatrix der linearen Abbildung $E\to E,\ x\mapsto x^9$ bereits
  vorher! Die beiden Varianten der Berechnung würden 
  in diesem Fall also wie folgt von Statten gehen:
  \[ u^{10} \speq= ((u^2)^2\cdot u)^2 \speq= u^9\cdot u\,.\]
\end{beispiel}

Nachstehend werden nun die beiden Varianten der Implementierung der Potenzierung
aufgeführt. Wir beginnen mit $p$-adischem Square-and-Multiply. Zu bemerken ist,
dass die Potenz bereits in $p$-adischer Darstellung als @int@-Array übergeben
werden muss. Zudem werden vermeidbare Matrixmultiplikationen (vgl. obiges
Beispiel) nicht durchgeführt und es ist sicherzustellen, 
dass @struct FFElem **matCharac@ als @struct FFElem*@-Array
von Länge $(l+1)m$ ist, wobei $l$ die Länge
des maximal auftretenden $0$-Intervalls in der $p$-adischen Darstellung meint 
(in obigem Beispiel bei $u^{10}$ wäre $l=1$).


\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=562, label=lst:powerffelem]
/**
 * Square and multiply in charac
 * mat is powering by charac
 *
 * !! ff is modified !!
 */
inline void powerFFElem(struct FFElem *ff, struct FFElem *mipo,
        struct FFElem *ret, 
        int m, int *power, int powerLen,
        struct FFElem **matCharac, int *tmp, struct FFElem *ffTmp,
        int *multTable, int *addTable){
    int i,j,k;
    int lenCurGap = 0;
    struct FFElem *ffSwitch = 0;
    struct FFElem *ffRetInt = ret;
    // init ret to 1
    ffRetInt->el[0] = 1; ffRetInt->idcs[0] = 0; ffRetInt->len = 1;
    for(j=powerLen-1;j>=0;j--){
        for(k=0;k<power[j];k++){
            multiplyFFElem(ffRetInt,ff,ffTmp, mipo,tmp,m,multTable,addTable);
            ffSwitch = ffRetInt; ffRetInt = ffTmp; ffTmp = ffSwitch;
        }
        if(j==0 || power[j-1] == 0){
            lenCurGap++;
            continue;
        }
        matmul(matCharac+lenCurGap*m, ff, ffTmp, m, multTable,addTable);
        ffSwitch = ff; ff = ffTmp; ffTmp = ffSwitch;
        lenCurGap = 0;
    }
    copyFFElem(ffRetInt,ret);
}
\end{ccode}


Als nächstes folgt die standardmäßige binäre Exponentiation. Auch hier wird die
Potenz bereits in Binärdarstellung erwartet.

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=602, label=lst:powerffelemsqm]
/**
 * Square and multiply
 *
 * !! ff is modified !!
 */
inline void powerFFElemSqM(struct FFElem *ff, struct FFElem *mipo,
        struct FFElem *ret, 
        int m, int *power, int powerLen,
        int *tmp, struct FFElem *ffTmp,
        int *multTable, int *addTable){
    int i,j,k;
    int lenCurGap = 0;
    struct FFElem *ffSwitch = 0;
    struct FFElem *ffRetInt = ret;
    // init ret to 1
    ffRetInt->el[0] = 1; ffRetInt->idcs[0] = 0; ffRetInt->len = 1;
    for(j=powerLen-1;j>=0;j--){
        if(power[j] == 1){
            multiplyFFElem(ffRetInt,ff,ffTmp, mipo,tmp,m,multTable,addTable);
            //switch ffTmp and ffRetInt
            ffSwitch = ffRetInt; ffRetInt = ffTmp; ffTmp = ffSwitch;
        }
        if(j>0){
            squareFFElem(ff,mipo,ffTmp,tmp,m,multTable,addTable);
            //switch ffTmp and ff
            ffSwitch = ff; ff = ffTmp; ffTmp = ffSwitch;
        }
    }
    copyFFElem(ffRetInt,ret);
}
\end{ccode}


\subsection{Primitivitätstest}
\label{subsub:primitivitaetstest}

Beim Testen eines Elements eines endlichen Körpers auf Primitivität bedienen
wir uns des wohlbekannten Satz von Lagrange aus der Gruppentheorie und geben
zunächst ein kleines Lemma an, auf dem der dann folgende Algorithmus basiert.

\begin{lemma}
  Sei $u \in \F_q$ und
  \[ q-1 \speq= p_1^{\nu_1}\cdot\ldots\cdot p_r^{\nu_r}\]
  die Primfaktorzerlegung von $q-1$. Definiere
  für alle $i=1,\dots,r$
  \[ \bar p_i \speq{:=}  \frac{q-1}{p_i} \speq=
    p_1^{\nu_1}\cdot \ldots\cdot p_{i-1}^{\nu_{i-1}} \cdot
    p_i^{\nu_i-1}\cdot p_{i+1}^{\nu_{i+1}}\cdot\ldots\cdot p_r^{\nu_r}\,.\]
  Dann gilt: $u$ ist primitiv genau dann, wenn
  \[ u^{\bar p_i} \speq\neq 1\quad\forall i=1,\ldots,r \,.\]
\end{lemma}
\begin{proof}
  Klar.
\end{proof}

Es bleibt jedoch immer noch offen diese $r$ Potenzierungen möglichst gut
zu organisieren. 
%Nehmen wir an, die Primzahlen sind in der Primfaktorzerlegung
%\[ q-1 \speq= p_1^{\nu_1}\cdot\ldots\cdot p_r^{\nu_r}\]
%aufsteigend sortiert, also $p_1<p_2<\ldots < p_r$, so
%hat sich als besonders hilfreich erwiesen, die Potenzen $\bar n_i$ auf
%Basis der Potenzen
%\begin{itemize}
  %\item $d := \ggT\{ \bar n_i:\ i=1,\ldots,r\}$ und 
  %\item $d' := \ggT\{ \frac{\bar n_i}{d}:\ i=1,\ldots,r-1\}$
%\end{itemize}
%durchzuführen und die bereits berechneten Potenzen zu nutzen, 
%wie nachstehendes Beispiel veranschaulicht.
Dazu formulieren wir folgendes Lemma, das die Arbeit der Aufwand der Berechnung
in vielen Fällen deutlich verringert hat.

\begin{lemma}
  Sei $q-1 = p_1^{\nu_1}\cdot\ldots\cdot p_r^{\nu_r}$ die 
  absteigend sortierte Primfaktorzerlegung
  von $q-1$, d.h. $p_1>p_2>\ldots>p_r$. Notiere
  \begin{itemize}
    \item $\bar p_i := \tfrac{q-1}{p_i}$,
    \item $d := \ggT\{ \bar p_i:\ i=1,\ldots,r\}$, \quad
      $d' := \ggT\{ \frac{\bar p_i}{d}:\ i=2,\ldots,r\}$, 
    \item $v := u^d$, \quad $w := v^{d'}$,
    \item $\bar n_1 := \tfrac{\bar p_1}{d}$, \quad
      $\bar n_i := \tfrac{\bar p_i}{d\, d'}$ für $i=2,\ldots,r$,
    \item $u_2 := w^{\bar n_2}$ und 
      $u_i := w^{\bar n_i - \bar n_{i-1}}$ für $i=3,\ldots,r$.
  \end{itemize}
  Es gilt: $u \in \F_q$ ist genau dann nicht primitiv, falls eine der
  nachstehenden Bedingungen erfüllt ist:
  \begin{enumerate}
    \item $v \speq= 1$.
    \item $v^{\bar n_1} \speq= 1$.
    \item $w \speq= 1$.
    \item $u_2 \speq= 1$.
    \item $u_i\cdot u_{i-1} \speq= 1$ für ein $i=3,\ldots r$.
  \end{enumerate}
  Ferner gilt: Die Differenzen $\bar n_i-\bar n_{i-1}$ für 
  $i=3,\ldots,r$ sind alle größer $0$.
\end{lemma}
\begin{proof}
  Nach vorausgehendem Lemma müssen wir also zeigen, dass für alle
  $i=1,\ldots,r$ überprüft wird, ob $u^{\bar p_i} \neq 1$. Genau dann ist
  $u$ primitiv. Zunächst erkennen wir, dass mit 
  \[ v^{\bar n_1} \speq= u^{\bar p_1}\]
  und 
  \[ u_2 \speq= w^{\bar n_2} \speq= u^{\bar p_2} \]
  die ersten beiden Kofaktoren abgedeckt wären.
  Ist $v = 1$ bzw. $w = 1$ hat $u$ Ordnung $d$ bzw. $d\,d'$, ist also nicht
  primitiv. Sei also $i \in \{3,\ldots,r\}$, so folgern wir
  \[ u_i \cdot u_{i-1} \speq= 
    w^{\bar n_i - \bar n_{i-1}} \cdot u_{i-1} \speq=
    w^{\bar n_i - \bar n_{i-1} + \bar n_{i-1}} \speq= 
    w^{\bar n_i} \speq= u^{\bar p_i}\,.\]
  Zuletzt erkennen wir, dass aufgrund der absteigenden Sortierung der $p_i$s,
  die $\bar p_i$s und damit die $\bar n_i$s aufsteigend sortiert sind, also
  $\bar n_i - \bar n_{i-1} > 0$ für alle $i=3,\ldots,r$.
\end{proof}


\begin{beispiel}
  Sei $u \in \F_{3^{10}}$. Da
  \[ 3^{10}-1 \speq= 61 \cdot 11^{2} \cdot 2^{3} \,,\]
  sind folgende Potenzen von $u$ zu berechnen:
  \[ \begin{array}{l@{\ =\ }l@{}l@{}l@{\ =\ }l}
    \bar p_1 & 2^3 \cdot & 11^2 && 968\,, \\
    \bar p_2 & 2^3 \cdot & 11 & \cdot 61 & 5368\,,\\
    \bar p_3 & 2^2 \cdot & 11^2 & \cdot 61 & 29524\,.
    \end{array}\]
  Wir sehen jedoch dass die Potenzen
  \[ d \speq{:=} \ggT\{ \bar p_1,\bar p_2,\bar p_3\} 
    \speq= 2^2\cdot 11 \speq= 44 \]
  und 
  \[ d' \speq{:=} \ggT\{ \tfrac{\bar p_2}{d},\tfrac{\bar p_3}{d}\} \speq= 61\]
  uns die Arbeit erheblich erleichtern können:
  Wir berechnen $v := u^d = u^{44}$ und 
  $w := v^{d'} = v^{61}$ separat, so schreiben sich die restlichen Potenzen 
  für $\bar n_2 := 2$ und $\bar n_3 := 11$ wie folgt:
  \[ \begin{array}{l@{\ =\ }l@{}l}
    u^{\bar p_1} & v^2\,, \\
    u^{\bar p_2} & u_2 &\speq= w^2\,, \\
    u^{\bar p_3} & u_3\cdot u_2 &\speq= w^9 \cdot u_2 \,.
  \end{array} \]
  Es ist klar, dass in diesem Beispiel obiges Vorgehen eine erhebliche
  Verkleinerung der zu berechnenden Potenzen liefert, die jedoch nicht in allen
  Fällen erwartet werden kann.
\end{beispiel}


In nachstehender Implementierung sind die Potenzen $d$
mit @commonBarFactor@ und $d'$ mit @commonBiggestBarFactor@ bezeichnet und
werden in $p$-adischer bzw. binärer Darstellung erwartet.  
Alle anderen zu berechnenden Potenzen, d.h. nach obigem Lemma die Liste
\[ [\bar n_1,\ \bar n_2,\ \bar n_3-\bar n_2,\ldots,\ 
  \bar n_r - \bar n_{r-1}]\,, \]
werden in 
@barFactors@ wiederum in $p$-adischer bzw. binärer Darstellung übergeben.
@barFactors@ ist dabei ein einziges @int@-Array,
wobei die jeweilige Länge der einzelnen Faktoren in dem @int@-Array
@lenBarFactors@ zu hinterlegen ist. Wie im Quelltext bemerkt, wird 
die Exponentiation $p$-adisch durchgeführt (siehe \autoref{lst:powerffelem}),
falls @matCharac@ ungleich @0@ ist, ansonsten binär 
(siehe \autoref{lst:powerffelemsqm}), wobei natürlich sicherzustellen ist, dass
die Potenzen in passender Darstellung vorliegen.

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=666, label=lst:isPrimitive]
/**
 * Test if element is primitive.
 *
 * !! if matCharac is Zero, all powers are assumed as binary arrays !!
 *
 * !! fff,ffTmp,ffTmp2,ffTmp3,ffRet must be malloced !!
 * !! x is NOT modified !!
 */
inline bool isPrimitive(struct FFElem *ff, struct FFElem *mipo,
        int m,
        int *barFactors, int *lenBarFactors, int countBarFactors,
        int *commonBarFactor, int lenCommonBarFactor,
        int *commonBiggestBarFactor, int lenCommonBiggestBarFactor,
        struct FFElem **matCharac, 
        struct FFElem *fff, struct FFElem *ffff, struct FFElem *ffTmp,
        struct FFElem *ffTmp2, struct FFElem *ffRet, 
        int *tmp, int *multTable, int *addTable){
    int i;
    int curPos = 0;
    bool binarySqM = (matCharac == 0);
    struct FFElem *ffSwitch = 0;

    copyFFElem(ff,fff);
    // all barFactors are power of commonBarFactor
    if(binarySqM)
        powerFFElemSqM(fff,mipo,ffTmp,
                m,commonBarFactor,lenCommonBarFactor,
                tmp,ffTmp2,
                multTable,addTable);
    else 
        powerFFElem(fff,mipo,ffTmp,
                m,commonBarFactor,lenCommonBarFactor,
                matCharac,tmp,ffTmp2,
                multTable,addTable);
    if(isOne(ffTmp)) return false;
    //switch ffTmp and fff
    ffSwitch = fff; fff = ffTmp; ffTmp = ffSwitch;
    copyFFElem(fff,ffff);
    //test first barFactor
    if(binarySqM)
        powerFFElemSqM(ffff,mipo,ffTmp,
                m,barFactors,lenBarFactors[0],
                tmp,ffTmp2,
                multTable,addTable);
    else
        powerFFElem(ffff,mipo,ffTmp,
                m,barFactors,lenBarFactors[0],
                matCharac,tmp,ffTmp2,
                multTable,addTable);
    if(isOne(ffTmp)) return false;
    curPos += lenBarFactors[0];
    //test further factors which are powers of commonBiggestBarFactor
    //so first, calc y^commonBiggestBarFactor
    copyFFElem(fff, ffff);
    if(binarySqM)
        powerFFElemSqM(ffff,mipo,ffTmp,
                m,commonBiggestBarFactor,lenCommonBiggestBarFactor,
                tmp,ffTmp2,
                multTable,addTable);
    else
        powerFFElem(ffff,mipo,ffTmp,
                m,commonBiggestBarFactor,lenCommonBiggestBarFactor,
                matCharac,tmp,ffTmp2,
                multTable,addTable);
    if(isOne(ffTmp)) return false;
    ffSwitch = fff; fff = ffTmp; ffTmp = ffSwitch;
    for(i=1;i<countBarFactors;i++){
        // copy z (fff) to ffff
        copyFFElem(fff,ffff);
        // *** ffff == fff == y^commonBiggestBarFactor
        if(binarySqM)
            powerFFElemSqM(ffff, mipo, ffTmp, 
                    m,barFactors+curPos, lenBarFactors[i],
                    tmp,ffTmp2,
                    multTable,addTable);
        else
            powerFFElem(ffff, mipo, ffTmp, 
                    m,barFactors+curPos, lenBarFactors[i],
                    matCharac,tmp,ffTmp2,
                    multTable,addTable);

        if(i>1){
            multiplyFFElem(ffRet,ffTmp,ffTmp2,mipo,
                    tmp,m,multTable,addTable);
        }else{
            ffSwitch = ffTmp2; ffTmp2 = ffTmp; ffTmp = ffSwitch;
        }
        if(isOne(ffTmp2)) return false;
        curPos += lenBarFactors[i];
        ffSwitch = ffRet; ffRet = ffTmp2; ffTmp2 = ffSwitch;
    }
    return true;
}
\end{ccode}

\section{Frobenius-Auswertung und Test auf vollständige
  Erzeuger-Eigenschaft}

\subsection{Frobenius-Auswertung}

Sei wie immer $F = \F_q$ ein endlicher Körper und $E = \F_{q^m}$ eine
Körpererweiterung. Sei $\C_{k,t}$ ein verallgemeinerter
Kreisteilungsmodul über $F$ (vgl.
\thref{def:verallgemeinerter_kreisteilungsmodul}) und 
$u\in E$ ein Element, das wir als vollständigen Erzeuger 
in Betracht ziehen (vgl. \thref{def:vollst_erzeuger}). Nach 
\thref{satz:moduln_ueber_v_g} (3) ist $u$ genau dann ein vollständiger 
Erzeuger von $\C_{k,t}$, wenn
\[ \Ord_{q^d}(u) \speq= \Phi_{\nu(k),\, \frac{kt}{\nu(k)d}} \qquad
  \forall d \mid \tfrac{k\,t}{\nu(k)}\,.\]
Folglich müssen wir, um $q$-Ordnungen berechnen zu können, in der Lage sein,
für beliebige Zwischenkörper $E\mid K\mid F$ von Grad $d$ über $F$ und beliebige 
$f(x) \in K[x]$ 
\[ f(\sigma^d)(u) \in E\]
auswerten zu können, wobei wieder $\sigma: \bar F\to \bar F, x \mapsto x^q$ den
Frobenius von $F$ bezeichne. Bleibt die Frage, wie die verschiedenen
Zwischenkörper mit Hilfe der @FFElem@s gelesen werden können. Da wir $E$ jedoch
stets als Erweiterung über dem zu Grunde liegenden Primkörper betrachten 
(vgl. \autoref{sub:beschreibung_endliche_koerper}) ist dies völlig unklar.
Daher umgehen wir dieses Problem und betrachten eine beliebige Einbettung von
$K$ in $E$. Die Frage, ob man damit immer noch $q$-Ordnungen berechnen kann,
beantwortet nachstehendes Lemma.

\begin{lemma}
  \label{lemma:einbettung_egal}
  Seien $F := \F_p[y] \big/(m_F(y))$, $K := \F_p[y]\big/(m_K(y))$ und
  $E := \F_p[y]\big/(m_E(y))$ drei endliche Körper mit 
  $\deg(m_F) \mid \deg(m_K) \mid \deg(m_E)$. Notiere
  $q := p^{\deg(m_F)}$, $d := \tfrac{\deg(m_K)}{\deg(m_F)}$ und
  $\sigma: E \to E,\ v\mapsto v^q$ den Frobenius von $F$.
  Sind ferner
  \[ \alpha_1: \funcdef{K &\to& E,\\{} [y] &\mapsto& \alpha_1(y)} 
    \quad\text{und}\quad
    \alpha_2: \funcdef{K &\to& E,\\{} [y] &\mapsto& \alpha_2(y)} \]
  zwei injektive Körperhomomorphismen 
  ($[y]$ bezeichne dabei die Restklasse von $y$ in
  $\F_p[y]\big/(m_K(y))$), so gilt für $u\in E$:
  Entweder ist
  \[ \alpha_1(f)(\sigma^d)(u) \speq= 0 \quad\text{und}\quad
    \alpha_2(f)(\sigma^d)(u) \speq=0 \]
  oder
  \[ \alpha_1(f)(\sigma^d)(u) \speq\neq 0 \quad\text{und}\quad
    \alpha_2(f)(\sigma^d)(u) \speq\neq 0\,. \]
  Mit anderen Worten hängt also die Frage, ob eine Frobenius-Auswertung $0$ 
  ist oder nicht, nicht von der Wahl der konkreten Einbettung ab.
\end{lemma}
\begin{proof}
  Wir bemerken, dass sich $\alpha_1(y) \in \F_p[y]\big/(m_E(y))$ durch
  ein Polynom $\beta_1(y) \in \F_p[y]$ mit 
  $\deg(\beta_1) < \deg(m_E)$ repräsentieren lässt. Analog
  sei $\beta_2(y) \in \F_p[y]$ jenes für $\alpha_2(y)$. Da es sich bei
  $\alpha_1$ und $\alpha_2$ um injektive Körperhomomorphismen handelt, sind
  $\im \alpha_1$ und $\im\alpha_2$ wieder endliche Körper von gleicher Ordnung
  und $\beta_1(y)$ bzw. $\beta_2(y)$ sind über $\F_p$ irreduzible Polynome von
  Grad $\deg(m_K)$. Wegen der Eindeutigkeit endlicher Körper sind
  damit die Bilder von $\alpha_1$ und $\alpha_2$ als Körper isomorph, was
  obige Behauptung zeigt.
\end{proof}

%\begin{lemma}
  %\label{lemma:einbettung_egal}
  %Seien $F \mid K\mid E$ ein Turm endlicher Körper mit $[K:F] = d$ und 
  %$\sigma: \bar F\to \bar F$ der Frobenius von $F$. 
  %Sei $f(x) \in K[x]$ ein Polynom und $u\in E$. Für je zwei
  %injektive Körperhomomorphismen
  %$g,h: K\to E$ ist entweder
  %\[ h(f)(\sigma^d)(u) \speq= 0 \quad\text{und}\quad 
    %g(f)(\sigma^d)(u) \speq= 0\]
  %oder 
  %\[ h(f)(\sigma^d)(u) \speq\neq 0 \quad\text{und}\quad 
    %g(f)(\sigma^d)(u) \speq\neq 0\,,\]
  %wobei $h(f) \in E[x]$ koeffizientenweise zu lesen ist.\\
  %Mit anderen Worten hängt also die Frage, ob eine Frobenius-Auswertung $0$ 
  %ist oder nicht, nicht von der Wahl der konkreten Einbettung ab.
%\end{lemma}
%\begin{proof}
  %\marginpar{Müsste man hier ausführlicher argumentieren?}
  %Aufgrund der Eindeutigkeit endlicher Körper (z.B.
  %\thref{satz:eindeutigkeit_endlicher_koerper}) unterscheiden sich zwei
  %Einbettungen $g,h: K\to E$ lediglich um einen Automorphismus $a: E\to E$,
  %also $h = a \circ g$. Dies beweist aber bereits die Behauptung.
%\end{proof}


Damit können wir erst einmal davon ausgehen, dass die zu betrachtenden Polynome
bereits in $E[x]$ liegen; also vom Typ @FFPoly@ sind. Analog zu 
\autoref{lst:powerffelem} wird auch hier das Potenzieren durch
Matrixmultiplikation beschrieben, wobei sicherzustellen ist, dass die maximal
auftretende Matrixpotenz vorhanden ist, d.h. übergibt man ein Polynom @poly@
vom Grad $k$, so muss @mats@ als Array bestehend aus @FFElem*@ von Länge
$m\cdot k$ sein, wobei $m$ wiederum den Grad der Erweiterung von $E$ über dem
Primkörper meint. Das bedeutet insbesondere, dass die erste Matrix in @mats@
die Darstellungsmatrix zu $\sigma^1$ ist und der Fall $\sigma^0 = \id$ separat
betrachtet werden muss (vgl. Zeile \texttt{791} in \autoref{lst:applyFrob}).

Im Hinblick auf das Berechnen von $q$-Ordnungen, wo ein Körperelement meist
mehr als einmal einer Frobenius-Auswertung unterzogen werden muss, haben wir
die Möglichkeit bereitgestellt, bereits durchgeführte Matrixmultiplikationen in
@matmulCache@ zu speichern. Das Array @matmulCacheCalced@ gibt dabei an, welche
Stellen in @matmulCache@ bereits berechnet wurden. Selbstredend wird dieser 
Zwischenspeicher durch die Ausführung von @applyFrob@ fortwährend aktualisiert.

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=773, label=lst:applyFrob]
/*
 * calculates g(sigma^frobPower)(x) where g is a polynomial 
 * and sigma the frobenius
 * application of frobenius is given by mats
 */
inline void applyFrob(struct FFElem *ff, struct FFElem *mipo,
        struct FFPoly *poly,
        struct FFElem **mats,
        int frobPower, struct FFElem *ret, 
        int m, int *tmp, struct FFElem *ffTmp, struct FFElem *ffTmp2,
        struct FFElem **matmulCache, bool *matmulCacheCalced,
        int *multTable, int *addTable){
    int i,j;
        
    ret->len = 0;
    for(i=0;i<poly->lenPoly;i++){
        if(poly->poly[i]->len == 0) continue;
        j = i*frobPower-1;
        if(i>0 && matmulCacheCalced[j] == true){
            multiplyFFElem(matmulCache[j],poly->poly[i],
                    ffTmp, mipo,
                    tmp,m,multTable,addTable);
            addFFElem(ret,ffTmp,ret,tmp,multTable,addTable);
        }else{
            if(i>0){
                matmul(mats+j*m, ff, ffTmp, m, multTable,addTable);
                //update matmulCache
                copyFFElem(ffTmp, matmulCache[j]);
                matmulCacheCalced[j] = true;
            }else{
                copyFFElem(ff,ffTmp);
            }
            //go on and multiply ffTmp with current coefficient
            multiplyFFElem(ffTmp, poly->poly[i],
                    ffTmp2, mipo,
                    tmp,m,multTable,addTable);
            addFFElem(ret,ffTmp2,ret,tmp,multTable,addTable);
        }
    }
}
\end{ccode}

Falls bereits klar ist, dass für ein gegebenes Element nur eine
Frobenius-Auswertung vollzogen wird, so ist der @matmulCache@ überflüssig und
führt zur Variante @applyFrob_noCache@, die ansonsten identisch zu obigem ist.

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=827, label=lst:applyFrob_noCache]
/*
 * calculates g(sigma^frobPower)(x) where g is a polynomial 
 * and sigma the frobenius
 * application of frobenius is given by mats
 */
inline void applyFrob_noCache(struct FFElem *ff, struct FFElem *mipo,
        struct FFPoly *poly,
        struct FFElem **mats,
        int frobPower, struct FFElem *ret, 
        int m, int *tmp, struct FFElem *ffTmp, struct FFElem *ffTmp2,
        int *multTable, int *addTable){
    int i,j;
    ret->len = 0;
    
    for(i=0;i<poly->lenPoly;i++){
        if(poly->poly[i]->len == 0) continue;
        if(i>0){
            j = i*frobPower-1;
            matmul(mats+j*m, ff, ffTmp, m, multTable,addTable);
        }else{
            copyFFElem(ff,ffTmp);
        }
        multiplyFFElem(ffTmp, poly->poly[i],
                ffTmp2, mipo,
                tmp,m,multTable,addTable);
        addFFElem(ret,ffTmp2,ret,tmp,multTable,addTable);
    }
}
\end{ccode}


\subsection{Testen von vollständigen Erzeugern}

Wie bereits erwähnt ist $u\in \F_{q^m}$ über $\F_q$ genau dann ein vollständiger
Erzeuger eines verallgemeinerten Kreisteilungsmoduls $\C_{k,t}$, wenn
\[ \Ord_{q^d}(u) \speq= \Phi_{\nu(k),\, \frac{kt}{\nu(k)d}} \qquad
  \forall d\mid \tfrac{k\,t}{\nu(k)}\,.\]
Analog zum Primitivitätstest reicht es, lediglich maximale Kofaktoren des
jeweiligen verallgemeinerten Kreisteilungspolynoms zu testen. 
Dies ist in nachstehendem Lemma für \emph{einen} Teiler
formuliert, wobei wir uns ohne Einschränkung
auf den Fall $d=1$ beschränken können; andernfalls vollführe man lediglich eine
Änderung der Notation von $q$, $m$, $k$ und $t$.

\begin{lemma}
  Seien $u\in \F_{q^m}$ und $\Phi_{k,t}(x) \in \F_q[x]$ ein verallgemeinertes
  Kreisteilungspolynom. Sei ferner
  \[ \Phi_{k,t}(x)  \speq= f_1(x)^{\nu_1} \cdot \ldots \cdot
    f_r(x)^{\nu_r}\quad \in \F_q[x]\]
  die vollständige Faktorisierung von $\Phi_{k,t}$ über $\F_q$ und
  bezeichne $F_i(x) := \tfrac{\Phi_{k,t}(x)}{f_i(x)}$ den jeweiligen maximalen
  Kofaktor von $f_i$ in $\Phi_{k,t}$ für alle $i=1,\ldots,r$.
  Seien zuletzt $h: \F_q \to \F_{q^m}$ ein injektiver Körperhomomorphismus und 
  $\sigma:\bar \F_q \to \bar \F_q, x\mapsto x^q$ der Frobenius von $\F_q$, 
  so ist $\Ord_q(u) = \Phi_{k,t}$ genau dann, wenn
  \[h(\Phi_{k,t})(\sigma)(u) \speq= 0 
    \qquad\text{und}\qquad 
    h(F_i)(\sigma)(u) \speq\neq 0 \quad \forall i=1,\ldots,r \,.\]
\end{lemma}
\begin{proof}
  Klar per definitionem der $q$-Ordnung und \thref{lemma:einbettung_egal}.
\end{proof}


Nun können wir auf diese Weise leicht eine Implementierung eines Tests auf
vollständige Erzeuger-Eigenschaft angeben, wenn wir davon ausgehen, dass die
Berechnung der maximalen Kofaktoren bereits geschehen ist. In
\autoref{lst:testSubmod} ist also sicherzustellen, dass in dem Array
@polys@ sowohl das verallgemeinerte Kreisteilungspolynom, als auch alle 
maximalen Kofaktoren auftauchen. Das Array @evalToZero@ gibt dabei an, ob 
bei Vorliegen eines vollständigen Erzeugers die Auswertung am jeweiligen
Polynom $0$ ergibt (@true@) oder nicht (@false@). Der Rückgabewert der Funktion
ist selbstredend ein @bool@ mit der Information, ob das getestete Element @ff@
ein vollständiger Erzeuger dieses Kreisteilungsmoduls ist (@true@) oder nicht
(@false@).

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=912, label=lst:testSubmod]
inline bool testSubmod(struct FFElem *ff, struct FFElem *mipo, 
        struct FFPoly **polys,
        int polysCount, bool *evalToZero, 
        struct FFElem **mats, int *frobPowers,
        int m, int *tmp, 
        struct FFElem *ffTmp, struct FFElem *ffTmp2, struct FFElem *ffTmp3, 
        struct FFElem **matmulCache, bool *matmulCacheCalced,
        int *multTable, int *addTable){
    int i;
    int goodCounter = 0;
    for(i=0;i<polysCount;i++){
        applyFrob(ff,mipo,
                polys[i],
                mats,frobPowers[i], ffTmp,
                m,tmp,ffTmp2,ffTmp3,
                matmulCache,matmulCacheCalced,
                multTable,addTable);
        if( isZero(ffTmp) == evalToZero[i] ){
            goodCounter++;
        }else{
            return false;
        }
    }
    if(goodCounter == polysCount){
        return true;
    }
    return false;
}
\end{ccode}


Ferner bieten wir die Möglichkeit ein Element auf vollständige
Erzeuger-Eigenschaft für mehrere verallgemeinerte Kreisteilungsmoduln zu
testen, wie \autoref{lst:testAllSubmods} zeigt. @decompCount@ ist dabei die
Anzahl der zu testenden verallgemeinerten Kreisteilungsmoduln und das Array
@polysCountPerDecomp@ gibt die Anzahl der Polynome für den jeweiligen
Kreisteilungsmodul an. Das Array @bool *toTestIndicator@ legt fest, welche
Kreisteilungsmodule getestet werden. Der Rückgabewert -- anders als in 
\autoref{lst:testSubmod} -- ist ein @int@, der die Werte $-1$, falls @ff@ kein
vollständiger Erzeuger der getesteten Kreisteilungsmoduln ist, oder $i$, falls
@ff@ gerade vollständiger Erzeuger des $i$-ten getesteten Kreisteilungsmoduls
ist, annimmt. Ferner bricht die Funktion ab, falls @ff@ ein vollständiger
Erzeuger ist, da es klar sein sollte, dass diese Eigenschaft lediglich für
\emph{einen} verallgemeinerten Kreisteilungsmodul zutreffen kann.

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=861, label=lst:testAllSubmods]
inline int testAllSubmods(struct FFElem *ff, struct FFElem *mipo, 
        int decompCount, struct FFPoly **polys,
        int *polysCountPerDecomp, bool *evalToZero, 
        struct FFElem **mats, int *frobPowers, bool *toTestIndicator,
        int m, int *tmp, 
        struct FFElem *ffTmp, struct FFElem *ffTmp2, struct FFElem *ffTmp3,
        struct FFElem **matmulCache, bool *matmulCacheCalced,
        int *multTable, int *addTable){
    if(ff->len == 0) return -1;
    int i,j,k;
    int goodCounter = 0;
    int curDecompPosition = 0;
    for(i=0;i<decompCount;i++){
        if(toTestIndicator != 0 && toTestIndicator[i] == false){
            curDecompPosition += polysCountPerDecomp[i];
            continue;
        }
        goodCounter = 0;
        for(j=0;j<polysCountPerDecomp[i];j++){
            applyFrob(ff,mipo,
                    polys[curDecompPosition+j],
                    mats,frobPowers[curDecompPosition+j], ffTmp,
                    m,tmp,ffTmp2,ffTmp3,
                    matmulCache,matmulCacheCalced,
                    multTable,addTable);
            if( isZero(ffTmp) == evalToZero[curDecompPosition+j] ){
                goodCounter++;
            }else break;
        }
        if(goodCounter == polysCountPerDecomp[i]){
            return i;
        }
        curDecompPosition += polysCountPerDecomp[i];
    }
    return -1;
}
\end{ccode}


\section{Implementierung der gezielten Enumeration}

\subsection{Enumeration eines verallgemeinerten Kreisteilungsmoduls}

Sei $E := \F_{q^m}$ über $F := \F_q$ eine Körpererweiterung endlicher Körper. Die Frage
nach einer Enumeration aller vollständig normaler Elemente dieser Erweiterung
lässt sich nach dem Zerlegungssatz (\thref{satz:zerlegungssatz}) auf die
separate Enumeration von verallgemeinerten Kreisteilungsmoduln zurückführen.
Daher starten wir mit einem verallgemeinerten Kreisteilungsmodul $\C_{k,t}$
über $\F_q$. Sicherlich könnte man alle $q^m$ Elemente von $E$ testen, ob sie
vollständige Erzeuger von $\C_{k,t}$ sind, was jedoch einen unnötig großen
Aufwand darstellen würde. Sei nämlich $u\in E$ ein vollständiger Erzeuger von
$\C_{k,t}$, so erhalten wir alle weiteren Elemente dieses Kreisteilungsmoduls
durch Anwendung von \thref{kor:moduln_ueber_v_g}, was wir hier in passender
Notation noch einmal formulieren möchten.

\begin{lemma}
  \label{lemma:moduln_durch_polys}
  Sei $u\in E$ ein vollständiger Erzeuger von $\C_{k,t}$ über $F$. 
  Dann gilt
  \[ \C_{k,t} \speq= \big\{ f(\sigma)(u):\ f(x) \in F[x]_{<\varphi(k)}\big\} \,,\]
  wobei wiederum $\sigma$ den Frobenius von $F$ und 
  $\varphi$ die Eulersche $\varphi$-Funktion notieren.
\end{lemma}
\begin{proof}
  \thref{kor:moduln_ueber_v_g} mit der Erkenntnis, dass
  $\deg(\Phi_{k,t}) = \varphi(k)\,t$.
\end{proof}

Nun ist klar, wie wir ausgehend von einem Erzeuger alle weiteren generieren
können: Sei $u \in E$ ein vollständiger Erzeuger von $\C_{k,t}$ über $F$, so 
berechnen wir iterativ $v := f(\sigma)(u)$ für alle $f \in F[x]_{<\varphi(k)t}$
mit @applyFrob_noCache@ (\autoref{lst:applyFrob_noCache}) 
und testen anschließend $v$ auf vollständige Erzeuger-Eigenschaft mit 
@testSubmod@ (\autoref{lst:testSubmod}). 
Die Generierung der $f$s erfolgt direkt in \autoref{lst:calcSubmoduleElements},
wobei die Elemente aus $F$ wieder mittels eines injektiven Körperhomomorphismus 
$F\to E$ als @FFElem*@-Array namens @elementsF@ übergeben werden.

Wie erwähnt müssen wir dieses Verfahren natürlich mit einem vollständigen
Erzeuger starten. Es ist sicherzustellen, dass sich dieser am aktuellen Knoten 
der Liste @struct Node *root@ befindet.

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=953, label=lst:calcSubmoduleElements]
inline void calcSubmoduleElements(struct Node *root,
        struct FFElem *mipo,
        int maxLenPoly, 
        int *genCounts, int curGen,
        struct FFPoly **polys, int polysCount, bool *evalToZero,
        struct FFElem **mats, int matLen, int *frobPowers,
        struct FFElem **elementsF,
        int m, int q, int *tmp,
        struct FFElem *ffTmp, struct FFElem *ffTmp2, struct FFElem *ffTmp3, 
        struct FFElem *ffTmp4,
        struct FFElem **matmulCache, bool *matmulCacheCalced,
        int *multTable, int *addTable){
    int i,j;
    struct Node *curRoot = root;
    struct FFElem *ff = root->ff;
    int *curPoly = malloc( maxLenPoly*sizeof(int) );
    struct FFPoly *curFPoly = malloc( sizeof(struct FFPoly) );
    curFPoly->poly = malloc( maxLenPoly*sizeof(struct FFElem*) );
    curFPoly->lenPoly = 0;

    initPoly(curPoly,maxLenPoly);
    curPoly[0] = 2;
    int curLenPoly = 1;
    if( q == 2 && maxLenPoly > 1){
        curLenPoly = 2;
        curPoly[0] = 0;
        curPoly[1] = 1;
    }
    if(q != 2 || maxLenPoly > 1){
        while(true){
            //setup curFPoly
            for(i=0;i<curLenPoly;i++)
                curFPoly->poly[i] = elementsF[curPoly[i]];
            curFPoly->lenPoly = curLenPoly;
            //apply Frobenius
            applyFrob_noCache(ff,mipo,
                    curFPoly,
                    mats,1, ffTmp, //return value
                    m,tmp,ffTmp2,ffTmp3,
                    multTable,addTable);
            //test generated element
            for(i=0;i<matLen;i++) matmulCacheCalced[i] = false;
            if(testSubmod(ffTmp, mipo,
                    polys,polysCount,evalToZero,
                    mats,frobPowers,m,tmp,
                    ffTmp2,ffTmp3,ffTmp4,
                    matmulCache,matmulCacheCalced, multTable,addTable)){
                curRoot = appendToEnd(curRoot,ffTmp,m);
                genCounts[curGen]++;
            }
            //generate next element
            curPoly[0] += 1;
            if( curPoly[0] == q ){
                for(i=0;i<maxLenPoly-1 && curPoly[i]==q;i++){
                    curPoly[i] = 0;
                    curPoly[i+1] += 1;
                }
                if(i+1>curLenPoly)
                    curLenPoly = i+1;
                if( curPoly[maxLenPoly-1]==q){
                    break;
                }
            }
        }
    }
    free(curPoly);
    free(curFPoly->poly);
    free(curFPoly);
}
\end{ccode}

Wie man in obigem Listing erkennt, startet die Erzeugung der Polynome aus 
$F[x]_{<\varphi(k)t}$ beim Polynom $2 \in F[x]$ (falls es die Charakteristik
zulässt), da $1\in F[x]$ ja wieder $(1)(\sigma)(u) = \id(u) = u$ liefert.
@maxLenPoly@ gibt dabei die maximale Länge der zu betrachtenden Polynome an (in
hiesiger Notation also @maxLenPoly@$= \varphi(k)t+1$). Die Polynome selbst
werden in zwei Schritten erzeugt: Sei $l := $@maxLenPoly@, so
durchläuft das @int@-Array @curPoly@ alle Elemente aus $\{0,\ldots,q-1\}^l$
Das korrekte Polynom in $E[x]$ wird dann durch einsetzen jeder Stelle 
dieses Tupels aus $\{0,\ldots,q-1\}^l$ in die @elementsF@ erzeugt und in 
@curFPoly@ gespeichert.

Die Anzahl der berechneten Erzeuger werden im @int@-Array @genCounts@ an der
Stelle @curGen@ gespeichert und da unsere Suche auf vollständig normale
Elemente abzielt, werden die konkreten Erzeuger durch @appendToEnd@ 
an die verkettete Liste @struct Node *root@ angehängt und 
damit für späteres Zusammensetzen gespeichert.


\subsubsection{Verkettete Listen zum Speichern berechneter vollständiger 
Erzeuger}
\label{subsub:verkettete_listen}

Die verkettete Liste ist dabei wie folgt aufgebaut.

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=175, label=lst:structNode]
struct Node {
    struct FFElem *ff;
    struct Node *next;
};
\end{ccode}

Ebenfalls ist das Anheften eines Elements ans Ende der Liste wie man es
erwartet, wobei zu bemerken gilt, dass der neue Endknoten zurückgegeben wird.
Auf diese Weise muss nicht bei jedem Anheften die komplette Liste durchlaufen
werden. Das Element @struct FFElem *element@ wird dabei kopiert, so dass es
anschließend weiterverwendet werden kann und die Liste unverändert bleibt 
(vgl. Anwendung in \autoref{lst:calcSubmoduleElements}).

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=180, label=lst:appendToEnd]
/**
 * appends element to end of root, where element is copied to new FFElem.
 */
inline struct Node *appendToEnd(struct Node *root, struct FFElem *element,int m){
    struct Node *nextNode = root;
    if( nextNode != 0){
        while(nextNode->next != 0){
            nextNode = nextNode->next;
        }
        if( nextNode->ff != 0){
            nextNode->next = malloc( sizeof(struct Node) );
            nextNode = nextNode->next;
        }
        if( nextNode != 0){
            nextNode->next = 0;
            nextNode->ff = mallocFFElem(m);
            copyFFElem(element,nextNode->ff);
            return nextNode;
        }
    }
    return NULL;
}
\end{ccode}


Wie üblich in \Clang, ist es hilfreich das Freigeben von Speicher in eine 
eigene Funktion zu setzen.

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=203, label=lst:freeNode]
inline void freeNode(struct Node* head){
    struct Node *next_n = NULL;
    struct Node *tmp_n = NULL;
    for(tmp_n=head; tmp_n !=NULL; ){
        next_n = tmp_n->next;
        freeFFElem(tmp_n->ff);
        free(tmp_n);
        tmp_n = next_n;
    }
    head = 0;
}
\end{ccode}

\subsection{Dynamische Enumeration des größten Kreisteilungsmoduls}
\label{sub:dynamische_enumeration}

Da der Zerlegungssatz (\thref{satz:zerlegungssatz}) nicht immer eine echte
Zerlegung liefert (sich also alle vollständig normalen Elemente auf einen
einzigen Modul konzentrieren) und in vielen Zerlegungen ein verallgemeinerter
Kreisteilungsmodul vorkommt, der verglichen mit den anderen Moduln dieser
Zerlegung, besonders viele Elemente enthält, hat sich die Speicherung
\emph{aller} Erzeuger als schlecht erwiesen. Daher sind wir dazu übergegangen,
den größten Kreisteilungsmodul dynamisch zu enumerieren. Das bedeutet, dass
alle anderen verallgemeinerten Kreisteilungsmoduln vorab durch 
@calcSubmoduleElements@ (\autoref{lst:calcSubmoduleElements}) behandelt werden.
Bei der Enumeration des größten nutzen wir dann diese Informationen und setzen
die gefundenen Erzeuger zu einem vollständig normalen Element zusammen. Dies
können wir dann auf Primitivität durch @isPrimitive@
(\autoref{lst:isPrimitive}) testen und abschließend verwerfen, da es uns ja nur
auf eine Enumeration und nicht auf die konkrete Angabe der vollständig normalen
und primitiven Elemente ankommt.

Die bereits berechneten vollständigen Erzeuger werden durch 
das Array von Listen @struct Node **roots@ übergeben. @decompCount@ gibt dabei
die Anzahl aller (also inklusive des größten) verallgemeinerten
Kreisteilungsmoduln an. Alle anderen Variablen wurden bereits in den vorherigen
Funktionen erklärt, wobei noch bemerkt werden sollte, dass diesmal die
Erzeugung der Polynome bei $1 \in F[x]$ startet, da der bereits gefundene
Erzeuger des größten Kreisteilungsmoduls auch Teil einer gültigen Kombination
zu einem vollständig normalen Element ist. Dieser „Fehler” in der Berechnung
der Anzahl @genCounts@ wird in Zeile \texttt{1156} am Ende der Funktion
korrigiert. Der Erzeuger selbst befindet sich wieder am aktuellen Knoten der
der letzten Liste des Arrays @roots@, da die Datenstrukturen so
aufgebaut werden, dass dieser größte verallgemeinerte Kreisteilungsmodul der
letzte ist (siehe Zeilen \texttt{1062} und \texttt{1064}).


\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=1030, label=lst:processLastSubmodule]
/**
 * Processes last submodule as others before, but does not save generated
 * elements. Cycles through already generated elements and tests for 
 * primitivity:
 *
 * !! all temporary variables are generated inside !!
 */
unsigned long long processLastSubmoduleAndTestPrimitivity(struct Node **roots,
        struct FFElem *mipo, int decompCount,
        int maxLenPoly, 
        int *genCounts, 
        struct FFPoly **polys, int polysCount, bool *evalToZero,
        struct FFElem **mats, int matLen, int *frobPowers,
        struct FFElem **elementsF,
        int m, int q, 
        int *barFactors, int *lenBarFactors, int countBarFactors,
        int *commonBarFactor, int lenCommonBarFactor,
        int *commonBiggestBarFactor, int lenCommonBiggestBarFactor,
        struct FFElem **matCharac,
        struct FFElem **matmulCache, bool *matmulCacheCalced,
        int *multTable, int *addTable){
    //generate temporary variables
    struct FFElem *fff = mallocFFElem(m);
    struct FFElem *ffff = mallocFFElem(m);
    struct FFElem *ffTmp = mallocFFElem(m);
    struct FFElem *ffTmp2 = mallocFFElem(m);
    struct FFElem *ffTmp3 = mallocFFElem(m);
    struct FFElem *ffTmp4 = mallocFFElem(m);
    struct FFElem *ffTmp5 = mallocFFElem(m);
    int *tmp = malloc(m*sizeof(int));

    int i,j;
    int curGen = decompCount-1;
    struct Node **curRoots = malloc( decompCount*sizeof(struct Node*) );
    struct FFElem *ff = roots[curGen]->ff;
    int *curPoly = malloc( maxLenPoly*sizeof(int) );
    struct FFPoly *curFPoly = malloc( sizeof(struct FFPoly) );
    curFPoly->poly = malloc( maxLenPoly*sizeof(struct FFElem*) );
    curFPoly->lenPoly = 0;
    
    initPoly(curPoly,maxLenPoly);
    curPoly[0] = 1;
    int curLenPoly = 1;

    unsigned long long pcn = 0;
    while(true){
        //setup curFPoly
        for(i=0;i<curLenPoly;i++)
            curFPoly->poly[i] = elementsF[curPoly[i]];
        curFPoly->lenPoly = curLenPoly;
        //apply Frobenius
        applyFrob_noCache(ff,mipo,
                curFPoly,
                mats,1, fff, //return value
                m,tmp,ffTmp,ffTmp2,
                multTable,addTable);
        //test generated element
        for(i=0;i<matLen;i++) matmulCacheCalced[i] = false;
        if(testSubmod(fff, mipo,
                polys,polysCount,evalToZero,
                mats,frobPowers,m,tmp,
                ffTmp,ffTmp2,ffTmp3,
                matmulCache,matmulCacheCalced, multTable,addTable)){
            genCounts[curGen]++;
            // build element as sum of already calced Nodes and ffTmp
            for(i=0;i<decompCount;i++) curRoots[i] = roots[i];
            // cycle through Nodes, build element and test primitivity
            while(true){
                copyFFElem(fff,ffff);
                //build element
                for(i=0;i<decompCount-1;i++){
                    addFFElem(ffff, curRoots[i]->ff, ffff, tmp,
                            multTable,addTable);
                }
                //test primitivity
                if(countBarFactors > 0){
                    if(isPrimitive(ffff, mipo,m,
                                barFactors,lenBarFactors,countBarFactors,
                                commonBarFactor,lenCommonBarFactor,
                                commonBiggestBarFactor,lenCommonBiggestBarFactor,
                                matCharac,
                                ffTmp,ffTmp2,ffTmp3,ffTmp4,ffTmp5,
                                tmp,multTable,addTable)){
                        pcn++;
                    }
                }

                //next element
                curRoots[0] = curRoots[0]->next;
                if( curRoots[0] == 0 ){
                   for(i=0;i<decompCount-1 && curRoots[i]==0;i++){
                       curRoots[i] = roots[i];
                       curRoots[i+1] = curRoots[i+1]->next;
                   }
                }
                if( curRoots[decompCount-1] == 0){
                   break;
                }
            }
        }
        //generate next element
        curPoly[0] += 1;
        if( curPoly[0] == q ){
            for(i=0;i<maxLenPoly-1 && curPoly[i]==q;i++){
                curPoly[i] = 0;
                curPoly[i+1] += 1;
            }
            if(i+1>curLenPoly)
                curLenPoly = i+1;
            if( curPoly[maxLenPoly-1]==q){
                break;
            }
        }
    }
    free(curPoly);
    free(curFPoly->poly);
    free(curFPoly);
    freeFFElem(fff);
    freeFFElem(ffff);
    freeFFElem(ffTmp);
    freeFFElem(ffTmp2);
    freeFFElem(ffTmp3);
    freeFFElem(ffTmp4);
    freeFFElem(ffTmp5);

    //we added first element twice
    genCounts[curGen]--;
    return pcn;
}
\end{ccode}


\begin{bemerkung}
  \label{bem:kein_test_auf_primitivitaet}
  Wie Zeile \texttt{1105} zu erkennen gibt, kann man durch das Setzen von
  @countBarFactors = 0@ den Test auf Primitivität überspringen. Dies ist
  sinnvoll, wenn man nur an der Anzahl der vollständig normalen Elemente
  interessiert ist.
\end{bemerkung}


\subsubsection{Vorbereiten der Enumeration auf Auffinden vollständiger
  Erzeuger}

Alle bisher betrachteten Verfahren basierten immer auf der Annahme, dass
bereits ein vollständiger Erzeuger eines Kreisteilungsmoduls bereits gefunden
ist. Es ist klar, dass man diese irgendwann suchen muss, was die Funktion
@processFiniteField@ bewerkstelligt. Gleichzeitig bildet sie den Wrapper, der
von \sage aufgerufen wird und als Rückgabewert @unsigned long long@ die Anzahl
der primitiven vollständig normalen Elemente trägt. Alle zu übergebenen
Parameter werden in \sage erzeugt und wurden bereits erklärt.


\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=1173, label=lst:processFiniteField]
unsigned long long processFiniteField(struct FFElem *mipo, int decompCount,
        struct FFPoly **polys, int *polysCountPerDecomp,
        bool *evalToZero, 
        struct FFElem **mats, int matLen, int *frobPowers,
        int *genCounts, int m, int charac, int q,
        int *barFactors, int *lenBarFactors, int countBarFactors,
        int *commonBarFactor, int lenCommonBarFactor,
        int *commonBiggestBarFactor, int lenCommonBiggestBarFactor,
        struct FFElem **matCharac, struct FFElem **elementsF,
        int *multTable, int *addTable){
    time_t TIME = time(NULL);
    int i,j;

    //setup temporary variables ----------------------------------------------
    int *tmp = malloc(m*sizeof(int));
    struct FFElem *ff = mallocFFElem(m);
    initPoly(ff->el,m);
    struct FFElem *ffRet = mallocFFElem(m);
    struct FFElem *ffTmp = mallocFFElem(m);
    struct FFElem *ffTmp2 = mallocFFElem(m);
    struct FFElem *ffTmp3 = mallocFFElem(m);
    struct FFElem *ffTmp4 = mallocFFElem(m);
    
    struct FFElem **matmulCache = malloc(matLen*sizeof(struct FFElem));
    for(i=0;i<matLen;i++) matmulCache[i] = mallocFFElem(m);
    bool *matmulCacheCalced = malloc(matLen*sizeof(bool));
    
    bool *toTestIndicator = malloc(decompCount*sizeof(bool));
    struct Node **roots = malloc( decompCount*sizeof(struct Node) );
    struct Node **curRoots = malloc(decompCount*sizeof(struct Node*));
    for(i=0;i<decompCount;i++){
        roots[i] = malloc( sizeof(struct Node) );
        roots[i]->ff = 0;
        roots[i]->next = 0;
        curRoots[i] = roots[i];
        toTestIndicator[i] = true;
    }
    //------------------------------------------------------------------------
    
    int foundCounter = 0;
    initPoly(genCounts,decompCount);

    // chase for elements ----------------------------------------------------
    while(true){
        for(i=0;i<matLen;i++) matmulCacheCalced[i] = 0;
        int curGen = testAllSubmods(ff,mipo,decompCount,
                polys,polysCountPerDecomp,evalToZero,
                mats,frobPowers,toTestIndicator,
                m,tmp,ffTmp,ffTmp2,ffTmp3,
                matmulCache,matmulCacheCalced,
                multTable,addTable);
        if( curGen != -1 ){
            if(toTestIndicator[curGen] == true){
                genCounts[curGen]++;
                appendToEnd(roots[curGen], ff, m);
                foundCounter++;
                toTestIndicator[curGen] = false;
            }
            if(foundCounter == decompCount) break;
        }
        //generate next element
        // (for sure there is a more efficient method)
        ff->el[0] += 1;
        if( ff->el[0] == charac ){
            for(i=0; i<m-1 && ff->el[i]==charac; i++){
                ff->el[i] = 0;
                ff->el[i+1] += 1;
            }
            if( ff->el[m-1] == charac )
                break;
        }
        updateFFElem(ff,m);
    }
    if( foundCounter != decompCount ){
        printf("BAAAD ERROR!!! foundCounter=%i < decompCount=%i\n",
                foundCounter,decompCount);
        exit(0);
    }
    printf("finding time: %.2f\n", (double)(time(NULL)-TIME));
    //------------------------------------------------------------------------
    


    // Process found elements ------------------------------------------------
    int curDecompPosition = 0;
    for(i=0;i<decompCount-1;i++){
        calcSubmoduleElements(roots[i], mipo,
                polys[curDecompPosition]->lenPoly-1, // *** == maxLenPoly
                genCounts,i, // *** i == curGen
                polys+curDecompPosition, polysCountPerDecomp[i],
                evalToZero+curDecompPosition,
                mats, matLen, frobPowers+curDecompPosition,
                elementsF,
                m,q,tmp,
                ffTmp,ffTmp2,ffTmp3,ffTmp4,
                matmulCache,matmulCacheCalced,
                multTable,addTable);
        curDecompPosition += polysCountPerDecomp[i];
    }
    printf("all not last time: %.2f\n", (double)(time(NULL)-TIME));
    //------------------------------------------------------------------------
    
    // Process last Decomposition --------------------------------------------
    int curGen = decompCount-1;
    unsigned long long pcn = 
        processLastSubmoduleAndTestPrimitivity(roots,mipo,decompCount,
            polys[curDecompPosition]->lenPoly-1, // *** == maxLenPoly
            genCounts,
            polys+curDecompPosition,polysCountPerDecomp[curGen],
            evalToZero+curDecompPosition,
            mats,matLen,frobPowers+curDecompPosition,
            elementsF,
            m,q,
            barFactors,lenBarFactors,countBarFactors,
            commonBarFactor,lenCommonBarFactor,
            commonBiggestBarFactor,lenCommonBiggestBarFactor,
            matCharac,
            matmulCache,matmulCacheCalced,
            multTable,addTable);
    //------------------------------------------------------------------------

    //free variables
    for(i=0;i<decompCount;i++)
        freeNode(roots[i]);
    free(roots); free(curRoots);

    //free temporary variables
    free(tmp);
    freeFFElem(ff);
    freeFFElem(ffRet);
    freeFFElem(ffTmp);
    freeFFElem(ffTmp2);
    freeFFElem(ffTmp3);
    freeFFElem(ffTmp4);
    for(i=0;i<matLen;i++) freeFFElem(matmulCache[i]);
    free(matmulCache);
    free(matmulCacheCalced);
    free(toTestIndicator);

    
    printf("total time: %.2f\n", (double)(time(NULL)-TIME));
    return pcn;
}
\end{ccode}

Wie zu erkennen ist, erfolgt die Suche nach vollständigen Erzeugern zunächst
durch iterative Enumeration aller Elemente. Wurde ein vollständiger Erzeuger
gefunden, so wird die jeweilige Stelle des @toTestIndicator@s umgeschaltet,
wodurch der zugehörige verallgemeinerte Kreisteilungsmodul in 
@testAllSubmods@ nicht mehr berücksichtigt wird. Ist für jeden
Kreisteilungsmodul ein vollständiger Erzeuger gefunden, werden wie oben
beschrieben durch @calcSubmoduleElements@ (\autoref{lst:calcSubmoduleElements})
alle, bis auf den letzten, verarbeitet. Dieser wird abschließend separat in
\autoref{lst:processLastSubmodule}
betrachtet und liefert die Anzahl der primitiven vollständig normalen Elemente.


\subsection{Top-Level-Implementierung in \sage}

Eingangs wurde zwar erwähnt, dass \sage nicht ausreichend performant ist, um
die hier angestrebten Ziele zu erreichen, doch wollen wir nicht gänzlich auf
die hochsprachlichen Funktionen dieses Computeralgebrasystems verzichten.
Insbesondere eignet sich \sage hier, die Daten für
@processFiniteField@ (\autoref{lst:processFiniteField}) bereitzustellen.

\subsubsection{Anwendung des Zerlegungssatzes}
Es ist klar, dass am Anfang der Berechnung von primitiv vollständig normalen
Elementen einer Erweiterung endlicher Körper stets die Anwendung des
Zerlegungssatzes (\thref{satz:zerlegungssatz}) steht.


\begin{sagecode}[caption={Aus \url{../Sage/enumeratePCNs.spyx}},
  firstnumber=544, label=lst:decompose]
# Application of the Decomposition Theorem (Section 19)
# for x^n-1 over F_p^e
def decompose(p,e, n):
    pi = largestDiv(p,n)
    return decompose_cycl_module(p,e, 1, n/pi, pi)
\end{sagecode}


\begin{sagecode}[caption={Aus \url{../Sage/enumeratePCNs.spyx}},
  firstnumber=571, label=lst:decompose_cycl_module]
# internal application of the Decomposition Theorem
# for Phi_k(x^(t*pi)) over F_p^e
def decompose_cycl_module(p,e, k,t,pi):
    if p.divides(k*t): print "ERROR p | kt"
    #test all prime divisors, start with largest one
    flag = False
    for r,l in reversed(factor(t)):
        if not (r**l).divides(ordn(squarefree(k*t),p**e)):
            R = largestDiv(r,t)
            return decompose_cycl_module(p,e, k, t/r, pi) \
                    + decompose_cycl_module(p,e, k*R, t/R, pi)
    return [(k,t,pi)]
\end{sagecode}

\begin{beispiel}
  Wollen wir einmal den Zerlegungssatz auf $E := \F_{3^{20}}$ über 
  $F := \F_3$ anwenden, so rufen wir "decompose(3,1,20)" auf und 
  erhalten
  \begin{center}
    "[(1, 1, 1), (2, 1, 1), (4, 1, 1), (5, 4, 1)]".
  \end{center}
  Umformuliert bedeutet das, dass
  \[ x^{20} - 1 \speq= \Phi_1(x)\ \Phi_2(x)\ \Phi_4(x)\ \Phi_5(x^4)\quad
    \in \F_3[x]\,,\]
  eine verträgliche Zerlegung ist. 
  Oder in Termen der erweiterten Kreisteilungsmoduln ist 
  \[ \C_{1,20} \speq= \C_{1,1} \oplus \C_{2,1} \oplus
    \C_{4,1} \oplus \C_{5,4}\]
  eine verträgliche Zerlegung über $\F_3$.
\end{beispiel}

Die benutzten Funktionen "largestDiv", "ordn" und "squarefree" sind dabei 
wie folgt gegeben.

\begin{sagecode}[caption={Aus \url{../Sage/enumeratePCNs.spyx}},
  firstnumber=586]
# returns the largest power of p dividing n
def largestDiv(p,n):
    l = 0
    while (p**l).divides(n):
        l = l+1
    return p**(l-1);
\end{sagecode}


\begin{sagecode}[caption={Aus \url{../Sage/enumeratePCNs.spyx}},
  firstnumber=538]
# computes ordn m(q) = min{ k: q ** k = 1 mod m }
def ordn(m,q):
    if m == 1: return 1
    for i in range(1,m+1):
        if (q ** i)%m == 1: return i;
\end{sagecode}  

\begin{sagecode}[caption={Aus \url{../Sage/enumeratePCNs.spyx}},
  firstnumber=534]
# computes the quadratic free part of an integer
def squarefree(n):
    return prod(map(lambda x: x[0], factor(Integer(n))))
\end{sagecode}  


\subsubsection{Ausnutzen einfacher Zerlegungen}

Zunächst müsste man für jeden erweiterten Kreisteilungsmodul
nun \emph{alle} Teiler des Modulcharakters testen, um vollständige Erzeuger zu
finden. Jedoch garantiert \thref{satz:einfache_erweiterungen}, dass dies in
manchen Fällen überflüssig ist, da bei einer einfachen Erweiterung ein Erzeuger
eines Kreisteilungsmoduls $\C_{k,t}$ über $\F_q$ bereits ein vollständiger
Erzeuger ist. Ist eine Erweiterung nicht einfach, so sollte man die Hoffnung
nach einer Vereinfachung der Suche nach vollständigen Erzeugern nicht aufgeben,
sondern sich überlegen, dass es einen Teiler $d \mid n$ geben kann, für den
die Erweiterung $\F_{q^n}$ über $\F_{q^d}$ einfach ist. Dann müssten keine
Teiler von Modulcharaktern getestet werden, die $d$ als echten Faktor
enthalten, da -- wie man sich sehr leicht überlegt -- 
falls $\F_{q^n}$ über $\F_{q^d}$ einfach
ist, auch $\F_{q^n}$ über $\F_{q^{d\,e}}$ für alle
Teiler $e \mid \tfrac n d$ einfach ist.

Dies wollen wir nutzen in nachstehender Funktion, die
gerade zu betrachtenden Teiler einer Erweiterung liefert.
%(und deren Benennung vielleicht etwas kontraintuitiv gewählt wurde).

\begin{sagecode}[caption={Aus \url{../Sage/enumeratePCNs.spyx}},
  firstnumber=594, label=lst:get_completely_basic_divisors]
# returns the NOT completely basic divisors of an 
# extension n over GF(p^e)
def get_completely_basic_divisors(p,e,n):
    n = Integer(n)
    q = Integer(p**e)
    divs = []
    for d in divisors(n):
        isComplBasic = True
        for r in prime_divisors(n/d):
            if r.divides(ordn(p_free_part(n/d/r,p),q**d)):
                isComplBasic = False
                break
        divs += [d]
        if isComplBasic: return divs
    return divs
\end{sagecode}

"p_free_part" gibt wie in \thref{satz:einfache_erweiterungen} (3) zu sehen ist,
gerade den größten Teiler des ersten Arguments an, der nicht mehr durch $p$,
dem zweiten Argument, teilbar ist. Es wird dabei nicht überprüft, ob das zweite
Argument eine Primzahl ist.


\begin{sagecode}[caption={Aus \url{../Sage/enumeratePCNs.spyx}},
  firstnumber=612]
# p-free part of t
def p_free_part(t,p):
    while p.divides(t):
        t /= p
    return t
\end{sagecode}




\subsubsection{Ausnutzen regulärer Kreisteilungsmoduln}

Sicherlich wollen wir auch Regularität (\thref{def:regulaer}) nicht unbeachtet
lassen, um uns die Suche nach vollständig normalen Elementen zu erleichtern.
Also haben wir auch einen Test auf Regularität nach \sage übersetzt.

\begin{sagecode}[caption={Aus \url{../Sage/enumeratePCNs.spyx}},
  firstnumber=431]
# tests if cyclotomic module C_k,t is regular over F_p^e
def isRegular(p,e, k,t,pi):
    return gcd( ordn( squarefree(k*p_free_part(t,p)), p**e ),  k*t*pi) == 1
\end{sagecode}

Ist ein Kreisteilungsmodul regulär, so ist ein Test auf vollständige
Erzeuger-Eigenschaft durch \thref{satz:regulare_erweiterungen} gegeben.
Da Regularität lediglich die Anzahl der Teiler des Erweiterungsgrades, deren
zugehörige Kreisteilungsmoduln auf vollständige Erzeuger getestet werden
müssen, reduziert, wird \thref{satz:regulare_erweiterungen} durch Rückgabe der
Teiler $\tau$ bzw. $\tau$ und $2\tau$ (in Notation dieses Satzes)
im ausfallenden Fall realisiert, wie die Funktion 
"get_tau_divisors" zeigt. Die zu übergebenden Parameter bestehen wieder aus 
$q = p^e$ und der Daten $(k,t,\pi)$ des zu betrachtenden Kreisteilungsmoduls 
$\C_{k,\,t\pi}$ über $\F_q$.

\begin{sagecode}[caption={Aus \url{../Sage/enumeratePCNs.spyx}},
  firstnumber=436]
# returns tau-divisors for complete generator test of 
# the cyclotomic module C_k,t*pi over F_p^e
def get_tau_divisors(p,e, k,t,pi):
    if t != 1:
        print "ERROR get_tau_divisors: t != 1 for p=",p," e=",e\
                ," k=",k," t=",t," pi=",pi
        raise Exception("Error t!=1")
    q = p**e
    tau = ordn(k,q) / ordn(squarefree(k),q)
    tau = prod(map(lambda ra: ra[0]**floor(ra[1]/2), factor(tau)))
    if isExceptional(p,e, k):
        return [ tau, 2*tau ]
    else:
        return [ tau ]
\end{sagecode}

Wie im Absatz vor der Definition von Regularität (\thref{def:regulaer})
erwähnt, ist die
kanonische Zerlegung im regulären Fall verträglich. Daher tritt ein Fehler auf,
wird obiger Funktion ein Kreisteilungsmodul $\C_{l,m}$ übergeben mit 
$m \neq p^b$ für ein $b\geq 0$.

Es bleibt natürlich noch ein Test anzugeben, der überprüft, ob 
die Parameter $(p,e,k)$ ausfallend sind (vgl. \thref{def:ausfallend}).

\begin{sagecode}[caption={Aus \url{../Sage/enumeratePCNs.spyx}},
  firstnumber=452]
# tests if n is exceptional over F_p^e
def isExceptional(p,e, n):
    q = p**e
    c = 0
    nbar = n
    while Integer(2).divides(nbar):
        c += 1
        nbar /= 2
    if (q).mod(4) == 3  and c >= 3  and ordn(q, 2**c) == 2:
        return True
    return False
\end{sagecode}  


\subsubsection{Die zentrale \sage-Funktion 
  \texttt{countCompleteSubmoduleGenerators}}

Als übergeordnete Funktion, die die Anzahl aller (primitiven) vollständig
normale Elemente und aller vollständigen Erzeuger im Sinne des Zerlegungssatzes
liefert, stellen wir "countCompleteSubmoduleGenerators" bereit. Als Argumente
sind selbstredend ein endlicher Körper zu übergeben und der Grad der zu
betrachtenden Erweiterung. Ferner gibt es die Möglichkeit durch das optionale
Argument "binaryPowers=False" den Test auf Primitivität durch $p$-adische
Exponentiation durchführen zu lassen wie in dem Absatz vor 
\autoref{lst:isPrimitive} erwähnt wurde (vgl. auch 
\autoref{subsub:primitivitaetstest}). Der Test auf Primitivität lässt sich auch
vollständig deaktivieren durch die Übergabe von "testPrimitivity=False"
(vgl. \thref{bem:kein_test_auf_primitivitaet}).

Der Rückgabewert der Funktion enthält die Anzahl aller vollständig normalen
Elemente der Erweiterung, die Anzahl aller primitiv vollständig normalen (oder
$0$, falls der Test auf Primitivität deaktiviert wurde), 
die Anzahl der jeweiligen vollständigen Erzeuger der Zerlegung in
verallgemeinerte Kreisteilungsmodule nach \thref{satz:zerlegungssatz} und
abschließend die Dauer der Berechnung.

Im Gegensatz zu den bisherigen Listings werden wir
"countCompleteSubmoduleGenerators" in mehrere Teile aufspalten, um ein besseres
Verständnis zu gewährleisten. Wir beginnen mit den ersten Zeilen, die in
offensichtlicher Weise die Datenstrukturen der Zerlegung bereitstellen, wie sie
in @testAllSubmods@ (\autoref{lst:testAllSubmods}) bzw. @testSubmod@ 
(\autoref{lst:testSubmod}) benötigt werden.


\begin{sagecode}[caption={Aus \url{../Sage/enumeratePCNs.spyx}},
  firstnumber=88]
def countCompleteSubmoduleGenerators(F,n, binaryPowers=True, \
        testPrimitivity=True):
    TIME = time.time()
    p = F.characteristic()
    q = F.order();
    e = q.log(p)
    E = F.extension(Integer(n),'a');
    P = E.prime_subfield()
    #generate factors
    polys = []
    polysCount = []
    evalToZero = []
    frobPowers = []
    notComplBasicDivisors = get_completely_basic_divisors(p,e,n)
    decomposition = decompose(p,e,n)
    for decomp in decomposition:
        k,t,pi = decomp
        divs = divisors(get_module_character(*decomp))
        divs = filter(lambda x: x in notComplBasicDivisors, divs)
        countPolysForThisDecomp = 0
        for d in divs:
            G = F.extension(Integer(d), 'c');
            Gx = PolynomialRing(G,'x'); 
            h = Hom(G,E)[0]
            cycl = Gx.cyclotomic_polynomial(squarefree(k))\
                    (Gx.gen()**(k*t*pi/squarefree(k)/d))
            polys += [map(lambda x: x.polynomial().list(),
                cycl.map_coefficients(h).list())]
            frobPowers += [d]
            evalToZero += [1]
            countPolysForThisDecomp += 1
            # add Co-Factors
            for f,mult in cycl.factor():
                g = cycl.quo_rem(f)[0]
                gE = g.map_coefficients(h)
                polys += [map(lambda x: x.polynomial().list(), gE.list())]
                frobPowers += [d]
                evalToZero += [0]
                countPolysForThisDecomp +=1
        polysCount += [countPolysForThisDecomp]
\end{sagecode}

Wie man gut erkennen kann, werden einfache Zerlegungen in den Zeilen
\texttt{101} und \texttt{106} ausgenutzt.

Anschließend berechnen wir, falls "testPrimitivity=True",
die Kofaktoren, wie sie beim Test auf Primitivität
in @isPrimitive@ (\autoref{lst:isPrimitive}) verwendet werden. Dabei ist zu
unterscheiden, ob die Faktoren in binärer (ab Zeile \texttt{151})
oder $p$-adischer Form (ab Zeile \texttt{156}) genutzt werden
sollen. Bei $p$-adischer Darstellung muss, wie in dem Absatz vor 
@powerFFElem@ (\autoref{lst:powerffelem}) erwähnt, die Länge des maximal
auftretenden $0$-Intervalls berechnet werden (ab Zeile \texttt{164}).

\begin{sagecode}[caption={\texttt{countCompleteSubmoduleGenerators}
  Fortsetzung (I)}, 
  firstnumber=128]
    charac = int(E.characteristic())
        #mipo
    mipo = E.modulus().list()
    m = len(mipo)-1

    #calc prime factors of order
    barFactors = []
    primitiveOrder = E.order()-1
    if testPrimitivity:
        factors = reversed(factor(primitiveOrder))
        for r,k in factors:
            barFactors += [primitiveOrder/r]
        countBarFactors = len(barFactors)
        commonBarFactor = gcd(barFactors)
        commonBiggestBarFactor = max(gcd(barFactors[1:]) / commonBarFactor,1)
        barFactors = map(lambda b: b/commonBarFactor, barFactors)
        curF = 0
        barFactors_tmp = [barFactors[0]]
        for b in barFactors[1:]:
            barFactors_tmp += [ b/commonBiggestBarFactor - curF]
            curF = b/commonBiggestBarFactor
        barFactors = barFactors_tmp
        
        if binaryPowers:
            barFactors = map(lambda b: get_padic_representation(b,2),barFactors)
            commonBarFactor = get_padic_representation(commonBarFactor,2)
            commonBiggestBarFactor = \
                    get_padic_representation(commonBiggestBarFactor,2)
        else:
            barFactors = map(lambda b: get_padic_representation(b,p),barFactors)
            commonBarFactor = get_padic_representation(commonBarFactor,p)
            commonBiggestBarFactor = \
                    get_padic_representation(commonBiggestBarFactor,p)
        lenCommonBarFactor = len(commonBarFactor)
        lenCommonBiggestBarFactor = len(commonBiggestBarFactor)

        lenBiggestZeroGap = 0
        if not binaryPowers:
            #find biggest gap (i.e. zero-interval)
            lenCurGap = 0
            for b in barFactors+[commonBarFactor]+[commonBiggestBarFactor]:
                i = 0
                while i < len(b):
                    lenCurGap = 0
                    while i<len(b) and b[i] == 0:
                        lenCurGap+= 1
                        i += 1
                    lenBiggestZeroGap = max(lenBiggestZeroGap, lenCurGap)
                    i += 1
    else:
        countBarFactors = 0
        barFactors = []
        commonBarFactor = []
        commonBiggestBarFactor = []
        lenBiggestZeroGap = 0
\end{sagecode}


Im letzten Teil der reinen \sage-Aufbereitung, liften wir die Elemente des
Grundkörpers mittels eines injektiven Körperhomomorphismus in den
Erweiterungskörper, wie sie in @calcSubmoduleElements@
(\autoref{lst:calcSubmoduleElements}) bzw.
@processLastSubmoduleAndTestPrimitivity@
(\autoref{lst:processLastSubmodule}) benötigt werden. Ferner stellen wir die 
Additions- und Multiplikationstabellen nach 
\autoref{sub:arithmetik_in_endlichen_körpern} auf.

\begin{sagecode}[caption={\texttt{countCompleteSubmoduleGenerators}
  Fortsetzung (II)}, 
  firstnumber=183]
        #generate F elements in E
    elementsF = []
    if e == 1:
        elementsF = map(lambda e: [e], list(F))
    else:
        h = Hom(F,E)[0]
        for e in itertools.product(xrange(p),repeat=e):
            elementsF += [h( F(list(reversed(e))) ).polynomial().list()]

        #calculate addition and multiplication tables
    ps = range(p)
    addTable = ps[P(-2*(p-1)):] + ps*2 + ps[:Integer(P(2*(p-1)))+1]
    multTable = ps[P(-(p-1)**2):] + ps*(2*(p-2)) + ps[:Integer(P((p-1)**2))+1]
\end{sagecode}  


Nun sind wir bereit alle Daten nach \Clang zu transferieren. Dies ist ein
notwendiges Übel, da die interne Repräsentation von \sage-Objekten nicht mit
denen in \Clang vereinbar sind. Beispielsweise sind Listen von Ganzzahlen
in \sage keineswegs \Clang-kompatible Arrays. 
Es existiert jedoch gerade für diesen Fall die Möglichkeit,
die komfortable Syntax von \texttt{numpy}-Arrays zu nutzen, die direkt auf 
\Clang-Arrays basieren.\footnote{Siehe z.B.
\url{http://www.sagemath.org/doc/numerical_sage/numpy.html} für die Benutzung
von \texttt{numpy}-Arrays in \sage.}

Andere Datenstrukturen, wie die selbst erstellten @struct FFElem@s, müssen
händisch übersetzt werden. Da \cython das (etwas merkwürdig wirkende) Mischen
von \python und \Clang erlaubt, schieben wir die hierfür erstellten Funktionen
der Übersetzung von \python-Listen in die jeweilige \Clang-Datenstruktur kurz
ein.

\begin{sagecode}[caption={Aus \url{../Sage/enumeratePCNs.spyx}},
  firstnumber=55]
cdef FFElem *pyList2FFElem(element,int m):
    cdef FFElem *ff = mallocFFElem(<int>m)
    initPoly(ff.el,m)
    for i,e in enumerate(element):
        ff.el[i] = e
    updateFFElem(ff,m)
    return ff
\end{sagecode}  

\begin{sagecode}[caption={Aus \url{../Sage/enumeratePCNs.spyx}},
  firstnumber=63]
cdef FFElem **pyList2PointFFElem(pyList, int m):
    lenList = len(pyList)
    cdef FFElem **ffs = <FFElem**>malloc(lenList*sizeof(FFElem*))
    for i,e in enumerate(pyList):
        ffs[i] = pyList2FFElem(e,m)
    return ffs
\end{sagecode}

\begin{sagecode}[caption={Aus \url{../Sage/enumeratePCNs.spyx}},
  firstnumber=70]
cdef FFPoly *pyList2FFPoly(listPoly, int m):
    lenPoly = len(listPoly)
    cdef FFPoly *poly = <FFPoly*>malloc(sizeof(FFPoly))
    poly.poly = <FFElem**>malloc(lenPoly*sizeof(FFElem*))
    poly.lenPoly = lenPoly
    for i,e in enumerate(listPoly):
        poly.poly[i] = pyList2FFElem(e,m)
    return poly
\end{sagecode}

\begin{sagecode}[caption={Aus \url{../Sage/enumeratePCNs.spyx}},
  firstnumber=79]
cdef FFPoly **pyList2PointFFPoly(listPolys, int m):
    countPolys = len(listPolys)
    cdef FFPoly **polys = <FFPoly**>malloc(countPolys*sizeof(FFPoly*))
    for i,e in enumerate(listPolys):
        polys[i] = pyList2FFPoly(e,m)
    return polys
\end{sagecode}


Nun können wir die Beschreibung von "countCompleteSubmoduleGenerators"
fortsetzen und erkennen sofort die gerade vorgestellten Funktionen der
Übersetznug sowie die Benutzung der \texttt{numpy}-Arrays.

\begin{sagecode}[caption={\texttt{countCompleteSubmoduleGenerators}
  Fortsetzung (III)}, 
  firstnumber=196]
    # SETUP C DATA ===========================================================
    maxMatPower = max(map(lambda d: euler_phi(d[0])*d[1]*d[2], decomposition))
        # multiplication and addition table
    cdef np.ndarray[int,ndim=1,mode="c"] multTableRawC\
        = np.array(multTable, dtype=np.int32)
    cdef np.ndarray[int,ndim=1,mode="c"] addTableRawC\
        = np.array(addTable, dtype=np.int32)
    cdef int* multTableC = <int*>multTableRawC.data + <int>((p-1)**2)
    cdef int* addTableC = <int*>addTableRawC.data + <int>(2*(p-1))
        #setup mipo
    cdef FFElem *mipoC = pyList2FFElem(mipo,m+1)
       #setup matrices
    cdef FFElem **matsC  = genFrobMats(mipoC,m,maxMatPower,q,
            multTableC, addTableC)
        # mat charac
    cdef FFElem **matCharacC
    if binaryPowers:
        matCharacC = <FFElem**>0
    else:
        matCharacC = genFrobMats(mipoC,m,lenBiggestZeroGap+1,
                p, multTableC, addTableC)
    #setup polynomials, polyLength, frobPowers, evaltoZero
    decompCount = int(len(polysCount))
        #evalToZeroC
    cdef np.ndarray[char,ndim=1,mode="c",cast=True] evalToZeroC\
            = np.array(evalToZero, dtype=np.uint8)
        #frobPowersC
    cdef np.ndarray[int,ndim=1,mode="c"] frobPowersC\
            = np.array(frobPowers, dtype=np.int32)
        #polysCountC
    cdef np.ndarray[int,ndim=1,mode="c"] polysCountC\
            = np.array(polysCount, dtype=np.int32)
    cdef FFPoly **polysC = pyList2PointFFPoly(polys,m)
        # bar Factors
    cdef np.ndarray[int,ndim=1,mode="c"] barFactorsC \
        = np.array(list(itertools.chain(*barFactors)), dtype=np.int32)
    cdef np.ndarray[int,ndim=1,mode="c"] lenBarFactorsC \
        = np.array(map(len,barFactors), dtype=np.int32)
    cdef np.ndarray[int,ndim=1,mode="c"] commonBarFactorC \
        = np.array(commonBarFactor, dtype=np.int32)
    cdef np.ndarray[int,ndim=1,mode="c"] commonBiggestBarFactorC \
        = np.array(commonBiggestBarFactor, dtype=np.int32)
        # F elements in E
    cdef FFElem **elementsFC = pyList2PointFFElem(elementsF,m)
    #=========================================================================
\end{sagecode}

Es gilt anzumerken, dass die Erzeugung der Darstellungsmatrizen des Frobenius
in \Clang durch die Funktion @genFrobMats@ 
(die in \url{../Sage/enumeratePCNs.c} zu finden ist und hier nicht näher
erläutert wird, da sie weder vom mathematischen Standpunkt her besonders
spannend ist, noch besonderes programmiertechnisch besondere Aufmerksamkeit
verdient)
geschieht, wobei die maximal zu berechnende
Matrixpotenz gerade durch den Grad des größten auftretenden Polynoms der
Zerlegung gegeben ist. Wir wissen jedoch genau, wie der Grad eines
verallgemeinerten Kreisteilungspolynoms zu berechnen ist, wie Zeile
\texttt{197} erkennen lässt.

In einem letzten Schritt können wir (nun endlich) die bereitgestellte
\Clang-Funktion @processFiniteField@ (\autoref{lst:processFiniteField}) 
aufrufen und die Rückgabewerte verwalten. Hier gilt es anzumerken, dass die
Anzahl der vollständigen Erzeuger direkt in das Array @genCountsC@ geschrieben
wird und nicht als expliziter Rückgabewert erkennbar ist.


\begin{sagecode}[caption={\texttt{countCompleteSubmoduleGenerators}
  Fortsetzung (IV)}, 
  firstnumber=241]
    #setup return values
    cdef np.ndarray[int,ndim=1,mode="c"] genCountsC
    genCountsC = np.zeros(decompCount, dtype=np.int32)

    cdef unsigned long long pcn = \
            processFiniteField(mipoC, decompCount,
                    polysC,<int*>polysCountC.data,
                    <char*>evalToZeroC.data,
                    matsC,maxMatPower,<int*>frobPowersC.data,
                    <int*>genCountsC.data, m, p, q,
                    <int*>barFactorsC.data, <int*>lenBarFactorsC.data,
                    countBarFactors,
                    <int*>commonBarFactorC.data,lenCommonBarFactor,
                    <int*>commonBiggestBarFactorC.data,lenCommonBiggestBarFactor,
                    matCharacC,elementsFC,
                    multTableC,addTableC)

    genCounts = dict()
    for i,d in enumerate(decomposition):
        genCounts[d] = Integer(genCountsC[i])

    # Free all malloced variables at the end =================================
    freeFFElem(mipoC)
    freeFFElemMatrix(matsC,m*maxMatPower)
    for i in range(len(polys)):
        freeFFPoly(polysC[i])
    free(polysC)
    freeFFElemMatrix(matCharacC,m*(lenBiggestZeroGap+1))
    freeFFElemMatrix(elementsFC,len(elementsF))
    #=========================================================================
    return prod(genCounts.values()), Integer(pcn), genCounts,\
            strfdelta(datetime.timedelta(seconds=(time.time()-TIME)))
\end{sagecode}


\subsection{Ein ausführliches Beispiel}

Wir wollen nun einmal das gesamte Verfahren zur Berechnung Anzahl 
der primitiv vollständig normalen Elemente einer Erweiterung endlicher Körper
anhand eines Beispiels nachvollziehen. Dazu wählen wir $F := \F_2$ und 
$n := 6$, also $E := \F_{2^6}$. Die Wahl des Minimalpolynoms dieser Erweiterung
überlassen wir \sage und erhalten 
\[ E = \F_2[a] \big/ ( a^6 + a^4 + a^3 + a + 1 ) \,.\]

Gehen wir erneut den Code von "countCompleteSubmoduleGenerators"
Zeile für Zeile durch, so beginnen wir mit der Festlegung der grundlegenden
Parameter:
\[ p := 2,\qquad q := 2,\qquad e := 1,\qquad P := \F_2\,.\]


\paragraph{Berechnung der nicht einfachen Teiler} Im nächsten Schritt berechnen
wir die nicht einfachen Teiler mithilfe "get_completely_basic_divisors" 
(\autoref{lst:get_completely_basic_divisors}).
Dazu gehen wir alle Teiler von $n=6$ durch und überprüfen, ob die jeweiligen
Erweiterungen einfach sind, d.h. für jeden Teiler $d \mid n$ testen wir für
jeden Primteiler $r \mid \tfrac{n}{d}$, ob $r \nmid \ord_{(\frac{n}{dr})'}(q^d)$
(vgl. \thref{satz:einfache_erweiterungen}). Wir brechen jeweils ab, falls ein
$r$ die Teilbarkeitsbedingung nicht erfüllt.

\[ \begin{array}{l|l|l|l|l|ll} 
  d & \frac{n}{d} & r & (\frac{n}{dr})' & \ord_{(\frac{n}{dr})'}(q^d) & 
    \multicolumn{2}{l}{r \nmid \ord_{(\frac{n}{dr})'}(q^d)}\\\hline\hline
  1 & 6 & 2 & 3 & 2 & \lightning &\leadsto\text{\small nicht einfach}\\\hline
  2 & 3 & 3 & 1 & 1 & \checkmark\\
  &&&&&& \leadsto\text{\small einfach}
  \end{array}\]

Damit sind alle zu betrachtenden Teiler von $n$ gegeben durch
\[ \text{"notComplBasicDivisors"} := [1,2]\,. \]
Wie man erkennt, wollen wir in diesem Beispiel alle auftretenden Listen in der
\python/\sage-üblichen Notation $[\ ,\ ,\ldots]$ angeben.


\paragraph{Anwendung des Zerlegungssatzes} Anschließend folgt die Berechnung
der Zerlegung in Kreisteilungsmoduln durch den Zerlegungssatz. Da wir in der
konkreten Implementierung stets drei Parameter für die Angabe von
Kreisteilungsmoduln verwenden, d.h. Potenzen der Charakteristik immer
„ausklammern”, wollen wir dies auch hier so notieren. Der zu
$x^n-1 = x^6-1$ über $\F_2$ gehörige Kreisteilungsmodul ist offenbar
\[ \C_{1,6} \speq= \C_{1,3\cdot 2}\]
und wir erhalten damit das Parametertripel $(k,t,\pi) := (1,3,2)$.
Hier startet der Zerlegungssatz rekursiv und wie in "decompose_cycl_module" 
(\autoref{lst:decompose_cycl_module}) erkennbar, durchlaufen wir die Primteiler
von $t$ in der Größe nach absteigend sortierter Reihenfolge.

\begin{center}
  \begin{tikzpicture}[level distance=2cm,sibling distance=3cm]
    \node (root) {$(1,3,2)$}
      child {node {$(1,1,2)$}
        edge from parent
          node[above, sloped, 
            font=\scriptsize,text=gray!50]
            {$(k,\tfrac t r, \pi)$}}
      child {node {$(3,1,2)$}
        edge from parent
          node[above,sloped,
          font=\scriptsize,text=gray!50]
          {$(kr,\tfrac t r, \pi)$}};
    \begin{scope}[overlay]
      \node[right=0.5cm of root, fill=gray!5,
        font=\small] 
        {$r=3$ $\leadsto$ 
          $3^1 \nmid \ord_{\nu(kt')}(q) = \ord_{3}(2) = 2$};
    \end{scope}
  \end{tikzpicture}
\end{center}
Da an den beiden Blättern $t=1$ gilt, endet hier die Möglichkeit einer weiteren
Rekursionsstufe und wir fassen zusammen, dass
\[ x^6-1 \speq= \Phi_1(x)^2 \ \Phi_3(x)^2 \]
die feinste verträgliche Zerlegung des Kreisteilungsmoduls $\C_{1,6}$
über $\F_2$ ist.


\paragraph{Polynome aufstellen} Nun sind wir in der Lage, die Polynome zu
berechnen, die wir für den Test von vermeindlichen vollständigen Erzeugen
benötigen werden. 
\begin{enumerate}
  \item Wir starten beim ersten erweiterten Kreisteilungspolynom
    \[ \Phi_{1,1}^2 \speq= x^2 + 1 \qquad \in \F_2[x]\,. \]
    Es ist nun $(k,t,\pi) := (1,1,2)$ und wir 
    müssten alle Teiler des Modulcharakters $\frac{k\,t\,\pi}{\nu(k)} = 2$,
    betrachten. Wie man an obig berechnetem "notComplBasicDivisors" erkennt, 
    lässt sich in diesem Fall auch keiner der beiden Teiler $\{1,2\}$
    streichen. Ein zweiter Kniff schafft aber eine Reduktion der Teilerzahl, da 
    $(1,1,2)$ regulär über $\F_2$ ist:
    \[ \ord_{\nu(k\,t')}(q) \speq= \ord_{1}(2) \speq= 1 \,. \]
    Da auch $(1,1,2)$ nicht ausfallend über $\F_2$ ist, reicht es den einzigen
    Teiler zu berechnen, den wir benötigen:
    \[ \tau(q,k) \speq= \tau(2,1) \speq= 1\,,\]
    da $\ord_k(q) = \ord_1(2) = \ord_{\nu(k)}(q)$.
    \begin{description}
      \item[$d=1.$] Nun sind alle Kofaktoren einer vollständigen Faktorisierung
        von $\Phi_{1,1}(x)^2$ über $\F_{2^d} = \F_2$ zu berechnen:
        \[ \Phi_{1,1}(x)^2 \speq= (x+1)^2\]
        und der einzige Kofaktor ist durch
        \[ g_{1,1,1}(x) \speq= x+1 \]
        gegeben.
    \end{description}
  \item Nun zum zweiten Kreisteilungsmodul $(k,t,\pi) := (3,1,2)$. Der
    Modulcharakter ist wiederum $\frac{k\,t\,\pi}{\nu(k)} = 2$. Auch hier
    können wir mit "notComplBasicDivisors" keinen Teiler wegdiskutieren. Anders
    als in obigem Fall ist dieser Kreisteilungsmodul nicht einmal regulär, da 
    \[ \ord_{\nu(kt')}(q) \speq= \ord_3(2) = 2\]
    nicht teilerfremd zu $kt=2$ ist.
    Also bleiben beide Teiler $\{1,2\}$ übrig.
    \begin{description}
      \item[$d=1.$] Wir faktorisieren 
        \[ \Phi_{3,1}(x)^2 \speq= (x^2+x+1)^2 \qquad \in \F_2[x] \]
        und erhalten als einzigen Kofaktor dieses Teilers
        \[ g_{2,1,1}(x) \speq= x^2+x+1\,.\]
      \item[$d=2.$] Blicken wir noch einmal in die Definition eines
        vollständigen Erzeugers (\thref{def:vollst_erzeuger}), so sehen wir,
        dass wir nun $\C_{3,1\cdot 2}$ als $\F_{2^2}[x]$-Modul betrachten
        müssen. Orientiert man sich an der Definition eines verallgemeinerten
        Kreisteilungsmoduls (\thref{def:verallgemeinerter_kreisteilungsmodul}),
        so sind wir gezwungen $\Phi_3(x^{\frac{2}{2}})$ über $\F_{2^2}$ zu
        faktorisieren. Dazu überlassen wir wiederum \sage die Repräsentation
        des endlichen Körpers
        \[ \F_{2^2} \speq= \F_2[b] \big/ (b^2+b+1)\]
        und faktorisieren
        \[ \Phi_{3,1}(x) \speq= (x+b) (x+b+1)\,. \]
        Ergo erhalten wir die beiden Kofaktoren in $\F_{2^2}[x]$:
        \begin{align*}
          g_{2,2,1}(x) &\speq{:=} x + b+1\,,\\
          g_{2,2,2}(x) &\speq{:=} x + b\,.
        \end{align*}
        Wie aber in der Beschreibung der Implementierung erwähnt, bietet es
        sich an, diese Polynome mittels eines injektiven Körperhomomorphismus
        in $E = \F_{2^6}$ zu lesen. Auch die Berechnung eines solchen
        überlassen wir \sage und wählen
        \[ h:\ \funcdef{\F_2[b]\big/(b^2+b+1) &\to& 
          \F_2[a] \big/ ( a^6 + a^4 + a^3 + a + 1 )\,,\\[10pt]
          b &\mapsto& a^2+a^2+a\,.}\]
        Damit schreiben wir obige Kofaktoren zu
        \begin{align*}
          g_{2,2,1}(x) &\speq{:=} x + a^3+a^2+a+1\,,\\
          g_{2,2,2}(x) &\speq{:=} x + a^3+a^2+a
        \end{align*}
        um, gelesen als Elemente von $\big(\F_2[a]\big/(a^6+a^4+a^3+a+1)\big)[x]$.
    \end{description}
\end{enumerate}
Als letzten Schritt des Aufstellens der Polynome fassen wir alle Ergebnisse
zusammen und erinnern uns an die Implementierung, wo neben den Polynomen auch
die Information, welche Polynome bei Vorliegen eines vollständigen Erzeugers in
der Frobenius-Auswertung zu Null ausgewertet werden müssen, und die Angabe der
Frobenius-Potenzen benötigt werden. Da alle Polynome in \emph{eine einzige}
Liste geschrieben werden, muss man selbstredend die Anzahl der Polynome des
jeweiligen Kreisteilungsmoduls abspeichern. Zusammengefasst erhalten wir
folgende Daten:
\[\small\begin{array}{r@{\ := [}llllll@{]}}
    \text{"polys"} &  x^2+1,& x+1, & x^4+x^2+1, &x^2+x+1, 
      & x+a^3+a^2+a+1, & x+a^3+a^2+a\\
    \text{"evalToZero"} & 1, & 0, & 1, & 0, & 0, & 0\\
    \text{"frobPowers"} & 1, & 1, & 1, & 1, & 2, & 2\\
    \text{"polysCount"} & 2, &    & 4  &    &    &\\
  \end{array}\]
Wie man sicherlich bemerkt, führen wir das den zweiten Kreisteilungsmodul
definierende Polynom $\Phi_{3,2}$ lediglich für den Teiler $d=1$ auf. Für den
Teiler $d=2$ hätten wir $\Phi_{3,1}$ jedoch mit Frobenius-Potenz $2$. Da ein
Element $u\in E$ jedoch genau dann $\Phi_{3,2}(\sigma)(u) = 0$ erfüllt, wenn 
$\Phi_{3,1}(\sigma^2)(u) = 0$, ist dieser Berechnungsschritt obsolet.

\paragraph{Daten für einen Primitivitätstest}
Für den in \autoref{lst:isPrimitive} beschriebenen Primitivitätstest, müssen
wir zunächst $q^n-1 = 2^6-1$ faktorisieren:
\[ 2^6-1 = 3^2\cdot 7\,.\]
Also sind die zu testenden Kofaktoren gerade $9$ und $21$. Wir erkennen sofort,
dass der größte gemeinsame Teiler beider Faktoren $3$ ist und setzen daher
in Benennung von "isPrimitive" (\autoref{lst:isPrimitive})
\[ \text{"commonBarFactor"}\ := 3\,.\]
Ergo reduzieren sich die Kofaktoren auf $3$ und $7$.
Im nächsten Schritt betrachten wir nur noch alle Kofaktoren, die den größten
Primfaktor obiger Faktorisierung enthalten. Hier ist dies nur einer:
$7$. Wieder berechnen wir den $\ggT$ all dieser: $7$. Damit haben wir alle
restlichen Daten:
\[ \begin{array}{r@{\ :=\ }l}
    \text{"commonBiggestBarFactor"} & 7\\
    \text{"barFactors"} & [3,1]
  \end{array} \]
Benutzen wir binäre Exponentiation so übersetzen wir die erhaltenen Zahlen ins
Binärsystem:
\[ \begin{array}{r@{\ :=\ }l}
    \text{"commonBarFactor"} & [1,1]\\
    \text{"commonBiggestBarFactor"} & [1,1,1]\\
    \text{"barFactors"} & \big[[1,1,1],\ [1]\big]
  \end{array} \]
In diesem Fall wären die Zahlen in $p$-adischer Schreibweise identisch, da ja
$p=2$.

\paragraph{Aufstellen der Frobenius-Matrizen}
Um den Frobenius von $F$, also 
$\bar F\to \bar F, x\mapsto x^2$,
effizient auf Elemente aus $E$ anwenden zu können,
müssen wir seine Darstellungsmatrix bezüglich der kanonischen Basis
\[\{ 1, a, a^2, a^3, a^4, a^5\} 
  \subseteq \F_2[a]\big/(a^6 + a^4 + a^3 + a + 1)\]
berechnen. Dazu fassen wir selbstredend die Elemente aus $E$ als Vektoren in
$\F_2^6$ auf:
\[\begin{array}{l@{\ =\ }l@{\quad\cong\quad}l}
  1^2 & 1 & \begin{bmatrix}1&0&0&0&0&0\end{bmatrix}^T\\
  a^2 & a^2 & \begin{bmatrix}0&0&1&0&0&0\end{bmatrix}^T\\
  (a^2)^2 & a^4 & \begin{bmatrix}0&0&0&0&1&0\end{bmatrix}^T\\
  (a^3)^2 & a^4+a^3+a+1 & \begin{bmatrix}1&1&0&1&1&0\end{bmatrix}^T\\
  (a^4)^2 & a^5 + a^4 + a^2 + a + 1 & \begin{bmatrix}1&1&1&0&1&1\end{bmatrix}^T\\
  (a^5)^2 & a^5+a^4+1 & \begin{bmatrix}1&0&0&0&1&1\end{bmatrix}^T
\end{array}\]

Damit erhalten wir eine Darstellungsmatrix des Frobenius:
\[\Gamma_\sigma \speq{:=} \begin{bmatrix}
  1 & 0 & 0 & 1 & 1 & 1 \\
  0 & 0 & 0 & 1 & 1 & 0 \\
  0 & 1 & 0 & 0 & 1 & 0 \\
  0 & 0 & 0 & 1 & 0 & 0 \\
  0 & 0 & 1 & 1 & 1 & 1 \\
  0 & 0 & 0 & 0 & 1 & 1 \\
  \end{bmatrix}\]

Wie man an den obigen Polynomen in "polys" erkennen kann, ist die maximale
Potenz des Frobenius gerade $4$. Daher bleibt noch $\Gamma_\sigma^2$,
$\Gamma_\sigma^3$ und $\Gamma_\sigma^4$ zu berechnen:

\[ \Gamma_\sigma^2 \speq{=}
  \begin{bmatrix}
    1 & 0 & 1 & 1 & 1 & 1 \\
    0 & 0 & 1 & 0 & 1 & 1 \\
    0 & 0 & 1 & 0 & 0 & 1 \\
    0 & 0 & 0 & 1 & 0 & 0 \\
    0 & 1 & 1 & 0 & 1 & 0 \\
    0 & 0 & 1 & 1 & 0 & 0 \\
    \end{bmatrix},
  \quad\Gamma_\sigma^3 \speq=
  \begin{bmatrix}
    1 & 1 & 1 & 1 & 0 & 1 \\
    0 & 1 & 1 & 1 & 1 & 0 \\
    0 & 1 & 0 & 0 & 0 & 1 \\
    0 & 0 & 0 & 1 & 0 & 0 \\
    0 & 1 & 1 & 0 & 1 & 1 \\
    0 & 1 & 0 & 1 & 1 & 0 \\
  \end{bmatrix},
  \quad\Gamma_\sigma^4 \speq=
  \begin{bmatrix}
    1 & 1 & 0 & 1 & 0 & 0 \\
    0 & 1 & 1 & 1 & 1 & 1 \\
    0 & 0 & 0 & 1 & 0 & 1 \\
    0 & 0 & 0 & 1 & 0 & 0 \\
    0 & 1 & 1 & 0 & 0 & 0 \\
    0 & 0 & 1 & 1 & 0 & 1 \\
  \end{bmatrix}.\]

Wie man in der Implementierung erkennen kann übergeben wir die
Frobenius-Matrizen stets als @FFElem **mats@, d.h. man sollte sich obige vier
Matrizen eher als eine $(24\times 6)$-Matrix vorstellen, deren Zeilen jeweils
aus einem @FFElem@ bestehen (vgl. \autoref{sec:impl_endl_körper}). 
Unter dieser Analogie ist dies gerade das Ergebnis der Funktion "genFrobMats".

\paragraph{Iteration von $E$ auf der Suche nach vollständigen Erzeugern}
Wie in der Beschreibung von @processFiniteField@
(\autoref{lst:processFiniteField}) angegeben, starten wir die Suche nach
vollständig normalen und primitiven Elementen bei einer Iteration des endlichen
Körpers $E$, bis wir für jeden Kreisteilungsmodul der Zerlegung einen
vollständigen Erzeuger gefunden haben. Die konkrete Iteration erfolgt dabei
lexikographisch in $\F_2^6$, wobei wir der besseren Lesbarkeit geschuldet
zwischen den verschiedenen Schreibweisen von Vektoren in $\F_2^6$ und
Polynomen in $\F_2[a]\big/(a^6 + a^4 + a^3 + a + 1)$ ohne besondere
Kennzeichnung wechseln werden.
\begin{description}
  \item[$u := \vec{0&0&0&0&0&0}.$] Hier gibt es nichts zu tun.
  \item[$u := \vec{1&0&0&0&0&0}.$] Wir blicken auf "polys" und berechnen
    \[ (x^2+1)(\sigma)(1) \speq= 0\ \checkmark,
    \qquad (x+1)(\sigma)(1) \speq= 0\ \lightning\,.\]
    Also ist $1$ kein Erzeuger von $\C_{1,1\cdot 2}$ über $\F_2$.
    Beim zweiten Kreisteilungsmodul scheitern wir bereits beim ersten Polynom:
    \[ (x^4+x+1)(\sigma)(1) \speq= 1\ \lightning\,.\]
  \item[\ldots] Hier sind weitere Elemente zu denken, die ebenfalls keine 
    vollständigen Erzeuger liefern.
  \item[$u := \vec{0&1&1&0&0&0}.$] Dieses Element liefert einen vollständigen
    Erzeuger des zweiten Kreisteilungsmoduls:
    \[\begin{array}{r@{\ =\ }l@{\quad}r@{\ =\ }l} 
      (x^4+x^2+1)(\sigma)(u) & 0, &
      (x^2+x+1)(\sigma)(u) & a^5+a^4+a^2+1, \\[8pt]
      (x+a^3+a^2+a^1)(\sigma^2)(u) & a^5 + a^4 + a^3 + a, &
      (x+a^3+a^2+a)(\sigma^2)(u) & a^5+a^4\,.
      \end{array}\]
    Die Anwendung des Frobenius ist dabei jeweils durch obige Matrizen zu
    denken.
  \item[\ldots]
  \item[$u := \vec{0&1&1&1&0&0}.$] Hier haben wir einen vollständigen Erzeuger
    des ersten Kreisteilungsmoduls, wie nachstehende Rechnung zeigt.
    \[\begin{array}{r@{\ =\ }l@{\qquad}r@{\ =\ }l} 
      (x^2+1)(\sigma)(u) & 0, &
      (x+1)(\sigma)(u) & 1\,.
      \end{array}\]
\end{description}
Die berechneten vollständigen Erzeuger speichern wir in einem Array aus
verketteten Listen (vgl. \autoref{subsub:verkettete_listen}). Die verketteten
Listen sowie das Array wollen wir hier jedoch wieder in \python-üblicher 
Notation angeben. Bisher haben wir also für jeden Kreisteilungsmodul einen
Erzeuger gefunden:
\[ \text{"roots"}\ =\ \big[\, [a^3+a^2+a],\ [a^2+a] \,\big]\]
Die Benennung "roots" ist hier konsistent mit @processFiniteField@
(\autoref{lst:processFiniteField}) gewählt. Jedoch sind die Elemente der Listen
natürlich wieder als @FFElem@ zu denken.


\paragraph{Enumeration der einzelnen Kreisteilungsmoduln}
An diesem Punkt haben wir für jeden Kreisteilungsmodul einen Erzeuger gefunden
und können anhand diesem den jeweiligen Modul vollständig enumerieren.
\begin{description}
  \item[$\Phi_{1,1}^2.$] Sei $u := a^3+a^2+a$ unser gefundener Erzeuger, so können
    wir nach \thref{lemma:moduln_durch_polys} den Modul durch Polynome über
    $F$, deren Grad kleiner $2$ ist, enumerieren:
    \[ \C_{1,1\cdot 2} \speq= \{ f(\sigma)(u):\ 
      f \in F[x]_{<2},\ \ggT(f,\Phi_{1,1}^2) = 1\}\,.\]
    Wie im Absatz nach \thref{lemma:moduln_durch_polys} erwähnt, führen wir die
    Berechnung des $\ggT$ nicht durch, sondern testen jedes Element auf
    vollständige Erzeuger-Eigenschaft für diesen Modul.
    \[\begin{array}{l|l|l}
      f(x) & f(\sigma)(u) & \text{vollst. Erz.}\\\hline
      1 & a^3+a^2+a & \checkmark\\
      x & a^3+a^2+a+1 & \checkmark\\
      x+1 & 1 & \lightning
      \end{array}\]
  \item [$\Phi_{3,1}^2.$] Sei in diesem Fall $u:= a^2+a$ der gefundene
    Erzeuger, so müssen wir Polynome bis zum Grad $3$ über $F$ betrachten:
    \[\begin{array}{l|l|l}
      f(x) & f(\sigma)(u) & \text{vollst. Erz.}\\\hline
      1 & a^2+a & \checkmark\\
      x & a^4+a^2 & \checkmark\\
      x+1 & a^4+a & \lightning\\
      x^2 & a^5+a^2+a+1 & \checkmark\\
      x^2+1 & a^5+1 & \checkmark\\
      x^2+x & a^5+a^4+a+1 & \lightning\\
      x^2+x+1 & a^5+a^4+a^2+1 & \lightning\\
      x^3 & a^5+a^2 & \checkmark\\
      x^3+1 & a^5+a & \lightning\\
      x^3+x & a^5+a^4 & \checkmark\\
      x^3+x+1 & a^5+a^4+a^2+a & \lightning\\
      x^3+x^2 & a+1 & \lightning\\
      x^3+x^2+1 & a^2+1 & \lightning\\
      x^3+x^2+x & a^4+a^2+a+1 & \lightning\\
      x^3+x^2+x+1 & a^4+1 & \lightning
      \end{array}\]
    In der konkreten Implementierung speichern wir diese Ergebnisse nicht ab,
    sondern erzeugen die weiteren Erzeuger des letzten Kreisteilungsmoduls
    dynamisch (vgl.  
    \autoref{sub:dynamische_enumeration}), was
    wir hier zur besseren Übersichtlichkeit nicht tun wollen.
\end{description}

Nun können wir die aktualisierte Liste "roots" angeben:
\[\text{"roots"}\ =\ \big[\, [a^3+a^2+a,\, a^3+a^2+a+1],\ 
  [a^2+a,\, a^4+a^2,\, a^5+a^2+a+1,\, a^5+1,\, a^5+a^2,\, a^5+a^4]\,\big]\]

An dieser Stelle können wir bereits festhalten, dass in der Erweiterung von
Grad $6$ über $\F_2$ genau $6\cdot 2=12$ vollständig normale Elemente
existieren.

\paragraph{Primitivitätstest}
Für einen Primitivitätstest müssen wir die $12$ vollständig normalen Elemente
natürlich erst einmal „zusammenbauen”. Dazu durchlaufen wir das kartesische
Produkt aus den Listen in "roots" und bilden jeweils die Summe der einzelnen
Elemente (vgl. \thref{def:vertraeglich}).
\begin{description}
  \item[$(a^3+a^2+a)\ +\ (a^2+a).$] 
    Wie in der Beschreibung zu @isPrimitive@ (\autoref{lst:isPrimitive})
    erläutert, berechnen wir zunächst $v^\texttt{\scriptsize commonBarFactor} = v^3$,
    wobei $v := a^3+a^2+a + a^2+a = a^3$ das zu testende Element ist.
    Dies führen wir mittels binärer Exponentiation durch, wie in 
    @powerFFElemSqM@ (\autoref{lst:powerffelemsqm}) beschrieben, geben hier
    jedoch nur das Ergebnis an. Es ist 
    \[ v^3 \speq=  a^5 + a^4 + a^2 + 1 \speq{=:} w\,.\]
    Da $w \neq 1$ müssen wir fortfahren mit dem ersten Faktor aus 
    @barFactors@:
    \[ w^3 \speq= a^5 + a^4 + a^2\,. \]
    Auch dies ist ungleich $1$, also fahren wir fort mit 
    $w^\texttt{\scriptsize commonBiggestBarFactor}$ wie in 
    @isPrimitive@ (\autoref{lst:isPrimitive}) angegeben:
    \[ w^7 \speq= 1\,.\]
    An dieser Stelle können wir abbrechen und wissen, dass $v$ kein
    primitives Element ist.
  \item[$(a^3+a^2+a+1)\ +\ (a^2+a).$]
    Auch hier beginnen wir mit $v := a^3+a^2+a+1 + a^2+a = a^3+1$ und 
    berechnen
    \[ v^3 \speq= a^5+a^2+a+1 \speq{=:} w \,.\]
    Wieder ist $w\neq 1$ und wir fahren fort mit dem ersten @barFactor@.
    \[ w^3 \speq= a^4+a^2+a\,.\]
    Für den Exponenten $\text{"biggestCommonBarFactor"} = 7$ erhalten wir:
    \[ w^7 \speq= a^3+a^2+a \speq{=:} z\,.\]
    Diesen müssen wir nun mit allen verbleibenden @barFactor@s potenzieren. In
    unserem Fall lediglich einer:
    \[ z^1 \speq= a^3+a^2+a \]
    und somit ist $v$ ein primitives Element in $E$.
\end{description}

Für alle weiteren Elemente wollen wir nur das Ergebnis der Primitivitätstests
in tabellarischer Form angeben.

\[\begin{array}{l|l|l|l}
  \text{Gen von } \C_{1,1\cdot 2} & \text{Gen von } \C_{3,1\cdot 2} &
    \text{Element} & 
    \text{primitiv} \\\hline
  a^3+a^2+a & a^4+a^2 & a^4+a^3 +a & \checkmark\\
  a^3+a^2+a+1 & a^4+a^2 & a^4+a^3+a+1 & \lightning\\
  a^3+a^2+a & a^5+a^2+a+1 & a^5+a^3+1 & \lightning\\
  a^3+a^2+a+1 &a^5+a^2+a+1 & a^5+a^3 & \checkmark\\
  a^3+a^2+a & a^5+1 & a^5 +a^3+a^2+a+1& \lightning\\
  a^3+a^2+a+1 &a^5+1 & a^5+a^3+a^2+a &\checkmark\\
  a^3+a^2+a & a^5+a^2 & a^5+a^3+a & \checkmark\\
  a^3+a^2+a+1 & a^5+a^2& a^5+a^3+a+1 &\lightning\\
  a^3+a^2+a & a^5+a^4 & a^5+a^4+a^3+a^2+a &\checkmark\\
  a^3+a^2+a+1 & a^5+a^4 & a^5+a^4+a^3+a^2+a+1 &\lightning\\
  \end{array}\]

Zusammenfassend existieren also $6$ primitiv vollständig normale Elemente in
der Erweiterung von Grad $6$ über $\F_2$.

\section{Auswertung der Ergebnisse}

Alle berechneten Ergebnisse werden in Tabellen im Anhang bereitgestellt.
Wie man erkennen kann, konnten wir alle Werte von 
\citeauthor{morgan1996} aus \autocite{morgan1996} reproduzieren. Darüber
hinaus konnten wir die konkreten Anzahlen der Erzeuger der jeweiligen 
nicht weiter zerlegbaren Kreisteilungsmoduln bestimmen (vgl. Tabellen), 
was gerade aus theoretischer Sicht ein interessantes Resultat ist, da diese
Zahlen möglicherweise auf der Suche nach einer allgemeinen Formel für die
vollständigen Erzeuger eines Kreisteilungsmoduls helfen können (Wir erinnern
uns, dass \thref{satz:anzahl_vollst_erzeuger} lediglich für 
reguläre Kreisteilungsmodule gilt). 
Zuletzt sei erwähnt, dass die obig vorgestellte Implementierung nur
eine unwesentliche Menge an Arbeitsspeicher erfordert, wodurch weitere
Ergebnisse problemlos produziert werden könnten, wenn man Rechenzeiten von über
einer Woche pro Körpererweiterung in Kauf nimmt. Die längste hier in Kauf
genommene Rechenzeit lag für $(q,n)=(243,4)$ bei $98$ Stunden und $4$ Minuten.


\section{Existenz von primitiv vollständig normalen Elementen}

\subsection{Theoretische Aspekte}

Zu Beginn dieses Kapitels wurde die Bezeichnung $\G$ als die Menge der
$n\in \N^\ast$ eingeführt, für die Erweiterungen von Grad $n$ über \emph{jedem}
endlichen Köper ein $\PCN$-Element enthalten und in
\thref{prob:g} haben wir uns das Ziel gesetzt, möglichst viele $n$
anzugeben, die in $\G$ liegen. Zunächst können wir alle Erweiterungen
aufnehmen, für die $n$ über jedem $q$ einfach ist,
da hier die Existenz eines primitiv vollständig normalen Elementes
der eines primitiv normalen entspricht, die nach 
\thref{satz:primitive_normalbasis} gesichert ist. 
Des Weiteren sichert \thref{satz:pcn_in_regular}, dass wir auch 
a priori alle ungeraden Erweiterung aufnehmen können, die regulär über jedem
Grundkörper sind. Dazu geben wir einige Beispiele an 
(vgl. \autocite[Abschnitt vor Section 2]{hachenberger2001}):

\begin{lemma}
  \label{lemma:regular_speziell}
  Sei $n \in \N^\ast$. Dann gilt: $n$ ist regulär
  über jeder Primzahlpotenz $q>1$, falls eine der nachstehenden
  Bedingungen erfüllt ist:
  \begin{enumerate}
    \item $n$ ist Potenz einer beliebigen Primzahl.
    \item $n = N^s$ für $s\geq 1$ und $N$ eine 
      \emph{Carmichael Zahl} (Eine \emph{Carmichael Zahl} ist eine ungerade
      natürliche Zahl $N$, sodass für jeden Primteiler $r$ von $N$ gilt: 
      $r-1$ teilt $N-1$).
  \end{enumerate}
\end{lemma}
\begin{proof}
  \begin{enumerate}
    \item Sei $n = r^s$ für eine Primzahl $r$ und 
      $q = p^e$ für eine Primzahl $p$, so ist für  $r=p$ klar,
      dass $\ord_{\nu(n)}(q) = \ord_{1}(q)=1$ gilt. Für $r \neq p$ haben wir
      $\ord_{\nu(n)}(q) = \ord_r(q) \mid \varphi(r) = r-1$ nach
      \thref{lemma:rechenregeln_ordn} und damit ist $(n,q)$ regulär, da
      $\ggT(r,r-1) = 1$.
    \item Schreibe $\nu(N^s) = \prod_{i=1}^k r_i$ für Primzahlen 
      $r_1,\ldots,r_k$. Dann ist wie oben $\ord_{\nu(N^s)}(q)$ ein
      Teiler von $\varphi(\nu(N^s)) = \prod_{i=1}^k\varphi(r_i) = 
      \prod_{i=1}^k (r_i-1)$. Nun gilt jedoch $(r_i-1) \mid (N-1) \mid (N^s-1)$
      und damit $\ggT(r_i-1, N^s) = 1$ für alle $i=1,\ldots,k$.
  \end{enumerate}
\end{proof}


Damit können wir bereits eine große Teilmenge von $\G$ ausmachen:

\begin{proposition}
  \label{prop:G}
  Es gilt:
  \[ \{ N^s:\ N\text{ Carmichael Zahl},\ s\in \N^\ast\} \ \cup\ 
    \{ r^s:\ r \text{ Primzahl},\ s\in \N^\ast\} \quad\subset\quad \G\,. \]
\end{proposition}
\begin{proof}
  Klar nach \thref{kor:einfache_erweiterungen} und 
  \thref{lemma:regular_speziell}.
\end{proof}

Doch wie können wir $\G$ noch größer werden lassen? 
Betrachten wir einmal alle $n\in \{ 2,3,\ldots,33\}$, so sehen wir mit
obiger Proposition, dass lediglich für 
\[ 6,\ 12,\ 14,\ 15,\ 18,\ 20,\ 21,\ 22,\ 24,\ 26,\ 28,\ 30\]
  %34,\ 35,\ 36,\ 38,\ 40\]
diese Frage noch offen ist.
Mit Hilfe von \thref{satz:pcn_schranke} brauchen wir für jedes $n$ 
„nur” alle $q < n^4$ auf Existenz eines $\PCN$-Elements zu überprüfen. Daher
bietet es sich an, an dieser Stelle erneut \sage zu bemühen, um letztlich
nachstehenden Satz beweisen zu können:

\begin{satz}
  \label{satz:hauptsatz_g}
  %Es gilt
  %\[ \{ 2,3,4, \ldots, 40 \} \speq\subseteq \G \,.\]
  Für alle $n\in \N^\ast$ mit $2 \leq n \leq 33$ gilt
  $n \in \G$.
\end{satz}


\subsection{Implementierung einer $\PCN$-Suche I}

Im Gegensatz zur Enumeration einer einzigen Körpererweiterungen geht es nun
darum, viele Körpererweiterungen mit immer gleichem Erweiterungsgrad zu
betrachten. Beispielsweise sind für $n = 30$ genau
$64902$ Körpererweiterungen zu prüfen, wobei das größte auftauchende $q$
gleich $809993$ ist.
%und damit der größte zu betrachtende Körper
%$21\,\allowbreak
 %366\,\allowbreak
 %880\,\allowbreak
 %187\,\allowbreak
 %906\,\allowbreak
 %632\,\allowbreak
 %687\,\allowbreak
 %514\,\allowbreak
 %074\,\allowbreak
 %105\,\allowbreak
 %613\,\allowbreak
 %675\,\allowbreak
 %429\,\allowbreak
 %853\,\allowbreak
 %637\,\allowbreak
 %389\,\allowbreak
 %181\,\allowbreak
 %949\,\allowbreak
 %057\,\allowbreak
 %288\,\allowbreak
 %253\,\allowbreak
 %929\,\allowbreak
 %247\,\allowbreak
 %658\,\allowbreak
 %456\,\allowbreak
 %282\,\allowbreak
 %382\,\allowbreak
 %468\,\allowbreak
 %815\,\allowbreak
 %886\,\allowbreak
 %964\,\allowbreak
 %073\,\allowbreak
 %599\,\allowbreak
 %674\,\allowbreak
 %916\,\allowbreak
 %653\,\allowbreak
 %373\,\allowbreak
 %765\,\allowbreak
 %754\,\allowbreak
 %199\,\allowbreak
 %896\,\allowbreak
 %430\,\allowbreak
 %060\,\allowbreak
 %696\,\allowbreak
 %944\,\allowbreak
 %213\,\allowbreak
 %682\,\allowbreak
 %519\,\allowbreak
 %652\,\allowbreak
 %698\,\allowbreak
 %462\,\allowbreak
 %471\,\allowbreak
 %628\,\allowbreak
 %340\,\allowbreak
 %522\,\allowbreak
 %570\,\allowbreak
 %646\,\allowbreak
 %913\,\allowbreak
 %923\,\allowbreak
 %734\,\allowbreak
 %591\,\allowbreak
 %660\,\allowbreak
 %041\,\allowbreak
 %323\,\allowbreak
 %668\,\allowbreak
 %864\,\allowbreak
 %602\,\allowbreak
 %928\,\allowbreak
 %439\,\allowbreak
 %707\,\allowbreak
 %352\,\allowbreak
 %577\,\allowbreak
 %304\,\allowbreak
 %227\,\allowbreak
 %818\,\allowbreak
 %869\,\allowbreak
 %137\,\allowbreak
 %311\,\allowbreak
 %550\,\allowbreak
 %893\,\allowbreak
 %478\,\allowbreak
 %904\,\allowbreak
 %281\,\allowbreak
 %581\,\allowbreak
 %752\,\allowbreak
 %801$
%Elemente besitzt.
Da in diesen Bereichen das Aufstellen von Frobenius-Matrizen, Additions- und
Multiplikationstabellen nicht mehr praktikabel ist, haben wir uns entschieden,
die gesamte Existenzsuche in \sage zu implementieren.


Den Test auf vollständige Normalität organisieren wir anhand nachstehendem
Lemma: 

\begin{lemma}
  Sei $E := \F_{q^n}$ über $F := \F_q$ eine Erweiterung endlicher Körper.
  Sei $x^n-1 = \prod_{i=1}^l \Phi_{k_i,t_i}^\pi$
  die feinst mögliche Zerlegung nach 
  dem Zerlegunssatz (\thref{satz:zerlegungssatz}).
  Notiere
  \[ D_1 \speq{:=} \{ d\mid n:\ 
    \nexists d'\mid d:\ \F_{q^n} \text{ über } \F_{q^{d'}}
    \text{ einfach} \}\]
  und 
  \[ D_2 \speq{:=} \{ d\in \N^\ast:\ d \mid \tfrac{k_it_i\pi}{\nu(k_i)}
    \text{ für ein } i=1,\ldots,l\}\,.\]
  Dann sind für $u\in E$ äquivalent:
  \begin{enumerate}
    \item $u$ ist vollständig normal über $F$.
    \item Für alle $d \in D := D_1 \cap D_2$ ist
      $\Ord_{q^d}(u) = x^{\frac n d}-1$.
    \item Für alle $d\in D$ gilt:
      Seien $x^{\frac n d}-1 = \prod_{j=1}^{l_d} f_i(x)^{\nu_i}$ 
      die vollständige Faktorisierung  von $x^{\frac n d}-1$ 
      über $\F_{q^d}$ und 
      $\bar f_i(x) = \tfrac{x^{\frac n d}-1}{f_i(x)}$ 
      für $i=1,\ldots,l_d$ die jeweiligen
      Kofaktoren, so gilt
      \[ \bar f_i(\sigma^d)(u) \speq\neq 0 \]
      für alle $i=1,\ldots,l_d$, wobei wie immer 
      $\sigma: \bar F \to \bar F, x\mapsto x^q$ den Frobenius-Endomorphismus
      von $F$ bezeichne.
  \end{enumerate}
\end{lemma}
\begin{proof}
  Die Äquivalenz von (2) und (3) ist klar mit der Definition der $q$-Ordnung,
  wobei es klar ist, dass $(x^{\frac n d}-1)(\sigma^d)(u) = 0$ nicht mehr
  überprüft werden muss, da es das Minimalpolynom von $\sigma^d$ über 
  $\F_{q^d}$ ist.
  Letztlich bleibt also nur ein Wort darüber zu verlieren, warum es ausreicht
  nur Teiler aus $D$ zu betrachten: Hier stellen wir fest, dass es klar ist,
  lediglich Teiler aus $D_1$ zu betrachten, da alle weiteren Teiler von $n$
  bereits Zwischenkörper einer einfachen Erweiterung sind.
  Bleibt $D_2$ zu klären. Dazu zerlege $u = u_1+\ldots+u_l$ mit
  $u_i \in \C_{k_i,t_i\pi}$ für $i=1,\ldots,l$. Nun gilt
  nach der Definition von vollständigen Erzeugern
  (\thref{def:vollst_erzeuger}), dass
  $u_i$ genau dann ein vollständiger Erzeuger von $\C_{k_i,t_i\pi}$ ist,
  wenn $\Ord_{q^d}(u_i) = \Phi_{k_i,t_i}^\pi$ für alle
  Teiler $d$ des Modulcharakters $\frac{k_it_i\pi}{\nu(k_i)}$.
  Ist damit (3) erfüllt, so sind alle $u_i$ vollständige Erzeuger und nach
  Definition verträglicher Zerlegungen (\thref{def:vertraeglich}) folgt
  (1).
\end{proof}


Konkret ist der Test auf vollständige Normalität wie folgt gegeben.


\begin{sagecode}[caption={Aus \url{../Sage/findAnyPCN_trinom.spyx}}]
# Tests x as Element of E on complete normality, i.e. tests for each 
# d in divs, if the corresponding polynomials in prodsAll over the corresponding
# field in fieldsAll vanishes on frobenius evaluation of x.
# fieldsAll and facsAll are dicts indexed by the divisors of divs, where
# fieldsAll[d] is the corresponding intermediate field of order q^d
# and facsAll[d] is the factorization of x^(n/d)-1 over GF(q^d).
# prodsAll[d] is the list of all possible cofactors of above factorization.
def isCompletelyNormal(x,E, q, divs, fieldsAll, facsAll, prodsAll):
    if x == E.zero(): return False
    #test isNormal for each divisor
    pows = dict()
    for d in divs:
        h = Hom(fieldsAll[d],E)[0];
        for idx,(f,mult) in enumerate(facsAll[d]):
            g = prodsAll[d][idx];
            ret = E.zero();
            iold = 0
            xiold = x
            for i,gi in enumerate(list(g)):
                if pows.has_key(i*d):
                    xi = pows[i*d];
                    iold = i*d
                    xiold = xi
                else:
                    xi = xiold**(q**(d*i-iold));
                    pows[i*d] = xi;
                    xiold = xi
                    iold = i*d
                ret += h(gi)*xi
            if ret == 0: return False;
    return True
\end{sagecode}

Hier wurde auf eine Anwendung der Frobenius-Auswertung durch
Matrixmultiplikation verzichtet, da dies via purem \sage-Code wesentlich
langsamer ist, als Potenzieren. Wie man jedoch erkennen kann, werden bereits
berechnete Potenzen wiederverwendet, um hier unnötigen Rechenaufwand
einzusparen.
Die Parameter "divs", "fieldsAll", "facsAll" und "prodsAll" werden jeweils in
den übergeordneten Funktionen "findAnyPCN_polynom" 
(\autoref{lst:findAnyPCN_polynom}) und
"findAnyPCN_polynom_prime" (\autoref{lst:findAnyPCN_polynom_prime})
wie folgt generiert.

\begin{sagecode}[caption={Aus \url{../Sage/findAnyPCN_trinom.spyx}}]
    #setup factors of x^n-1
    divs = get_proper_subfield_divisors(p,r,n)
    facsAll = dict();
    prodsAll = dict();
    fieldsAll = dict();
    for d in divs:
        G = F.extension(Integer(d), 'c');
        Gx = PolynomialRing(G,'x');
        fieldsAll[d] = G;
        facsAll[d] = list((Gx.gen()**(n/d)-1).factor());
        prodsAll[d] = dict();
        for idx,(f,mult) in enumerate(facsAll[d]):
            prodsAll[d][idx] = (Gx.gen()**(n/d)-1).quo_rem(f)[0]
\end{sagecode}




Bereits \citeauthor{morgan1996} haben in \autocite{morgan1996} für alle 
$p^n < 10^{50}$ mit $p\leq 97$ ein primitives, vollständig normales Polynom 
von Grad $n$ über $\F_p$ angegeben. Betrachtet man diese Tabellen, so ist
auffällig, dass sehr viele dieser Polynome Trinome sind. Man kann sich leicht
überlegen, dass ein Binom nicht Minimalpolynom eines vollständig normalen
Elements einer Körpererweiterung sein kann und bemerke, dass sich 
zwei Koeffizienten des Minimalpolynoms eines primitiv vollständig normalen
Elements etwas eingrenzen lassen:

\begin{lemma}
  \label{lemma:pcn_koeff}
  Sei $u \in \F_{q^n}$ über $\F_q$ ein primitiv vollständig normales Element
  und $f(x) \speq= x^n + a_{n-1}x^{n-1}+\ldots+a_0 \in \F_q[x]$ 
  sein Minimalpolynom. Dann gilt
  \begin{enumerate}
    \item $a_{n-1} \speq= -\Tr_{\F_{q^n}\mid \F_q}(u) \speq\neq 0$ und 
    \item $(-1)^na_0 \speq= \Nm_{\F_{q^n}\mid \F_q}(u)$ ist primitiv in $\F_q$.
  \end{enumerate}
\end{lemma}
\begin{proof}
  Die beiden Identitäten sind klar durch Koeffizientenvergleich von
  $f(x) = (x-u)(x-u^q)(x-u^{q^2})\cdot\ldots\cdot(x-u^{q^{n-1}})$.%
  \footnote{Man kennt diesen Zusammenhang der 
    Koeffizienten eines Polynoms mit seinen Nullstellen auch unter dem Namen
    „elementarsymmetrische Funktionen”.}
  Die Spur eines (vollständig) normalen Elements einer Körpererweiterungen ist
  stets ungleich Null, da sie ja gerade die Summe aller Basiselemente der 
  von jenem Element erzeugten Normalbasis ist und diese ja über dem Grundkörper
  linear unabhängig sind. 
  Die Primitivität der Norm erhalten wir sofort durch
  \[ \Nm_{\F_{q^n}\mid \F_q}(u) \speq= u\cdot u^q\cdot \ldots\cdot u^{q^n-1}
    u^{\frac{q^n-1}{q-1}}\,.\]
  Aus der Primitivität von $u$ folgt nun $\ord(u^{\frac{q^n-1}{q-1}}) = q-1$
  und damit $\ord((-1)^na_0) = q-1$.
\end{proof}

In der Hoffnung möglichst viele Trinome vorzufinden, haben wir uns das Ziel
gesetzt für jede Primzahlpotenz $q$ mit $q < n^4$ für einen gegebenen
Erweiterungsgrad $n$ das „kleinste” primitiv vollständig normale Polynom
über $\F_q$ von Grad $n$ zu bestimmen. Das „kleinste” beziehe sich dabei auf
folgende Ordnungsrelation:

\begin{definition}
  \label{def:polynomordnung}
  Seien $f(x) = x^n+a_{n-1}x^{n-1}+\ldots+a_0$ und
  $g(x) = x^n + b_{n-1}x^{n-1}+\ldots+b_0$ zwei Polynome gleichen Grades über 
  $\F_q$. Ferner bezeichne $i(f)$ dasjenige Wort über dem Alphabet
  $\{ 0,\ldots,n\}$, das die Indizes der nicht verschwindenden 
  Koeffizienten von $f$ in
  aufsteigender Reihenfolge repräsentiert, d.h. ist $i(f) = i_1i_2\ldots i_k$,
  so gilt $i_1<i_2<\ldots<i_k$ und $a_{i_j} \neq 0$ für alle 
  $j \in \{i_1,\ldots,i_k\}$. Analog sei $a(f)$ das Wort über dem Alphabet 
  $\F_q$, das die nicht verschwindenden Koeffizienten von $f$ 
  ihrem Index aufsteigend nach repräsentiert, d.h. ist 
  $a(f) = a_{i_1}a_{i_2}\ldots a_{i_k}$, so ist 
  $i_1<i_2<\ldots<i_k$ und für alle $j \in \{i_1,\ldots,i_k\}$ gilt:
  $a_{i_j}$ ist der nicht verschwindende Koeffizient
  von $x^{i_j}$ in $f$.

  Dann heißt $f$ \emph{kleiner oder gleich} $g$, 
  geschrieben $f\preceq g$, falls gilt:
  \begin{enumerate}
    \item $i(f)$ ist lexikographisch kleiner oder gleich $i(g)$ und bei
      Gleichheit gilt zusätzlich:
    \item $a(f)$ ist kleiner oder gleich $a(g)$, wobei eine Ordnung
      auf $\F_q$ gegeben ist ist wie folgt:
      \begin{itemize}
        \item Ist $q = p$ für eine Primzahl $p$, so wähle die natürliche Ordnung von
          $\F_p \cong \{ 0,1,\ldots,p-1\}$.
        \item Sonst wähle einmalig eine Repräsentation von 
          $\F_q$ durch $\F_p[x]\big/(h(x))$ und definiere 
          $u$ kleiner gleich $v$ für $u,v\in \F_q$ als
          $a(x) \preceq b(x)$ via dieser Definition für
          Repräsentanten $a(x)$ von $u$ und $b(x)$ von $v$ mit
          $a(x),b(x) \in F_p[x]$ und $\deg(a),\deg(b) < \deg(h)$.
      \end{itemize}
  \end{enumerate}
\end{definition}


Wir haben uns für diese Definition einer Ordnung auf $\F_q[x]$ entschieden, da
hier stets Polynome 
\begin{itemize}
  \item mit kleinerem Hamming-Gewicht, d.h. mit kleinerer Anzahl an 
    nicht verschwindenden Koeffizienten, 
  \item mit kleineren Exponenten,
  \item mit „kleineren“ Koeffizienten (vgl. obige Definition)
\end{itemize}
bevorzugt werden.


Die konkrete Suche nach einem $\PCN$-Polynom für ein Paar $(n,q)$ 
teilen wir in zwei verschiedene Funktionen auf, wobei wir
"findAnyPCN_polynom_prime" nutzen wollen, falls $q$ eine Primzahl ist und
"findAnyPCN_polynom", falls $q$ eine echte Primzahlpotenz ist. Der wesentliche
Unterschied liegt dabei in der Enumeration des Grundkörpers $\F_q$, einmal
simplerweise durch $\{0,1,\ldots,p-1\}$ darstellbar, falls $q = p$ eine
Primzahl ist. Andernfalls müssen wir uns wieder des Polynomrings
über dem Primkörper $\F_p$ bedienen, um die Elemente in
$\F_q \cong \F_p[x]\big/(f(x))$ für $q=p^r$ für $r>1$ darstellen zu können.
Konkret:

\begin{sagecode}[caption={Aus \url{../Sage/findAnyPCN_trinom.spyx}},
  label=lst:findAnyPCN_polynom_prime]
# special function for testing extensions of PrimeFields
def findAnyPCN_polynom_prime(p,n):
    p = Integer(p)
    n = Integer(n)
    F = GF(p)
    
    Fx = PolynomialRing(F,'x')
    
    orderE = p**n
    primOrder = orderE-1
    
    primitives = []

    #setup factors of x^n-1
    divs = get_proper_subfield_divisors(p,1,n)
    facsAll = dict();
    prodsAll = dict();
    fieldsAll = dict();
    for d in divs:
        G = F.extension(Integer(d), 'c');
        Gx = PolynomialRing(G,'x');
        fieldsAll[d] = G;
        facsAll[d] = list((Gx.gen()**(n/d)-1).factor());
        prodsAll[d] = dict();
        for idx,(f,mult) in enumerate(facsAll[d]):
            prodsAll[d][idx] = (Gx.gen()**(n/d)-1).quo_rem(f)[0]

    firstRun = True
    # first test trinoms!
    for coeffT in xrange(1,p):
        if firstRun:
            if is_even(n):
                prange = xrange(1,p)
            else:
                prange = xrange(p-1,0,-1)
            for coeffN in prange:
                if F(coeffN).multiplicative_order() != p-1: continue
                if is_even(n):
                    primitives += [coeffN]
                else:
                    coeffN *= (-1)
                    primitives = [coeffN] + primitives
                f = Fx.gen()**n + coeffT*Fx.gen()**(n-1) + coeffN
                if not f.is_irreducible(): continue
                
                E = GF(orderE, name='a', modulus=f)

                if E.gen().multiplicative_order() == primOrder \
                        and isCompletelyNormal(E.gen(),E,p,\
                            divs,fieldsAll,facsAll,prodsAll):
                    return E.gen(),f
            firstRun = False
        else:
            for coeffN in primitives:
                f = Fx.gen()**n + coeffT*Fx.gen()**(n-1) + coeffN
                if not f.is_irreducible(): continue
                E = GF(orderE, name='a', modulus=f)

                if E.gen().multiplicative_order() == primOrder \
                        and isCompletelyNormal(E.gen(),E,p,\
                            divs,fieldsAll,facsAll,prodsAll):
                    return E.gen(),f
    # test rest
    for length in xrange(1,n-1):
        for idcs in itertools.combinations(xrange(1,n-1),length):
            for xs in itertools.product(xrange(1,p),repeat=length+1):
                for x in primitives:
                    f = Fx.gen()**n + xs[0]*Fx.gen()**(n-1) + x
                    for j,j2 in enumerate(idcs):
                        f += xs[length-j] * Fx.gen() ** j2
                    if not f.is_irreducible(): continue
                    E = GF(orderE, name='a', modulus=f)

                    if E.gen().multiplicative_order() == primOrder \
                            and isCompletelyNormal(E.gen(),E,p,\
                                divs,fieldsAll,facsAll,prodsAll):
                        return E.gen(),f
\end{sagecode}

Wie man erkennen kann stützen wir uns auf die Hoffnung Trinome vorzufinden und
beginnen unsere Suche daher bei deren Enumeration. Ferner machen wir uns
\thref{lemma:pcn_koeff} zu Nutze und bestimmen anfangs dynamisch die primitiven
Elemente des Grundkörpers (vgl. Zeilen \texttt{37}-\texttt{43}).
Um die Ordnung nach \thref{def:polynomordnung} beizubehalten, sind wir hier
gewzungen eine Fallunterscheidung in $n$ gerade oder ungerade zu vollziehen
(vgl. Zeile \texttt{38}). Ebenfalls ein Vorteil gegenüber 
"findAnyPCN_polynom" ist die Tatsache, dass der Erweiterungskörper "E"
durch das zu testende Polynom gegeben werden kann und so dieses nicht erst über
"E" faktorisiert werden muss (vgl. Zeilen \texttt{46}, \texttt{48}).

Es sei ferner angemerkt, dass \sage eine Funktion "is_primitive" für Polynome
besitzt, die gerade testet, ob ein Polynom primitiv ist oder nicht. Jedoch hat
sich herausgestellt, dass dies um ein Vielfaches länger dauert, als die hier
beschriebene Methode in Zeile \texttt{48}.


Falls der Grundkörper kein Primkörper ist, organisieren wir die Suche analog,
wobei wir gewzungen sind, einige „Umwege“ zu gehen.


\begin{sagecode}[caption={Aus \url{../Sage/findAnyPCN_trinom.spyx}},
  label=lst:findAnyPCN_polynom]
def findAnyPCN_polynom(p,r,n):
    if r == 1:
        return findAnyPCN_polynom_prime(p,n)

    q = p**r
    F = GF(q,'a')

    E = F.extension(n,'a')
    P = E.prime_subfield()

    Px = PolynomialRing(P,'x')
    Fx = PolynomialRing(F,'x')
    Ex = PolynomialRing(E,'x')
    h = Hom(F,E)[0]
    primOrder = E.order()-1
    
    primitives = []
    
    #setup factors of x^n-1
    divs = get_proper_subfield_divisors(p,r,n)
    facsAll = dict();
    prodsAll = dict();
    fieldsAll = dict();
    for d in divs:
        G = F.extension(Integer(d), 'c');
        Gx = PolynomialRing(G,'x');
        fieldsAll[d] = G;
        facsAll[d] = list((Gx.gen()**(n/d)-1).factor());
        prodsAll[d] = dict();
        for idx,(f,mult) in enumerate(facsAll[d]):
            prodsAll[d][idx] = (Gx.gen()**(n/d)-1).quo_rem(f)[0]

    # list elements of F
    Flist = [F.zero()]
    for i in xrange(1,r+1):
        for idcs in itertools.combinations(xrange(0,r),i):
            for koeffs in itertools.product(xrange(1,p),repeat=i):
                Flist += [F(list(sum([e * Px.gen()**idcs[j] for \
                        j,e in enumerate(reversed(koeffs))])))]

    if not is_even(n):
        FprimList = [F.zero()]
        for i in xrange(1,r+1):
            for idcs in itertools.combinations(xrange(0,r),i):
                for koeffs in itertools.product(xrange(p-1,0,-1),repeat=i):
                    FprimList += [F(list(sum([e * Px.gen()**idcs[j] for \
                            j,e in enumerate(reversed(koeffs))])))]

    firstRun = True
    # first test trinoms!
    for coeffT in xrange(1,q):
        coeffTF = Flist[coeffT]
        if firstRun:
            for coeffN in xrange(p,q):
                if is_even(n):
                    coeffNF = Flist[coeffN]
                else:
                    coeffNF = FprimList[coeffN]
                if coeffNF.multiplicative_order() != F.order()-1: continue
                if not is_even(n): coeffNF *= (-1)
                primitives += [coeffNF]
                f = Fx.gen()**n + coeffTF*Fx.gen()**(n-1) + coeffNF
                if not f.is_irreducible(): continue
                for fac,mul in Ex(f.map_coefficients(h)).factor():
                    if fac.degree() == 1:
                        x = -fac[0]
                        if isCompletelyNormal(x,E,q,divs,\
                                    fieldsAll,facsAll,prodsAll) and \
                                x.multiplicative_order() == primOrder:
                            return x,f
                        else: break
                    else: break
            firstRun = False
        else:
            for coeffNF in primitives:
                f = Fx.gen()**n + coeffTF*Fx.gen()**(n-1) + coeffNF
                if not f.is_irreducible(): continue
                for fac,mul in Ex(f.map_coefficients(h)).factor():
                    if fac.degree() == 1:
                        x = -fac[0]
                        if isCompletelyNormal(x,E,q,divs,\
                                    fieldsAll,facsAll,prodsAll) and \
                                x.multiplicative_order() == primOrder:
                            return x,f
                        else: break
                    else: break
    # test rest
    for length in xrange(1,n-2):
        for idcs in itertools.combinations(xrange(1,n-1),length):
            for xs in itertools.product(xrange(1,q),repeat=length+1):
                for x in primitives:
                    f = Fx.gen()**n + Flist[xs[0]]*Fx.gen()**(n-1) + x
                    for j,j2 in enumerate(idcs):
                        f += Flist[xs[length-j]] * Fx.gen() ** j2
                    if not f.is_irreducible(): continue
                    for fac,mul in Ex(f.map_coefficients(h)).factor():
                        if fac.degree() == 1:
                            y = -fac[0]
                            if isCompletelyNormal(y,E,q,divs,\
                                    fieldsAll,facsAll,prodsAll) and \
                                    y.multiplicative_order() == primOrder:
                                return y,f
                            else: break
                        else: break
\end{sagecode}

Man erkennt, dass wir hier die Elemente aus $F$ eigens generieren müssen, um
den Bedingungen aus \thref{def:polynomordnung} gerecht zu werden.

Sicherlich ist klar, dass man auch eine Funktion braucht, die gleich alle
$q$ für gegebenes $n$ testet:


\begin{sagecode}[caption={Aus \url{../Sage/findAnyPCN_trinom.spyx}}]
def findAnyPCN_polynom_wrapper(n, border=lambda n:n**4, \
        fileoutput=False, filepath="pcns_trinom_", \
        startPrime=1, stopPrime=0, onlyR=None, \
        cpuNum=1):
    if fileoutput:
        st = datetime.datetime.\
                fromtimestamp(time.time()).strftime('%Y-%m-%d_%H:%M:%S')
        filepath += str(n)+"_"
        if onlyR != None: filepath += str(onlyR)+"_"
        filepath += st
    border = border(n)
    p = startPrime
    if onlyR != None and p**onlyR > border: return

    gen = runGenerator(border,startPrime,stopPrime,onlyR)
    pool = Pool(cpuNum)
    for p,r,n,(x,pol) in pool.imap( findAnyPCN_polynom__star, \
            ((p,r,n) for p,r in gen) ):
        if fileoutput:
            with open(filepath,'a') as f:
                f.write(str(p)+"\t"+str(r)
                        +"\t"+str(pol)+"\n")
            f.close();
    pool.close()
    pool.join()
\end{sagecode}

Wie man erkennen kann, hat es sich als Vorteilhaft erwiesen die Argumente
"startPrime", "stopPrime" und "onlyR" einzuführen, wobei letzteres lediglich
Paare $(q,n)$ testet, bei denen $q = p^r$ mit $r=$ "onlyR". (Insbesondere eine
Trennung zwischen "onlyR" $=1$ und dem Rest war hilfreich, da es stets sehr
viele Primzahlen $p$ mit $p<n^4$ gibt, jedoch nur wenige, für die eine echte
Potenz immernoch kleiner $n^4$ ist.)


Wir schließen mit den beiden Hilfsfunktionen, die in obiger Funktion
benutzt werden, um der Syntax von "Pool.imap" gerecht zu werden.

\begin{sagecode}[caption={Aus \url{../Sage/findAnyPCN_trinom.spyx}}]
def findAnyPCN_polynom__star(prn):
    return prn[0],prn[1],prn[2],findAnyPCN_polynom(*prn)
\end{sagecode}


\begin{sagecode}[caption={Aus \url{../Sage/findAnyPCN_trinom.spyx}}]
def runGenerator(border,startPrime,stopPrime,onlyR):
    p = startPrime
    while p < border :
        if stopPrime != 0 and p > stopPrime: return
        p = next_prime(p)
        # consider only one r
        if onlyR != None:
            r = onlyR
            if p**r > border: continue
            yield p,r
        # consider all rs
        else:
            r = 1
            q = p**r
            while q < border:
                yield p,r
                r += 1
                q = p**r
\end{sagecode}

In den Tabellen in \autoref{anh:pcns} findet man die Ergebnisse unsere
computergestützten Suche.


\subsection{Implementierung einer $\PCN$-Suche II}

Leider waren wir nicht in der Lage für alle Paare $(p^r,n)$ obige Implementierung
zu nutzen, da gerade für große $r$ in sinnvoller Rechenzeit kein $\PCN$-Polynom
gefunden werden konnte. Um für diese Ausnahmen dennoch ein $\PCN$-Polynom
präsentieren zu können, geben wir für diese Erweiterungen ein beliebiges
$\PCN$-Polynom an (also nicht wie oben das beste im Sinne der Ordnung aus
\thref{def:polynomordnung}). Dieses finden wir wie folgt: Für gegebenes $(q,n)$
bestimmen wir ein primitives Element $u \in \F_{q^n}$ via der \sage-Funktion
"primitive_element()". Anschließend iterieren wir aufsteigend über alle 
$i\in\N^\ast$ mit $\ggT(i,q^n-1) = 1$ und beenden die Suche mit
Ausgabe des Minimalpolynoms von $u^i$ über $\F_q$, falls
$u^i$ vollständig normal ist. Nach \thref{satz:zykl_gruppen} (5) ist klar, dass
wir $u^i$ nicht mehr auf Primitivität zu testen brauchen.
In \sage sieht dieses Vorgehen konkret wie folgt aus.

\begin{sagecode}[caption={Aus \url{../Sage/findAnyPCN_additional.spyx}}]
def findAnyPCN(p,r,n):
    q = p**r
    F = GF(q,'a')

    E = F.extension(n,'a')
    P = E.prime_subfield()

    Px = PolynomialRing(P,'x')
    Fx = PolynomialRing(F,'x')
    Ex = PolynomialRing(E,'x')
    h = Hom(F,E)[0]
    primOrder = E.order()-1
    
    primitives = []
    
    #setup factors of x^n-1
    divs = get_proper_subfield_divisors(p,r,n)
    facsAll = dict();
    prodsAll = dict();
    fieldsAll = dict();
    for d in divs:
        G = F.extension(Integer(d), 'c');
        Gx = PolynomialRing(G,'x');
        fieldsAll[d] = G;
        facsAll[d] = list((Gx.gen()**(n/d)-1).factor());
        prodsAll[d] = dict();
        for idx,(f,mult) in enumerate(facsAll[d]):
            prodsAll[d][idx] = (Gx.gen()**(n/d)-1).quo_rem(f)[0]
    
    # get one primitive element
    x = E.primitive_element()
    
    lasti = 0
    y = x
    for i in itertools.count(1):
        if gcd(i,E.order()-1) != 1: continue
        y = y*x**(i-lasti)
        lasti = i
        if isCompletelyNormal(y,E,q,divs,fieldsAll,facsAll,prodsAll):
            mipo = y.minpoly()
            for f,i in Fx(mipo).factor():
                if f(y) == E.zero():
                    return f
\end{sagecode}


Die „unschönen“ Ergebnisse dieser Funktion wurden im Anhang speziell
gekennzeichnet.


\subsection{Auswertung der Ergebnisse}

Mit Hilfe der hier vorgestellten Funktionen zur Findung von $\PCN$-Polynomen
konnte nun bewiesen werden, dass für alle $n \in \{ 2,3,\ldots,33\}$ und für
alle Primzahlpotenzen $q$ ein primitiv vollständig normales Polynom von Grad
$n$ über $\F_q$ existiert (\thref{satz:hauptsatz_g}). Dies stellt in der Tat
eine 


Wie man anhand der Tabellen im Anhang erkennen kann, konnten wir nachweisen,
dass für sehr viele Erweiterungen primitiv vollständig normale Trinome
existieren. Inbesondere kann man erkennen, dass wenn $q$ nur groß genug wird,
offenbar stets ein $\PCN$-Trinom vorhanden ist. Dieses faszinierende Resultat 
legt die folgende Vermutung nahe, die bisher gänzlich unklar bleibt und für die 
zumindest im Rahmen dieser Arbeit keine Möglichkeit eines 
Beweises gefunden werden konnte.

\begin{vermutung}
  Für jedes $n\in \N^\ast$ existiert ein $P\in \N^\ast$, so dass für alle
  Primzahlpotenzen $q \geq P$ ein primitiv vollständig normales Trinom von Grad
  $n$ über $\F_q$ existiert.
\end{vermutung}
