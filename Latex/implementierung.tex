\lstMakeShortInline[
  basicstyle = \small\normalfont\ttfamily,
  frame = none,
% numbers = left,
  numberstyle = \tiny,
% numbersep = 5pt,
  breaklines = true,
  %xleftmargin = 0.1\linewidth,
  %xrightmargin = 0.1\linewidth,
  escapeinside = {(*}{*)},
  tabsize=3,
  language=C,
  mathescape=true,
  breaklines=true]@

\lstMakeShortInline[
  basicstyle = \small\normalfont\ttfamily,
  frame = none,
% numbers = left,
  numberstyle = \tiny,
% numbersep = 5pt,
  breaklines = true,
  %xleftmargin = 0.1\linewidth,
  %xrightmargin = 0.1\linewidth,
  escapeinside = {(*}{*)},
  tabsize=3,
  language=Python,
  mathescape=true,
  breaklines=true]"


\chapter{Enumeration primitiv vollständig normaler Elemente}

In den vorangegangenen Kapiteln haben wir lediglich normale und vollständig
normale Elemente in Erweiterungen endlicher Körper betrachtet. Es existiert
jedoch eine weitere besondere Eigenschaft, die gerade in der Anwendung von
großem Interesse ist: Primitivität (\thref{def:primitiv}).

\TODO %theorie über primitiv vollst normal fehlt\ldots

In diesem Kapitel interessieren wir uns für die Anzahl von normalen bzw.
vollständig normalen Elementen in einer gegeben Körpererweiterung, d.h. wir
widmen uns der beiden folgenden Fragen:

\begin{frage}
  Sei $\F_q$ ein endlicher Körper und $n\in \N^\ast$. Wie viele 
  verschiedene normale Elemente existieren in der Erweiterung $\F_{q^n} \mid
  \F_q$.
\end{frage}

Wir wollen
dazu zunächst einige theoretische Resultate angeben, doch im Allgemeinen bleibt 

\section{Theoretische Enumerationen}




\section{Implementierung endlicher Körper und Körpererweiterungen}
\label{sec:impl_endl_körper}
Grundsätzlich wurde zur konkreten Suche und Enumeration primitiver und
vollständig normaler Elemente das Computeralgebrasystem \sage verwendet.
\sage bietet bereits die Möglichkeit in endlichen Körpern zu rechnen. Jedoch
hat sich herausgestellt, dass die zugrunde liegenden \Clang-Bibliotheken 
(im Allgemeinen Fall ist dies das \texttt{Pari C library}%
\footnote{vgl. \url{http://www.sagemath.org/doc/reference/%
rings_standard/sage/rings/finite_rings/constructor.html}}) 
zu langsam sind. Dies ist sicherlich auf die Allgemeinheit ihrer
Anwendungsgebiete zurückzuführen. Beispielsweise arbeitet die 
\texttt{Pari}-Bibliothek stets mit Ganzzahlen beliebiger Größe. Deren
Arithmetik ist selbstredend aufwendiger und langsamer, als maschineninterne
\texttt{Integer}-Arithmetik. Daher haben wir uns entschlossen eigene 
\Clang-Bibliotheken anzulegen, die auf einfacher (jedoch begrenzter) 
\texttt{Integer}-Arithmetik basieren.

\subsection{Beschreibung von Elementen endlicher Körper}
\label{sub:beschreibung_endliche_koerper}
Die Implementierung von Primkörpern ist freilich kanonisch. Daher brauchen wir
an dieser Stelle nicht viele Worte verlieren, da wir auf der Suche nach
primitiv und vollständig normalen Elementen ohnehin nur in Erweiterungen von
Graden größer $1$ zu rechnen haben.

Sei also $\F_q$ ein endlicher Körper von Charakteristik $p$ und $q = p^r$
für $r>1$.
Wie auch in \sage üblich, haben wir uns entschieden bei der programmatischen
Beschreibung die Isomorphie
\[ \F_q \speq\cong \F_p[x] \big/ (f(x))\]
mit $f(x) \in F_p[x]$ irreduzibel von Grad $r$ zu nutzen. 
Also wird ein Element $w \in \F_q$ als Array der Länge $r+1$ beschrieben,
wobei die nullte Stelle des Arrays auch den Koeffizienten von $x^0$ meint, und
alle Berechnungen (insb. Multiplikation) modulo $f(x)$ ausgeführt.

Es hat sich herausgestellt, dass es von Vorteil ist, neben dem Koeffizienten
tragenden Array ein weiteres Array mitzuführen, welches die
Indizes speichert, deren zugehörige Koeffizienten nicht verschwinden. Letztlich
fehlt noch, wie es in \Clang üblich und notwendig ist, die Länge des
Indexarrays zu speichern und wir erhalten den Datentyp @struct FFElem@.

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=15]
/**
 * Finite Field Element. 
 * 
 * !! idcs must be in desc order !!
 *
 * Uses int arrays, i.e. you must not consider 
 * PrimeFields of order p with  (p-1)*(p-1) > INT_MAX
 */
struct FFElem{
    int *el;
    int *idcs;
    int len;
};
\end{ccode}

@len@ gibt immer die Länge von @idcs@ an. Zusätzlich fordern wir noch folgende
Eigenschaften, die den Umgang mit @struct FFElem@ erleichtern.

\begin{invariante}
  \label{invariante:desc_order}
  Für das Indexarray @idcs@ eines @struct FFElem@ sei sichergestellt, 
  dass die Werte stets in absteigender Reihenfolge sortiert sind. 
\end{invariante}

\begin{invariante}
  \label{invariante:array_len}
  Bei der Benutzung von @struct FFElem@ sei sichergestellt, 
  dass die Länge aller auftretenden Arrays dem Grade der 
  Körpererweiterung über dem jeweiligen Primkörper entspricht
\end{invariante}

\cref{invariante:desc_order} erleichtert den Zugriff auf
den Grad des Elements (also seinen Grad als Polynom in
$\F_p[x]\big/(f(x))$). Letztere Invariante stellt sicher, dass durch
Veränderung eines @struct FFElem@ (beispielsweise Arithmetik) kein 
Speicherzugriffsfehler auftritt.

\begin{beispiel}
  Wollen wir das Element 
  \[ w := x^8 + 2*x^6 + x^2 + 2 \in \F_3[x]\]
  des endlichen Körpers $\F_{3^{10}}$ 
  (wir verzichten auf Angabe eines Minimalpolynoms, da es hier keine
  Rolle spielt) in obiger Darstellung beschreiben, so müssen wir \Clang-üblich
  Speicher allokieren und die Arrays in passender Länge anlegen:
  \begin{cexample}
    struct FFElem *w = malloc(sizeof(struct FFElem));
    w->el = (int[]) {2, 0, 1, 0, 0, 0, 2, 0, 1, 0};
    w->idcs = (int[]) {9, 7, 2, 0, 0, 0, 0, 0, 0, 0};
    w->len = 4;
  \end{cexample}
  Der besseren Lesbarkeit zu Gute haben wir die ungenutzten Indizes und die 
  verschwindenden Koeffizienten mit @0@ aufgefüllt. Man überlege sich jedoch,
  dass lediglich eine einzige @0@ notwendig ist und alle anderen 
  beliebig ersetzt werden könnten. Beispielsweise ist
  \begin{cexample}
    struct FFElem *w = malloc(sizeof(struct FFElem));
    w->el = (int[]) {2, -10, 1, 100, -2, -3, 2, -4, 1, -8};
    w->idcs = (int[]) {9, 7, 2, 0, -3, -2, -5, -1, -1, -1};
    w->len = 4;
  \end{cexample}
  mit obiger Beschreibung identisch.
\end{beispiel}


\subsubsection{Hilfsfunktionen zum Anlegen und Löschen}

Da \Clang ohne \emph{Garbage-Collection} auskommt, muss man selbst für die
entsprechende Speicherverwaltung sorgen. Dies erleichtern die Funktionen
@mallocFFElem@ und @freeFFElem@.

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=30]
inline struct FFElem *mallocFFElem(int m){
    struct FFElem *ff = malloc(sizeof(struct FFElem));
    ff->el = malloc(m*sizeof(int));
    ff->idcs = malloc(m*sizeof(int));
    ff->len = 0;
    return ff;
}
\end{ccode}

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=37]
inline void freeFFElem(struct FFElem *ff){
    free(ff->el);
    free(ff->idcs);
    free(ff);
}
\end{ccode}

Schließlich führen wir noch eine Funktion ein, die den Inhalt eines
@struct FFElem@s in ein neues kopiert. Dieses muss aber bereits allokiert sein!


\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=50]
/**
 * Copies the content of ff1 into ff2
 *
 * !! ff2 must be malloced!
 */
inline void copyFFElem(struct FFElem *ff1, struct FFElem *ff2){
    if(ff1 == ff2) return;
    int i;
    for(i=0;i < ff1->len;i++){
        ff2->idcs[i] = ff1->idcs[i];
        ff2->el[ ff1->idcs[i] ] = ff1->el[ ff1->idcs[i] ];
    }
    ff2->len = ff1->len;
}
\end{ccode}

\subsection{Arithmetik in endlichen Körpern}
\label{sub:arithmetik_in_endlichen_körpern}


\subsubsection{Additions- und Multiplikationstabellen}
Will man Arithmetik mit @struct FFElems@ betreiben, so stellt sich sicherlich
am Anfang die Frage, wie die Arithmetik im Primkörper 
$\F_p = \{0,1,\ldots,p-1\}$
aussehen möge. Da
die @FFElem@s auf @int@-Arrays basieren liegt es nahe, die Addition bzw.
Multiplikation zweier Elemente $a,b\in \F_p$ durch die integrierten Funktionen
@($a$+$b$) % $p$@ 
und @($a$*$b$) % $p$@
zu implementieren. Es hat sich jedoch herausgestellt, dass dies vergleisweise
langsam ist. Insbesondere bei kleinen Primzahlen hat sich das Anlegen einer
Additions- und einer Multiplikationstabelle bewährt. Diese sind @int@-Arrays,
sodass die @($a$+$b$)@-te Stelle der Additions- und die 
@($a$*$b$)@-te Stelle der Multiplikationstabelle gerade das Ergebnis der
jeweiligen Rechnung in $\F_p$ liefert.

\begin{bemerkung}
  Um sich nicht um vorzeichenbehaftete Werte kümmern zu müssen, überdecken die
  Tabellen auch negative Bereiche und daher ist eine Additionstabelle in $\F_p$
  stets von Länge $4(p-1)+1$ und eine Multiplikationstabelle von
  Länge $2(p-1)^2+1$.
\end{bemerkung}

\begin{beispiel}
  Betreiben wir Arithmetik in $\F_3$, so legen wir eine Additions- bzw.
  Multiplikationstabelle wie folgt an und stellen durch eine Verschiebung des
  Pointers sicher, dass auch vorzeichenbehaftete Rechnungen richtig erfasst
  werden können.
  \begin{cexample}
    int addTableRaw[] = {2, 0, 1, 2, 0, 1, 2, 0, 1};
    int initialAddShift = 4;
    int *addTable = addTableRaw+initialAddShift;
    int multTableRaw[] = {2, 0, 1, 2, 0, 1, 2, 0, 1};
    int initialMultShift = 4;
    int *multTable = multTableRaw+initialMultShift;
  \end{cexample}
  Führen wir nun Rechnungen durch können wir diese nutzen:
  \begin{cexample}
    addTable[ 2+1 ]  // == 0 
    addTable[ 0-2 ]  // == 1
    multTable[ 2*2 ]  // == 1
  \end{cexample}
\end{beispiel}


\subsubsection{Addition}
Aufgrund der effizienteren Darstellung der Elemente endlicher Körper durch
Speicherung ihrer Indices, ist die Addition nicht lediglich gegeben durch
komponentenweise Betrachtung, sondern erfordert etwas mehr Aufwand.

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=226]
/**
 * Adds two FFElems.
 *
 * !! ff1 may be same as ret !!
 * !! ff2 must not be same as ret !!
 */
inline void addFFElem(struct FFElem *ff1, struct FFElem *ff2,
        struct FFElem *ret,
        int *tmp,
        int *multTable, int *addTable){
    int i=0,j=0,k=0, i2;
    bool end = false;
    //handle trivial cases
    if(ff1->len == 0){
        copyFFElem(ff2,ret);
        return;
    }
    if(ff2->len == 0){
        copyFFElem(ff1,ret);
        return;
    }
    copyArray(ff1->idcs,tmp,ff1->len);
    while( end == false ){
        while( tmp[i] != ff2->idcs[j] ){
            if( tmp[i] > ff2->idcs[j] ){
                ret->el[ tmp[i] ] = ff1->el[ tmp[i] ];
                ret->idcs[k] = tmp[i];
                i++; k++;
            }else if( tmp[i] < ff2->idcs[j] ){
                ret->el[ ff2->idcs[j] ] = ff2->el[ ff2->idcs[j] ];
                ret->idcs[k] = ff2->idcs[j];
                j++; k++;
            }
            if(i == ff1->len || j == ff2->len){
                end = true;
                break;
            }

        }
        if(end == true) break;
        //tmp[i] == ff2->idcs[j]
        i2 = tmp[i];
        ret->el[i2] = addTable[ ff1->el[i2] + ff2->el[i2] ];
        if(ret->el[i2] != 0){
            ret->idcs[k] = i2;
            k++;
        }
        i++; j++;
        if(i == ff1->len || j == ff2->len) end = true;
    }
    //add rest of ff1 or ff2
    if(i != ff1->len ){
        while(i<ff1->len){
            ret->el[ tmp[i] ] = ff1->el[ tmp[i] ];
            ret->idcs[k] = tmp[i];
            i++; k++;
        }
    }else if(j != ff2->len){
        while(j<ff2->len){
            ret->el[ ff2->idcs[j] ] = ff2->el[ ff2->idcs[j] ];
            ret->idcs[k] = ff2->idcs[j];
            j++; k++;
        }
    }
    ret->len = k;
}
\end{ccode}  

Wie später aus der Beschreibung anderer Algorithmen hervorgeht, ist es von
Vorteil, wenn das Ergebnis einer Addition bereits eines der beiden addierten
Elemente ist. Auf diese Weise spart man das Anlegen unnötiger Hilfs-@FFElem@s.
Wie man schnell einsieht, werden jeweils nur die beiden Indexarrays durchlaufen
und lediglich wenn diese gleich sind, muss eine Addition ausgeführt werden;
ansonsten reicht es den jeweiligen Koeffizienten zu übernehmen.


\subsubsection{Multiplikation}
Wir haben uns entschieden, keine speziellen Multiplikationsalgorithmen 
(wie Karatsuba oder FFT-basierte Algorithmen) zu implementieren, da
die hier betrachteten Erweiterungen nicht von Graden sind, in denen jene
Algorithmen ihre Vorteile ausspielen könnten.

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=302]
/**
 * Multiplies two FFElems and reduces the result by mipo.
 *
 * !! tmp must have at least length m!
 * !! ret must be malloced!
 */
inline void multiplyFFElem(struct FFElem *ff1, struct FFElem *ff2, 
        struct FFElem *ret, 
        struct FFElem *mipo, int *tmp, int m,
        int *multTable, int *addTable){
    /* 
     * catch trivial cases
     */
    if(ff1->len == 0 || ff2->len == 0){
        ret->len = 0;
        return;
    }
    if(ff1->len == 1 && ff1->idcs[0] == 0 && ff1->el[0] == 1){
        copyFFElem(ff2, ret);
        return;
    }
    if(ff2->len == 1 && ff2->idcs[0] == 0 && ff2->el[0] == 1){
        copyFFElem(ff1, ret);
        return;
    }

    /*
     * Do multiplication
     */
    int maxlen = ff1->idcs[0] + ff2->idcs[0] + 1;
    int i,j,i2,j2,k;
    int max2 = maxlen;
    if( maxlen > m ){
        max2 = m;
        initPoly(tmp,maxlen-m);
    }
    initPoly(ret->el,max2);
    //multiply 
    for(i=0;i<(ff1->len);i++){
        for(j=0;j<(ff2->len);j++){
            i2 = ff1->idcs[i];
            j2 = ff2->idcs[j];
            k = i2+j2;
            if(k<m){
                ret->el[k] = addTable[ ret->el[k] + 
                    multTable[ ff1->el[i2] * ff2->el[j2] ] ];
            }else{
                tmp[k-m] = addTable[ tmp[k-m] +
                    multTable[ ff1->el[i2] * ff2->el[j2] ] ];
            }
        }
    }
    
    /*
     * Reduce mod mipo
     */
    if(maxlen > m){
        int quo;
        for(i=maxlen-m-1;i>=0;i--){
            quo = tmp[i];
            if(quo == 0) continue;
            for(j=0;j<(mipo->len); j++){
                j2 = mipo->idcs[j];
                k = i+j2;
                if(k>=m){
                    tmp[k-m] = addTable[ tmp[k-m] - 
                        multTable[ mipo->el[j2]*quo ] ];
                }else{
                    ret->el[k] = addTable[ ret->el[k] - 
                        multTable[ mipo->el[j2]*quo ] ];
                }
            }
        }
    }

    /*
     * Recalc indices
     */
    i2 = 0;
    for(i=max2-1;i>=0;i--){
        if(ret->el[i] != 0){
            ret->idcs[i2] = i;
            i2++;
        }
    }
    ret->len = i2;
}
\end{ccode}
Außer den beiden zu multiplizierenden @FFElem@s muss man natürlich das
Minimalpolynom des zu Grunde liegenden Körpers und dessen Grad über dem
Primkörper -- hier mit @int m@ bezeichnet -- mit übergeben.
Leider war es an dieser Stelle im Gegensatz zur Addition nicht 
möglich, die Indizes des Produkts direkt zu berechnen, da es sich bei den
Koeffizienten des Produkts ja Summen von Produkten von Koeffizienten der beiden
Faktoren handelt. Daher muss nach der
Reduktion modulo Minimalpolynoms eine Neuberechnung der Indizes erfolgen.

\subsubsection{Quadratur}
Im Hinblick auf das Testen von @struct FFElem@s auf Primitivität und dem damit
verbundenen Potenzieren, existiert eine separate Funktion zur Quadrierung eines 
@FFElem@s. Es ist klar, dass beim Quadrieren weniger Produkte und Summen
berechnet werden müssen als bei einer allgemeinen Multiplikation.
\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=404]
/**
 * Squares an FFElem
 *
 * !! ff is not modified !!
 * !! tmp must have at least length m !!
 */
inline void squareFFElem(struct FFElem *ff, struct FFElem *mipo,
        struct FFElem *ret, int *tmp, int m,
        int *multTable, int *addTable){
    /* 
     * catch trivial cases
     */
    if(ff->len == 0){
        copyFFElem(ff,ret);
        return;
    }
    if(ff->len == 1 && ff->idcs[0] == 0 && ff->el[0] == 1){
        copyFFElem(ff,ret);
        return;
    }

    /*
     * Do multiplication
     */
    int maxlen = 2*ff->idcs[0] + 1;
    int i,j,i2,j2,k;
    int max2 = maxlen;
    if( maxlen > m ){
        max2 = m;
        initPoly(tmp,maxlen-m);
    }
    initPoly(ret->el,max2);
    for(i=0;i<(ff->len);i++){
        // same index must be squared
        i2 = ff->idcs[i];
        k = 2*i2;
        if(k<m){
            ret->el[k] = addTable[ ret->el[k] + 
                multTable[ ff->el[i2]*ff->el[i2] ] ];
        }else{
            tmp[k-m] = addTable[ tmp[k-m] +
                multTable[ ff->el[i2]*ff->el[i2] ] ];
        }
        // other indices only multipied and doubled
        for(j=i+1;j<(ff->len);j++){
            i2 = ff->idcs[i];
            j2 = ff->idcs[j];
            k = i2+j2;
            if(k<m){
                ret->el[k] = addTable[ ret->el[k] + 
                    multTable[ 2 * multTable[ ff->el[i2] * ff->el[j2] ] ] ];
            }else{
                tmp[k-m] = addTable[ tmp[k-m] +
                    multTable[ 2 * multTable[ ff->el[i2] * ff->el[j2] ] ]];
            }
        }
    }
    /*
     * Reduce mod mipo
     */
    if(maxlen > m){
        int quo;
        for(i=maxlen-m-1;i>=0;i--){
            quo = tmp[i];
            if(quo == 0) continue;
            for(j=0;j<(mipo->len); j++){
                j2 = mipo->idcs[j];
                k = i+j2;
                if(k>=m){
                    tmp[k-m] = addTable[ tmp[k-m] - 
                        multTable[ mipo->el[j2]*quo ] ];
                }else{
                    ret->el[k] = addTable[ ret->el[k] - 
                        multTable[ mipo->el[j2]*quo ] ];
                }
            }
        }
    }

    /*
     * Recalc indices
     */
    i2 = 0;
    for(i=max2-1;i>=0;i--){
        if(ret->el[i] != 0){
            ret->idcs[i2] = i;
            i2++;
        }
    }
    ret->len = i2;
}
\end{ccode}


\subsection{Matrizen und Polynome über endlichen Körpern}

\subsubsection{Matrizen und Matrixmultiplikation}

Nach \thref{satz:power_p_linear} ist das Potenzieren mit der Charakteristik in
endlichen Körpern eine lineare Abbildung. Dies wollen wir Nutzen und haben
daher als Darstellung von Matrizen über endlichen Körpern naheliegenderweise
ein Array aus @FFElem@s gewählt.

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=515]
/**
 * Matrix multiplication
 *
 * !! tmp must have at least length m!
 */
inline void matmul(struct FFElem **mat, struct FFElem *ff,
        struct FFElem *ret, 
        int m, int *multTable, int *addTable){
    int i,j,i2, row;
    bool end;
    for(row=0;row<m;row++){
        ret->el[row] = 0;
        i=0; j=0;
        end = false;
        while(end == false){
            while(ff->idcs[i] != mat[row]->idcs[j]){
                if(ff->idcs[i] > mat[row]->idcs[j]) i++;
                else if(ff->idcs[i] < mat[row]->idcs[j]) j++;
                if(i == ff->len || j == mat[row]->len){
                    end = true;
                    break;
                }
            }
            if(end == true) break;
            i2 = ff->idcs[i]; // == mat[row]->idcs[j]
            ret->el[row] = addTable[ ret->el[row] 
                + multTable[ mat[row]->el[i2]*ff->el[i2] ] ];
            i++;
            j++;
            if(i==ff->len || j==mat[row]->len) end = true;
        }
    }
    i2 = 0;
    for(i=m-1;i>=0;i--){
        if(ret->el[i] != 0){
            ret->idcs[i2] = i;
            i2++;
        }
    }
    ret->len = i2;
}
\end{ccode}

Hier wird -- anders als bei der Addition -- nur nach den gemeinsamen Indizes
gesucht (alle anderen Produkte sind schließlich 0). 
\thref{invariante:desc_order} stellt dabei wiederum sicher, dass das hier
aufgeführte Verfahren funktioniert.

Ferner existiert eine Funktion, die das Freigeben von Matrizen erleichtert.

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=43]
inline void freeFFElemMatrix(struct FFElem **mat, int len){
    if(mat==0) return;
    int i;
    for(i=0;i<len;i++) freeFFElem(mat[i]);
    free(mat);
}
\end{ccode}


\subsubsection{Polynome}
Im Hinblick auf das Testen von @FFElem@s auf vollständige Normalität 
(bzw. vollständige Erzeuger-Eigenschaft) müssen wir einen Weg wählen, Polynome
über endlichen Körpern darzustellen; also Polynome deren Koeffizienten 
@FFElem@s sind. Dazu führen wir ein eigenes @struct@ ein.

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=144]
struct FFPoly{
    struct FFElem **poly;
    int lenPoly;
};
\end{ccode}


\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=149]
inline struct FFPoly *mallocFFPoly(int m, int lenPoly){
    struct FFPoly *poly = malloc(lenPoly*sizeof(struct FFElem*));
    poly->lenPoly = lenPoly;
    int i;
    for(i=0;i<lenPoly;i++) poly->poly[i] = mallocFFElem(m);
    return poly;
}
\end{ccode}  

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=157]
inline void freeFFPoly(struct FFPoly *poly){
    int i;
    for(i=0;i<poly->lenPoly;i++) freeFFElem(poly->poly[i]);
    free(poly->poly);
    free(poly);
}
\end{ccode}  


\section{Potenzieren und Primitivitätstest}

\subsection{Potenzieren}
Für das Potenzieren von @FFElem@s wurde stets ein Square-and-Multiply-Ansatz
verwendet. Da in endlichen Körpern jedoch das Potenzieren mit der
Charakteristik eine lineare Abbildung darstellt, ist es a priori nicht unklug
eine $p$-adische Square-and-Multiply-Variante zu wählen. Es hat sich jedoch
herausgestellt, dass in den meisten Fällen normales Square-and-Multiply
schneller ist als sein $p$-adisches Pendant. Dies veranschaulicht auch
nachstehendes Beispiel.

\begin{beispiel}
  Sei $u \in E := \F_{3^4}$ und zu berechnen sei $u^{16}$, so stellen wir zunächst
  $16$ binär und $3$-adisch da:
  \[ 16 \speq= 10000_2 \speq= 121_3 \,.\]
  Damit gilt
  \[ u^{16} \speq= ((u^2)^2)^2)^2 \speq= (u^3\cdot u\cdot u)^3\cdot u\,.\]
  In einer Implementierung sehen wir also, dass die binäre Exponentiation 
  $4$ Quadrierungen „kostet“, die $3$-adische Version 
  hingegen $2$ Matrixmultiplikationen und $3$ Multiplikationen.
  Da in der Regel allgemeine Multiplikationen teuer sind, wäre in diesem Fall
  die binäre Variante wohl die bessere Wahl.\\
  Wollen wir $u^{10}$ berechnen, so sehen wir aus
  \[ 10 \speq= 1010_2 \speq= 101_3\,,\]
  dass in diesem Fall die binäre Exponentiation 4 Quadierungen und eine
  allgemeine Multiplikation erfordert, die $3$-adische Variante jedoch nur 
  $2$ Matrixmultiplikationen und $1$ allgemeine Multiplikation. Letzteres lässt
  sich sogar auf eine Matrixmultiplikation reduzieren, berechnet man die
  Darstellungsmatrix der linearen Abbildung $E\to E,\ x\mapsto x^9$ bereits
  vorher! Die beiden Varianten der Berechnung würden 
  in diesem Fall also wie folgt von Statten gehen:
  \[ u^{10} \speq= ((u^2)^2\cdot u)^2 \speq= u^9\cdot u\,.\]
\end{beispiel}

Nachstehend werden nun die beiden Varianten der Implementierung der Potenzierung
aufgeführt. Wir beginnen mit $p$-adischem Square-and-Multiply. Zu bemerken ist,
dass die Potenz bereits in $p$-adischer Darstellung als @int@-Array übergeben
werden muss. Zudem werden vermeidbare Matrixmultiplikationen (vgl. obiges
Beispiel) nicht durchgeführt und es ist sicherzustellen, 
dass @struct FFElem **matCharac@ als @struct FFElem*@-Array
von Länge $(l+1)m$ ist, wobei $l$ die Länge
des maximal auftretenden $0$-Intervalls in der $p$-adischen Darstellung meint 
(in obigem Beispiel bei $u^{10}$ wäre $l=1$).


\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=562, label=lst:powerffelem]
/**
 * Square and multiply in charac
 * mat is powering by charac
 *
 * !! ff is modified !!
 */
inline void powerFFElem(struct FFElem *ff, struct FFElem *mipo,
        struct FFElem *ret, 
        int m, int *power, int powerLen,
        struct FFElem **matCharac, int *tmp, struct FFElem *ffTmp,
        int *multTable, int *addTable){
    int i,j,k;
    int lenCurGap = 0;
    struct FFElem *ffSwitch = 0;
    struct FFElem *ffRetInt = ret;
    // init ret to 1
    ffRetInt->el[0] = 1; ffRetInt->idcs[0] = 0; ffRetInt->len = 1;
    for(j=powerLen-1;j>=0;j--){
        for(k=0;k<power[j];k++){
            multiplyFFElem(ffRetInt,ff,ffTmp, mipo,tmp,m,multTable,addTable);
            ffSwitch = ffRetInt; ffRetInt = ffTmp; ffTmp = ffSwitch;
        }
        if(j==0 || power[j-1] == 0){
            lenCurGap++;
            continue;
        }
        matmul(matCharac+lenCurGap*m, ff, ffTmp, m, multTable,addTable);
        ffSwitch = ff; ff = ffTmp; ffTmp = ffSwitch;
        lenCurGap = 0;
    }
    copyFFElem(ffRetInt,ret);
}
\end{ccode}


Als nächstes folgt die standardmäßige binäre Exponentiation. Auch hier wird die
Potenz bereits in Binärdarstellung erwartet.

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=602, label=lst:powerffelemsqm]
/**
 * Square and multiply
 *
 * !! ff is modified !!
 */
inline void powerFFElemSqM(struct FFElem *ff, struct FFElem *mipo,
        struct FFElem *ret, 
        int m, int *power, int powerLen,
        int *tmp, struct FFElem *ffTmp,
        int *multTable, int *addTable){
    int i,j,k;
    int lenCurGap = 0;
    struct FFElem *ffSwitch = 0;
    struct FFElem *ffRetInt = ret;
    // init ret to 1
    ffRetInt->el[0] = 1; ffRetInt->idcs[0] = 0; ffRetInt->len = 1;
    for(j=powerLen-1;j>=0;j--){
        if(power[j] == 1){
            multiplyFFElem(ffRetInt,ff,ffTmp, mipo,tmp,m,multTable,addTable);
            //switch ffTmp and ffRetInt
            ffSwitch = ffRetInt; ffRetInt = ffTmp; ffTmp = ffSwitch;
        }
        if(j>0){
            squareFFElem(ff,mipo,ffTmp,tmp,m,multTable,addTable);
            //switch ffTmp and ff
            ffSwitch = ff; ff = ffTmp; ffTmp = ffSwitch;
        }
    }
    copyFFElem(ffRetInt,ret);
}
\end{ccode}


\subsection{Primitivitätstest}
\label{subsub:primitivitaetstest}

Beim Testen eines Elements eines endlichen Körpers auf Primitivität bedienen
wir uns des wohlbekannten Satz von Lagrange aus der Gruppentheorie und geben
zunächst ein kleines Lemma an, auf dem der dann folgende Algorithmus basiert.

\begin{lemma}
  Sei $u \in \F_q$ und
  \[ q-1 \speq= p_1^{\nu_1}\cdot\ldots\cdot p_r^{\nu_r}\]
  die Primfaktorzerlegung von $q-1$. Definiere
  für alle $i=1,\dots,r$
  \[ \bar n_i \speq{:=}  \frac{q-1}{p_i} \speq=
    p_1^{\nu_1}\cdot \ldots\cdot p_{i-1}^{\nu_{i-1}} \cdot
    p_i^{\nu_i-1}\cdot p_{i+1}^{\nu_{i+1}}\cdot\ldots\cdot p_r^{\nu_r}\,.\]
  Dann gilt: $u$ ist primitiv genau dann, wenn
  \[ u^{\bar n_i} \speq\neq 1\quad\forall i=1,\ldots,r \,.\]
\end{lemma}
\begin{proof}
  Per definitionem der Primitivität klar.
\end{proof}

Es bleibt jedoch immer noch offen diese $r$ Potenzierungen möglichst gut
zu organisieren. Nehmen wir an, die Primzahlen sind in der Primfaktorzerlegung
\[ q-1 \speq= p_1^{\nu_1}\cdot\ldots\cdot p_r^{\nu_r}\]
aufsteigend sortiert, also $p_1<p_2<\ldots < p_r$, so
hat sich als besonders hilfreich erwiesen, die Potenzen $\bar n_i$ auf
Basis der Potenzen
\begin{itemize}
  \item $d := \ggT\{ \bar n_i:\ i=1,\ldots,r\}$ und 
  \item $d' := \ggT\{ \frac{\bar n_i}{d}:\ i=1,\ldots,r-1\}$
\end{itemize}
durchzuführen und die bereits berechneten Potenzen zu nutzen, 
wie nachstehendes Beispiel veranschaulicht.

\begin{beispiel}
  Sei $u \in \F_{3^{10}}$. Da
  \[ 3^{10}-1 = \speq 2^{3} \cdot 11^{2} \cdot 61 \,,\]
  sind folgende Potenzen von $u$ zu berechnen:
  \[ \begin{array}{l@{\ =\ }l@{}l@{}l@{\ =\ }l}
    \bar n_1 & 2^2 \cdot & 11^2 & \cdot 61 & 29524\,,\\
    \bar n_2 & 2^3 \cdot & 11 & \cdot 61 & 5368\,,\\
    \bar n_3 & 2^3 \cdot & 11^2 && 968\,. \end{array} \]
  Wir sehen jedoch dass die Potenzen
  \[ d \speq{:=} \ggT\{ \bar n_1,\bar n_2,\bar n_3\} 
    \speq= 2^2\cdot 11 \speq= 44 \]
  und 
  \[ d' \speq{:=} \ggT\{ \tfrac{\bar n_1}{d},\tfrac{\bar n_2}{d}\} \speq= 61\]
  uns die Arbeit erheblich erleichtern können:
  Wir berechnen $v := u^d = u^{44}$ und 
  $w := v^{d'} = v^{61}$ separat, so schreiben sich die restlichen Potenzen wie
  folgt:
  \[ \begin{array}{l@{\ =\ }l}
    u^{\bar n_3} & w^{11}\,, \\
    u^{\bar n_2} & v^2\,, \\
    u^{\bar n_1} & v^2 \cdot v^{9}\,.
  \end{array} \]
  Selbstverständlich kann man den Test auf Primitivität bereits abbrechen,
  falls $v = 1$ oder $w = 1$.
  Es ist klar, dass in diesem Beispiel obiges Vorgehen eine erhebliche
  Verkleinerung der zu berechnenden Potenzen liefert, die jedoch nicht in allen
  Fällen erwartet werden kann.
\end{beispiel}


In nachstehender Implementierung sind die separat aufgelisteten Potenzen $d$
mit @commonBarFactor@ und $d'$ mit @commonBiggestBarFactor@ bezeichnet und
werden in $p$-adischer bzw. binärer Darstellung erwartet.  Ferner
werden die restlichen $\bar n_i$s in @barFactors@ bereits in 
$p$-adischer bzw. binärer Darstellung als ein einziges @int@-Array übergeben, 
wobei die jeweilige Länge der einzelnen Faktoren in dem @int@-Array
@lenBarFactors@ zu hinterlegen ist. Wie im Quelltext bemerkt, wird 
die Exponentiation $p$-adisch durchgeführt (siehe \autoref{lst:powerffelem}),
falls @matCharac@ ungleich @0@ ist, ansonsten binär 
(siehe \autoref{lst:powerffelemsqm}), wobei natürlich sicherzustellen ist, dass
die Potenzen in passender Darstellung vorliegen.

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=666, label=lst:isPrimitive]
/**
 * Test if element is primitive.
 *
 * !! if matCharac is Zero, all powers are assumed as binary arrays !!
 *
 * !! fff,ffTmp,ffTmp2,ffTmp3,ffRet must be malloced !!
 * !! x is NOT modified !!
 */
inline bool isPrimitive(struct FFElem *ff, struct FFElem *mipo,
        int m,
        int *barFactors, int *lenBarFactors, int countBarFactors,
        int *commonBarFactor, int lenCommonBarFactor,
        int *commonBiggestBarFactor, int lenCommonBiggestBarFactor,
        struct FFElem **matCharac, 
        struct FFElem *fff, struct FFElem *ffff, struct FFElem *ffTmp,
        struct FFElem *ffTmp2, struct FFElem *ffRet, 
        int *tmp, int *multTable, int *addTable){
    int i;
    int curPos = 0;
    bool binarySqM = (matCharac == 0);
    struct FFElem *ffSwitch = 0;

    copyFFElem(ff,fff);
    // all barFactors are power of commonBarFactor
    if(binarySqM)
        powerFFElemSqM(fff,mipo,ffTmp,
                m,commonBarFactor,lenCommonBarFactor,
                tmp,ffTmp2,
                multTable,addTable);
    else 
        powerFFElem(fff,mipo,ffTmp,
                m,commonBarFactor,lenCommonBarFactor,
                matCharac,tmp,ffTmp2,
                multTable,addTable);
    if(isOne(ffTmp)) return false;
    //switch ffTmp and fff
    ffSwitch = fff; fff = ffTmp; ffTmp = ffSwitch;
    copyFFElem(fff,ffff);
    //test first barFactor
    if(binarySqM)
        powerFFElemSqM(ffff,mipo,ffTmp,
                m,barFactors,lenBarFactors[0],
                tmp,ffTmp2,
                multTable,addTable);
    else
        powerFFElem(ffff,mipo,ffTmp,
                m,barFactors,lenBarFactors[0],
                matCharac,tmp,ffTmp2,
                multTable,addTable);
    if(isOne(ffTmp)) return false;
    curPos += lenBarFactors[0];
    //test further factors which are powers of commonBiggestBarFactor
    //so first, calc y^commonBiggestBarFactor
    copyFFElem(fff, ffff);
    if(binarySqM)
        powerFFElemSqM(ffff,mipo,ffTmp,
                m,commonBiggestBarFactor,lenCommonBiggestBarFactor,
                tmp,ffTmp2,
                multTable,addTable);
    else
        powerFFElem(ffff,mipo,ffTmp,
                m,commonBiggestBarFactor,lenCommonBiggestBarFactor,
                matCharac,tmp,ffTmp2,
                multTable,addTable);
    if(isOne(ffTmp)) return false;
    ffSwitch = fff; fff = ffTmp; ffTmp = ffSwitch;
    for(i=1;i<countBarFactors;i++){
        // copy z (fff) to ffff
        copyFFElem(fff,ffff);
        // *** ffff == fff == y^commonBiggestBarFactor
        if(binarySqM)
            powerFFElemSqM(ffff, mipo, ffTmp, 
                    m,barFactors+curPos, lenBarFactors[i],
                    tmp,ffTmp2,
                    multTable,addTable);
        else
            powerFFElem(ffff, mipo, ffTmp, 
                    m,barFactors+curPos, lenBarFactors[i],
                    matCharac,tmp,ffTmp2,
                    multTable,addTable);

        if(i>1){
            multiplyFFElem(ffRet,ffTmp,ffTmp2,mipo,
                    tmp,m,multTable,addTable);
        }else{
            ffSwitch = ffTmp2; ffTmp2 = ffTmp; ffTmp = ffSwitch;
        }
        if(isOne(ffTmp2)) return false;
        curPos += lenBarFactors[i];
        ffSwitch = ffRet; ffRet = ffTmp2; ffTmp2 = ffSwitch;
    }
    return true;
}
\end{ccode}

\section{Frobenius-Auswertung und Test auf vollständige
  Erzeuger-Eigenschaft}

\subsection{Frobenius-Auswertung}

Sei wie immer $F = \F_q$ ein endlicher Körper und $E = \F_{q^m}$ eine
Körpererweiterung. Sei $\C_{k,t}$ ein verallgemeinerter
Kreisteilungsmodul über $F$ (vgl.
\thref{def:verallgemeinerter_kreisteilungsmodul}) und 
$u\in E$ ein Element, das wir als vollständigen Erzeuger 
in Betracht ziehen (vgl. \thref{def:vollst_erzeuger}). Nach 
\thref{satz:erzeuger_zykl_moduln} (3) ist $u$ genau dann ein vollständiger 
Erzeuger von $\C_{k,t}$, wenn
\[ \Ord_{q^d}(u) \speq= \Phi_{\nu(k),\, \frac{kt}{\nu(k)d}} \qquad
  \forall d \mid \tfrac{k\,t}{\nu(k)}\,.\]
Folglich müssen wir, um $q$-Ordnungen berechnen zu können, in der Lage sein,
für beliebige Zwischenkörper $F\mid K\mid E$ von Grad $d$ über $F$ und beliebige 
$f(x) \in K[x]$ 
\[ f(\sigma^d)(u) \in E\]
auswerten zu können, wobei wieder $\sigma: \bar F\to \bar F, x \mapsto x^q$ den
Frobenius über $F$ bezeichne. Bleibt die Frage, wie die verschiedenen
Zwischenkörper mit Hilfe der @FFElem@s gelesen werden können. Da wir $E$ jedoch
stets als Erweiterung über dem zu Grunde liegenden Primkörper betrachten 
(vgl. \autoref{sub:beschreibung_endliche_koerper}) ist dies völlig unklar.
Daher umgehen wir dieses Problem und betrachten eine beliebige Einbettung von
$K$ in $E$. Die Frage, ob man damit immer noch $q$-Ordnungen berechnen kann,
beantwortet nachstehendes Lemma.

\begin{lemma}
  \label{lemma:einbettung_egal}
  Seien $F \mid K\mid E$ ein Turm endlicher Körper mit $[K:F] = d$ und 
  $\sigma: \bar F\to \bar F$ der Frobenius von $F$. 
  Sei $f(x) \in K[x]$ ein Polynom und $u\in E$. Für je zwei
  injektive Körperhomomorphismen
  $g,h: K\to E$ ist entweder
  \[ h(f)(\sigma^d)(u) \speq= 0 \quad\text{und}\quad 
    g(f)(\sigma^d)(u) \speq= 0\]
  oder 
  \[ h(f)(\sigma^d)(u) \speq\neq 0 \quad\text{und}\quad 
    g(f)(\sigma^d)(u) \speq\neq 0\,,\]
  wobei $h(f) \in E[x]$ koeffizientenweise zu lesen ist.\\
  Mit anderen Worten hängt also die Frage, ob eine Frobenius-Auswertung $0$ 
  ist oder nicht, nicht von der Wahl der konkreten Einbettung ab.
\end{lemma}
\begin{proof}
  \marginpar{Müsste man hier ausführlicher argumentieren?}
  Aufgrund der Eindeutigkeit endlicher Körper (z.B.
  \thref{satz:eindeutigkeit_endlicher_koerper}) unterscheiden sich zwei
  Einbettungen $g,h: K\to E$ lediglich um einen Automorphismus $a: E\to E$,
  also $h = a \circ g$. Dies beweist aber bereits die Behauptung.
\end{proof}


Damit können wir uns erstmal davon ausgehen, dass die zu betrachtenden Polynome
bereits in $E[x]$ liegen; also vom Typ @FFPoly@ sind. Analog zu 
\autoref{lst:powerffelem} wird auch hier das Potenzieren durch
Matrixmultiplikation beschrieben, wobei sicherzustellen ist, dass die maximal
auftretende Matrixpotenz vorhanden ist, d.h. übergibt man ein Polynom @poly@
vom Grad $k$, so muss @mats@ als Array bestehend aus @FFElem*@ von Länge
$m\cdot k$ sein, wobei $m$ wiederum den Grad der Erweiterung von $E$ über dem
Primkörper meint. Das bedeutet insbesondere, dass die erste Matrix in @mats@
die Darstellungsmatrix zu $\sigma^1$ ist und der Fall $\sigma^0 = \id$ separat
betrachtet werden muss (vgl. Zeile \texttt{791} in \autoref{lst:applyFrob}).

Im Hinblick auf das Berechnen von $q$-Ordnungen, wo ein Körperelement meist
mehr als einmal einer Frobenius-Auswertung unterzogen werden muss, haben wir
die Möglichkeit bereitgestellt, bereits durchgeführte Matrixmultiplikationen in
@matmulCache@ zu speichern. Das Array @matmulCacheCalced@ gibt dabei an, welche
Stellen in @matmulCache@ bereits berechnet wurden. Selbstredend wird dieser 
Zwischenspeicher durch die Ausführung von @applyFrob@ fortwährend aktualisiert.

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=773, label=lst:applyFrob]
/*
 * calculates g(sigma^frobPower)(x) where g is a polynomial 
 * and sigma the frobenius
 * application of frobenius is given by mats
 */
inline void applyFrob(struct FFElem *ff, struct FFElem *mipo,
        struct FFPoly *poly,
        struct FFElem **mats,
        int frobPower, struct FFElem *ret, 
        int m, int *tmp, struct FFElem *ffTmp, struct FFElem *ffTmp2,
        struct FFElem **matmulCache, bool *matmulCacheCalced,
        int *multTable, int *addTable){
    int i,j;
        
    ret->len = 0;
    for(i=0;i<poly->lenPoly;i++){
        if(poly->poly[i]->len == 0) continue;
        j = i*frobPower-1;
        if(i>0 && matmulCacheCalced[j] == true){
            multiplyFFElem(matmulCache[j],poly->poly[i],
                    ffTmp, mipo,
                    tmp,m,multTable,addTable);
            addFFElem(ret,ffTmp,ret,tmp,multTable,addTable);
        }else{
            if(i>0){
                matmul(mats+j*m, ff, ffTmp, m, multTable,addTable);
                //update matmulCache
                copyFFElem(ffTmp, matmulCache[j]);
                matmulCacheCalced[j] = true;
            }else{
                copyFFElem(ff,ffTmp);
            }
            //go on and multiply ffTmp with current coefficient
            multiplyFFElem(ffTmp, poly->poly[i],
                    ffTmp2, mipo,
                    tmp,m,multTable,addTable);
            addFFElem(ret,ffTmp2,ret,tmp,multTable,addTable);
        }
    }
}
\end{ccode}

Falls bereits klar ist, dass für ein gegebenes Element nur eine
Frobenius-Auswertung vollzogen wird, so ist der @matmulCache@ überflüssig und
führt zur Variante @applyFrob_noCache@, die ansonsten identisch zu obigem ist.

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=827, label=lst:applyFrob_noCache]
/*
 * calculates g(sigma^frobPower)(x) where g is a polynomial 
 * and sigma the frobenius
 * application of frobenius is given by mats
 */
inline void applyFrob_noCache(struct FFElem *ff, struct FFElem *mipo,
        struct FFPoly *poly,
        struct FFElem **mats,
        int frobPower, struct FFElem *ret, 
        int m, int *tmp, struct FFElem *ffTmp, struct FFElem *ffTmp2,
        int *multTable, int *addTable){
    int i,j;
    ret->len = 0;
    
    for(i=0;i<poly->lenPoly;i++){
        if(poly->poly[i]->len == 0) continue;
        if(i>0){
            j = i*frobPower-1;
            matmul(mats+j*m, ff, ffTmp, m, multTable,addTable);
        }else{
            copyFFElem(ff,ffTmp);
        }
        multiplyFFElem(ffTmp, poly->poly[i],
                ffTmp2, mipo,
                tmp,m,multTable,addTable);
        addFFElem(ret,ffTmp2,ret,tmp,multTable,addTable);
    }
}
\end{ccode}


\subsection{Testen von vollständigen Erzeugern}

Wie bereits erwähnt ist $u\in \F_{q^m}$ über $\F_q$ genau dann ein vollständiger
Erzeuger eines verallgemeinerten Kreisteilungsmoduls $\C_{k,t}$, wenn
\[ \Ord_{q^d}(u) \speq= \Phi_{\nu(k),\, \frac{kt}{\nu(k)d}} \qquad
  \forall d\mid \tfrac{k\,t}{\nu(k)}\,.\]
Analog zum Primitivitätstest reicht es, lediglich maximale Kofaktoren des
jeweiligen verallgemeinerten Kreisteilungspolynoms zu testen, wie nachstehendes
Lemma beschreibt.

\begin{lemma}
  Seien $u\in \F_{q^m}$ und $\Phi_{k,t}(x) \in \F_q[x]$ ein verallgemeinertes
  Kreisteilungspolynom. Sei ferner
  \[ \Phi_{k,t}(x)  \speq= f_1(x)^{\nu_1} \cdot \ldots \cdot
    f_r(x)^{\nu_r}\quad \in \F_q[x]\]
  die vollständige Faktorisierung von $\Phi_{k,t}$ über $\F_q$ und
  bezeichne $F_i(x) := \tfrac{\Phi_{k,t}(x)}{f_i(x)}$ den jeweiligen maximalen
  Kofaktor von $f_i$ in $\Phi_{k,t}$ für alle $i=1,\ldots,r$.
  Seien zuletzt $h: \F_q \to \F_{q^m}$ ein injektiver Körperhomomorphismus und 
  $\sigma:\bar \F_q \to \bar \F_q, x\mapsto x^q$ der Frobenius von $\F_q$, 
  so ist $\Ord_q(u) = \Phi_{k,t}$ genau dann, wenn
  \[h(\Phi_{k,t})(\sigma)(u) \speq= 0 
    \qquad\text{und}\qquad 
    h(F_i)(\sigma)(u) \speq\neq 0 \quad \forall i=1,\ldots,r \,.\]
\end{lemma}
\begin{proof}
  Klar per definitionem der $q$-Ordnung und \thref{lemma:einbettung_egal}.
\end{proof}


Nun können wir auf diese Weise leicht eine Implementierung eines Tests auf
vollständige Erzeuger-Eigenschaft angeben, wenn wir davon ausgehen, dass die
Berechnung der maximalen Kofaktoren bereits geschehen ist. In
\autoref{lst:testSubmod} ist also sicherzustellen, dass in dem Array
@polys@ sowohl das verallgemeinerte Kreisteilungspolynom, als auch alle 
maximalen Kofaktoren auftauchen. Das Array @evalToZero@ gibt dabei an, ob 
bei Vorliegen eines vollständigen Erzeugers die Auswertung am jeweiligen
Polynom $0$ ergibt (@true@) oder nicht (@false@). Der Rückgabewert der Funktion
ist selbstredend ein @bool@ mit der Information, ob das getestete Element @ff@
ein vollständiger Erzeuger dieses Kreisteilungsmoduls ist (@true@) oder nicht
(@false@).

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=912, label=lst:testSubmod]
inline bool testSubmod(struct FFElem *ff, struct FFElem *mipo, 
        struct FFPoly **polys,
        int polysCount, bool *evalToZero, 
        struct FFElem **mats, int *frobPowers,
        int m, int *tmp, 
        struct FFElem *ffTmp, struct FFElem *ffTmp2, struct FFElem *ffTmp3, 
        struct FFElem **matmulCache, bool *matmulCacheCalced,
        int *multTable, int *addTable){
    int i;
    int goodCounter = 0;
    for(i=0;i<polysCount;i++){
        applyFrob(ff,mipo,
                polys[i],
                mats,frobPowers[i], ffTmp,
                m,tmp,ffTmp2,ffTmp3,
                matmulCache,matmulCacheCalced,
                multTable,addTable);
        if( isZero(ffTmp) == evalToZero[i] ){
            goodCounter++;
        }else{
            return false;
        }
    }
    if(goodCounter == polysCount){
        return true;
    }
    return false;
}
\end{ccode}


Ferner bieten wir die Möglichkeit ein Element auf vollständige
Erzeuger-Eigenschaft für mehrere verallgemeinerte Kreisteilungsmoduln zu
testen, wie \autoref{lst:testAllSubmods} zeigt. @decompCount@ ist dabei die
Anzahl der zu testenden verallgemeinerten Kreisteilungsmoduln und das Array
@polysCountPerDecomp@ gibt die Anzahl der Polynome für den jeweiligen
Kreisteilungsmodul an. Das Array @bool *toTestIndicator@ legt fest, welche
Kreisteilungsmodule getestet werden. Der Rückgabewert -- anders als in 
\autoref{lst:testSubmod} -- ist ein @int@, der die Werte $-1$, falls @ff@ kein
vollständiger Erzeuger der getesteten Kreisteilungsmoduln ist, oder $i$, falls
@ff@ gerade vollständiger Erzeuger des $i$-ten getesteten Kreisteilungsmoduls
ist, annimmt. Ferner bricht die Funktion ab, falls @ff@ ein vollständiger
Erzeuger ist, da es klar sein sollte, dass diese Eigenschaft lediglich für
\emph{einen} verallgemeinerten Kreisteilungsmodul zutreffen kann.

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=861, label=lst:testAllSubmods]
inline int testAllSubmods(struct FFElem *ff, struct FFElem *mipo, 
        int decompCount, struct FFPoly **polys,
        int *polysCountPerDecomp, bool *evalToZero, 
        struct FFElem **mats, int *frobPowers, bool *toTestIndicator,
        int m, int *tmp, 
        struct FFElem *ffTmp, struct FFElem *ffTmp2, struct FFElem *ffTmp3,
        struct FFElem **matmulCache, bool *matmulCacheCalced,
        int *multTable, int *addTable){
    if(ff->len == 0) return -1;
    int i,j,k;
    int goodCounter = 0;
    int curDecompPosition = 0;
    for(i=0;i<decompCount;i++){
        if(toTestIndicator != 0 && toTestIndicator[i] == false){
            curDecompPosition += polysCountPerDecomp[i];
            continue;
        }
        goodCounter = 0;
        for(j=0;j<polysCountPerDecomp[i];j++){
            applyFrob(ff,mipo,
                    polys[curDecompPosition+j],
                    mats,frobPowers[curDecompPosition+j], ffTmp,
                    m,tmp,ffTmp2,ffTmp3,
                    matmulCache,matmulCacheCalced,
                    multTable,addTable);
            if( isZero(ffTmp) == evalToZero[curDecompPosition+j] ){
                goodCounter++;
            }else break;
        }
        if(goodCounter == polysCountPerDecomp[i]){
            return i;
        }
        curDecompPosition += polysCountPerDecomp[i];
    }
    return -1;
}
\end{ccode}


\section{Implementierung der gezielten Enumeration}

\subsection{Enumeration eines verallgemeinerten Kreisteilungsmoduls}

Sei $E := \F_{q^m}$ über $F := \F_q$ eine Körpererweiterung endlicher Körper. Die Frage
nach einer Enumeration aller vollständig normaler Elemente dieser Erweiterung
lässt sich nach dem Zerlegungssatz (\thref{satz:zerlegungssatz}) auf die
separate Enumeration von verallgemeinerten Kreisteilungsmoduln zurückführen.
Daher starten wir mit einem verallgemeinerten Kreisteilungsmodul $\C_{k,t}$
über $\F_q$. Sicherlich könnte man alle $q^m$ Elemente von $E$ testen, ob sie
vollständige Erzeuger von $\C_{k,t}$ sind, was jedoch einen unnötig großen
Aufwand darstellen würde. Sei nämlich $u\in E$ ein vollständiger Erzeuger von
$\C_{k,t}$, so erhalten wir alle weiteren Elemente dieses Kreisteilungsmoduls
durch Anwendung von \thref{kor:moduln_ueber_v_g}, was wir hier in passender
Notation noch einmal formulieren möchten.

\begin{lemma}
  \label{lemma:moduln_durch_polys}
  Sei $u\in E$ ein vollständiger Erzeuger von $\C_{k,t}$ über $F$. 
  Dann gilt
  \[ \C_{k,t} \speq= \big\{ f(\sigma)(u):\ f(x) \in F[x]_{<\varphi(k)\,t},\ 
    \ggT(f,\Phi_{k,t}) = 1 \big\} \,,\]
  wobei wiederum $\sigma$ den Frobenius von $F$ und 
  $\varphi$ die Eulersche $\varphi$-Funktion notieren.
\end{lemma}
\begin{proof}
  \thref{kor:moduln_ueber_v_g} mit der Erkenntnis, dass
  $\deg(\Phi_{k,t}) = \varphi(k)\,t$.
\end{proof}

Nun ist klar, wie wir ausgehend von einem Erzeuger alle weiteren generieren
können: Sei $u \in E$ ein vollständiger Erzeuger von $\C_{k,t}$ über $F$, so 
berechnen wir iterativ $v := f(\sigma)(u)$ für alle $f \in F[x]_{<\varphi(k)t}$
mit @applyFrob_noCache@ (\autoref{lst:applyFrob_noCache}) 
und testen anschließend $v$ auf vollständige Erzeuger-Eigenschaft mit 
@testSubmod@ (\autoref{lst:testSubmod}). Auf eine Berechnung von 
$\ggT(f,\Phi_{k,t})$ verzichten wir, da wir @testSubmod@ ohnehin ausführen
müssen und damit durch die Kenntnis des $\ggT$ keinen Vorteil erlangen würden.
Die Generierung der $f$s erfolgt direkt in \autoref{lst:calcSubmoduleElements},
wobei die Elemente aus $F$ wieder mittels eines injektiven Körperhomomorphismus 
$F\to E$ als @FFElem*@-Array namens @elementsF@ übergeben werden.

\begin{bemerkung}
  \marginpar{Müsste man hier ausführlicher argumentieren?}
  Wiederum überzeuge man sich kurz mit der gleichen Argumentation wie in 
  \thref{lemma:einbettung_egal}, dass ein Endomorphismus $E\to E$ lediglich die
  Erzeuger eines verallgemeinerten Kreisteilungsmoduls permutiert.
\end{bemerkung}

Wie erwähnt müssen wir dieses Verfahren natürlich mit einem vollständigen
Erzeuger starten. Es ist sicherzustellen, dass sich dieser am aktuellen Knoten 
der Liste @struct Node *root@ befindet.

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=953, label=lst:calcSubmoduleElements]
inline void calcSubmoduleElements(struct Node *root,
        struct FFElem *mipo,
        int maxLenPoly, 
        int *genCounts, int curGen,
        struct FFPoly **polys, int polysCount, bool *evalToZero,
        struct FFElem **mats, int matLen, int *frobPowers,
        struct FFElem **elementsF,
        int m, int q, int *tmp,
        struct FFElem *ffTmp, struct FFElem *ffTmp2, struct FFElem *ffTmp3, 
        struct FFElem *ffTmp4,
        struct FFElem **matmulCache, bool *matmulCacheCalced,
        int *multTable, int *addTable){
    int i,j;
    struct Node *curRoot = root;
    struct FFElem *ff = root->ff;
    int *curPoly = malloc( maxLenPoly*sizeof(int) );
    struct FFPoly *curFPoly = malloc( sizeof(struct FFPoly) );
    curFPoly->poly = malloc( maxLenPoly*sizeof(struct FFElem*) );
    curFPoly->lenPoly = 0;

    initPoly(curPoly,maxLenPoly);
    curPoly[0] = 2;
    int curLenPoly = 1;
    if( q == 2 && maxLenPoly > 1){
        curLenPoly = 2;
        curPoly[0] = 0;
        curPoly[1] = 1;
    }
    if(q != 2 || maxLenPoly > 1){
        while(true){
            //setup curFPoly
            for(i=0;i<curLenPoly;i++)
                curFPoly->poly[i] = elementsF[curPoly[i]];
            curFPoly->lenPoly = curLenPoly;
            //apply Frobenius
            applyFrob_noCache(ff,mipo,
                    curFPoly,
                    mats,1, ffTmp, //return value
                    m,tmp,ffTmp2,ffTmp3,
                    multTable,addTable);
            //test generated element
            for(i=0;i<matLen;i++) matmulCacheCalced[i] = false;
            if(testSubmod(ffTmp, mipo,
                    polys,polysCount,evalToZero,
                    mats,frobPowers,m,tmp,
                    ffTmp2,ffTmp3,ffTmp4,
                    matmulCache,matmulCacheCalced, multTable,addTable)){
                curRoot = appendToEnd(curRoot,ffTmp,m);
                genCounts[curGen]++;
            }
            //generate next element
            curPoly[0] += 1;
            if( curPoly[0] == q ){
                for(i=0;i<maxLenPoly-1 && curPoly[i]==q;i++){
                    curPoly[i] = 0;
                    curPoly[i+1] += 1;
                }
                if(i+1>curLenPoly)
                    curLenPoly = i+1;
                if( curPoly[maxLenPoly-1]==q){
                    break;
                }
            }
        }
    }
    free(curPoly);
    free(curFPoly->poly);
    free(curFPoly);
}
\end{ccode}

Wie man in obigem Listing erkennt, startet die Erzeugung der Polynome aus 
$F[x]_{\varphi(k)t}$ beim Polynom $2 \in F[x]$ (falls es die Charakteristik
zulässt), da $1\in F[x]$ ja wieder $(1)(\sigma)(u) = \id(u) = u$ liefert.
@maxLenPoly@ gibt dabei die maximale Länge der zu betrachtenden Polynome an (in
hiesiger Notation also @maxLenPoly@$= \varphi(k)t+1$). Die Polynome selbst
werden in zwei Schritten erzeugt: Sei $l := $@maxLenPoly@, so
durchläuft das @int@-Array @curPoly@ alle Elemente aus $\Z_q^l$. 
Das korrekte Polynom in $E[x]$ wird dann durch einsetzen jeder Stelle 
dieses Tupels aus $\Z_q^l$ in die @elementsF@ erzeugt und in 
@curFPoly@ gespeichert.

Die Anzahl der berechneten Erzeuger werden im @int@-Array @genCounts@ an der
Stelle @curGen@ gespeichert und da unsere Suche auf vollständig normale
Elemente abzielt, werden die konkreten Erzeuger durch @appendToEnd@ 
an die verkettete Liste @struct Node *root@ angehängt und 
damit für späteres Zusammensetzen gespeichert.


\subsubsection{Verkettete Listen zum Speichern berechneter vollständiger 
Erzeuger}
\label{subsub:verkettete_listen}

Die verkettete Liste ist dabei wie folgt aufgebaut.

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=175, label=lst:structNode]
struct Node {
    struct FFElem *ff;
    struct Node *next;
};
\end{ccode}

Ebenfalls ist das Anheften eines Elements ans Ende der Liste wie man es
erwartet, wobei zu bemerken gilt, dass der neue Endknoten zurückgegeben wird.
Auf diese Weise muss nicht bei jedem Anheften die komplette Liste durchlaufen
werden. Das Element @struct FFElem *element@ wird dabei kopiert, so dass es
anschließend weiterverwendet werden kann und die Liste unverändert bleibt 
(vgl. Anwendung in \autoref{lst:calcSubmoduleElements}).

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=180, label=lst:appendToEnd]
/**
 * appends element to end of root, where element is copied to new FFElem.
 */
inline struct Node *appendToEnd(struct Node *root, struct FFElem *element,int m){
    struct Node *nextNode = root;
    if( nextNode != 0){
        while(nextNode->next != 0){
            nextNode = nextNode->next;
        }
        if( nextNode->ff != 0){
            nextNode->next = malloc( sizeof(struct Node) );
            nextNode = nextNode->next;
        }
        if( nextNode != 0){
            nextNode->next = 0;
            nextNode->ff = mallocFFElem(m);
            copyFFElem(element,nextNode->ff);
            return nextNode;
        }
    }
    return NULL;
}
\end{ccode}


Wie üblich in \Clang, ist es hilfreich das Freigeben von Speicher in eine 
eigene Funktion zu setzen.

\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=203, label=lst:freeNode]
inline void freeNode(struct Node* head){
    struct Node *next_n = NULL;
    struct Node *tmp_n = NULL;
    for(tmp_n=head; tmp_n !=NULL; ){
        next_n = tmp_n->next;
        freeFFElem(tmp_n->ff);
        free(tmp_n);
        tmp_n = next_n;
    }
    head = 0;
}
\end{ccode}

\subsection{Dynamische Enumeration des größten Kreisteilungsmoduls}
\label{sub:dynamische_enumeration}

Da der Zerlegungssatz (\thref{satz:zerlegungssatz}) nicht immer eine echte
Zerlegung liefert (sich also alle vollständig normalen Elemente auf einen
einzigen Modul konzentrieren) und in vielen Zerlegungen ein verallgemeinerter
Kreisteilungsmodul vorkommt, der verglichen mit den anderen Moduln dieser
Zerlegung, besonders viele Elemente enthält, hat sich die Speicherung
\emph{aller} Erzeuger als schlecht erwiesen. Daher sind wir dazu übergegangen,
den größten Kreisteilungsmodul dynamisch zu enumerieren. Das bedeutet, dass
alle anderen verallgemeinerten Kreisteilungsmoduln vorab durch 
@calcSubmoduleElements@ (\autoref{lst:calcSubmoduleElements}) behandelt werden.
Bei der Enumeration des größten nutzen wir dann diese Informationen und setzen
die gefundenen Erzeuger zu einem vollständig normalen Element zusammen. Dies
können wir dann auf Primitivität durch @isPrimitive@
(\autoref{lst:isPrimitive}) testen und abschließend verwerfen, da es uns ja nur
auf eine Enumeration und nicht auf die konkrete Angabe der vollständig normalen
und primitiven Elemente ankommt.

Die bereits berechneten vollständigen Erzeuger werden durch 
das Array von Listen @struct Node **roots@ übergeben. @decompCount@ gibt dabei
die Anzahl aller (also inklusive des größten) verallgemeinerten
Kreisteilungsmoduln an. Alle anderen Variablen wurden bereits in den vorherigen
Funktionen erklärt, wobei noch bemerkt werden sollte, dass diesmal die
Erzeugung der Polynome bei $1 \in F[x]$ startet, da der bereits gefundene
Erzeuger des größten Kreisteilungsmoduls auch Teil einer gültigen Kombination
zu einem vollständig normalen Element ist. Dieser „Fehler” in der Berechnung
der Anzahl @genCounts@ wird in Zeile \texttt{1156} am Ende der Funktion
korrigiert. Der Erzeuger selbst befindet sich wieder am aktuellen Knoten der
der letzten Liste des Arrays @roots@, da die Datenstrukturen so
aufgebaut werden, dass dieser größte verallgemeinerte Kreisteilungsmodul der
letzte ist (siehe Zeilen \texttt{1062} und \texttt{1064}).


\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=1030, label=lst:processLastSubmodule]
/**
 * Processes last submodule as others before, but does not save generated
 * elements. Cycles through already generated elements and tests for 
 * primitivity:
 *
 * !! all temporary variables are generated inside !!
 */
unsigned long long processLastSubmoduleAndTestPrimitivity(struct Node **roots,
        struct FFElem *mipo, int decompCount,
        int maxLenPoly, 
        int *genCounts, 
        struct FFPoly **polys, int polysCount, bool *evalToZero,
        struct FFElem **mats, int matLen, int *frobPowers,
        struct FFElem **elementsF,
        int m, int q, 
        int *barFactors, int *lenBarFactors, int countBarFactors,
        int *commonBarFactor, int lenCommonBarFactor,
        int *commonBiggestBarFactor, int lenCommonBiggestBarFactor,
        struct FFElem **matCharac,
        struct FFElem **matmulCache, bool *matmulCacheCalced,
        int *multTable, int *addTable){
    //generate temporary variables
    struct FFElem *fff = mallocFFElem(m);
    struct FFElem *ffff = mallocFFElem(m);
    struct FFElem *ffTmp = mallocFFElem(m);
    struct FFElem *ffTmp2 = mallocFFElem(m);
    struct FFElem *ffTmp3 = mallocFFElem(m);
    struct FFElem *ffTmp4 = mallocFFElem(m);
    struct FFElem *ffTmp5 = mallocFFElem(m);
    int *tmp = malloc(m*sizeof(int));

    int i,j;
    int curGen = decompCount-1;
    struct Node **curRoots = malloc( decompCount*sizeof(struct Node*) );
    struct FFElem *ff = roots[curGen]->ff;
    int *curPoly = malloc( maxLenPoly*sizeof(int) );
    struct FFPoly *curFPoly = malloc( sizeof(struct FFPoly) );
    curFPoly->poly = malloc( maxLenPoly*sizeof(struct FFElem*) );
    curFPoly->lenPoly = 0;
    
    initPoly(curPoly,maxLenPoly);
    curPoly[0] = 1;
    int curLenPoly = 1;

    unsigned long long pcn = 0;
    while(true){
        //setup curFPoly
        for(i=0;i<curLenPoly;i++)
            curFPoly->poly[i] = elementsF[curPoly[i]];
        curFPoly->lenPoly = curLenPoly;
        //apply Frobenius
        applyFrob_noCache(ff,mipo,
                curFPoly,
                mats,1, fff, //return value
                m,tmp,ffTmp,ffTmp2,
                multTable,addTable);
        //test generated element
        for(i=0;i<matLen;i++) matmulCacheCalced[i] = false;
        if(testSubmod(fff, mipo,
                polys,polysCount,evalToZero,
                mats,frobPowers,m,tmp,
                ffTmp,ffTmp2,ffTmp3,
                matmulCache,matmulCacheCalced, multTable,addTable)){
            genCounts[curGen]++;
            // build element as sum of already calced Nodes and ffTmp
            for(i=0;i<decompCount;i++) curRoots[i] = roots[i];
            // cycle through Nodes, build element and test primitivity
            while(true){
                copyFFElem(fff,ffff);
                //build element
                for(i=0;i<decompCount-1;i++){
                    addFFElem(ffff, curRoots[i]->ff, ffff, tmp,
                            multTable,addTable);
                }
                //test primitivity
                if(countBarFactors > 0){
                    if(isPrimitive(ffff, mipo,m,
                                barFactors,lenBarFactors,countBarFactors,
                                commonBarFactor,lenCommonBarFactor,
                                commonBiggestBarFactor,lenCommonBiggestBarFactor,
                                matCharac,
                                ffTmp,ffTmp2,ffTmp3,ffTmp4,ffTmp5,
                                tmp,multTable,addTable)){
                        pcn++;
                    }
                }

                //next element
                curRoots[0] = curRoots[0]->next;
                if( curRoots[0] == 0 ){
                   for(i=0;i<decompCount-1 && curRoots[i]==0;i++){
                       curRoots[i] = roots[i];
                       curRoots[i+1] = curRoots[i+1]->next;
                   }
                }
                if( curRoots[decompCount-1] == 0){
                   break;
                }
            }
        }
        //generate next element
        curPoly[0] += 1;
        if( curPoly[0] == q ){
            for(i=0;i<maxLenPoly-1 && curPoly[i]==q;i++){
                curPoly[i] = 0;
                curPoly[i+1] += 1;
            }
            if(i+1>curLenPoly)
                curLenPoly = i+1;
            if( curPoly[maxLenPoly-1]==q){
                break;
            }
        }
    }
    free(curPoly);
    free(curFPoly->poly);
    free(curFPoly);
    freeFFElem(fff);
    freeFFElem(ffff);
    freeFFElem(ffTmp);
    freeFFElem(ffTmp2);
    freeFFElem(ffTmp3);
    freeFFElem(ffTmp4);
    freeFFElem(ffTmp5);

    //we added first element twice
    genCounts[curGen]--;
    return pcn;
}
\end{ccode}


\begin{bemerkung}
  \label{bem:kein_test_auf_primitivitaet}
  Wie Zeile \texttt{1105} zu erkennen gibt, kann man durch das Setzen von
  @countBarFactors = 0@ den Test auf Primitivität überspringen. Dies ist
  sinnvoll, wenn man nur an der Anzahl der vollständig normalen Elemente
  interessiert ist.
\end{bemerkung}


\subsubsection{Vorbereiten der Enumeration auf Auffinden vollständiger
  Erzeuger}

Alle bisher betrachteten Verfahren basierten immer auf der Annahme, dass
bereits ein vollständiger Erzeuger eines Kreisteilungsmoduls bereits gefunden
ist. Es ist klar, dass man diese irgendwann suchen muss, was die Funktion
@processFiniteField@ bewerkstelligt. Gleichzeitig bildet sie den Wrapper, der
von \sage aufgerufen wird und als Rückgabewert @unsigned long long@ die Anzahl
der primitiven vollständig normalen Elemente trägt. Alle zu übergebenen
Parameter werden in \sage erzeugt und wurden bereits erklärt.


\begin{ccode}[caption={Aus \url{../Sage/enumeratePCNs.c}},
  firstnumber=1173, label=lst:processFiniteField]
unsigned long long processFiniteField(struct FFElem *mipo, int decompCount,
        struct FFPoly **polys, int *polysCountPerDecomp,
        bool *evalToZero, 
        struct FFElem **mats, int matLen, int *frobPowers,
        int *genCounts, int m, int charac, int q,
        int *barFactors, int *lenBarFactors, int countBarFactors,
        int *commonBarFactor, int lenCommonBarFactor,
        int *commonBiggestBarFactor, int lenCommonBiggestBarFactor,
        struct FFElem **matCharac, struct FFElem **elementsF,
        int *multTable, int *addTable){
    time_t TIME = time(NULL);
    int i,j;

    //setup temporary variables ----------------------------------------------
    int *tmp = malloc(m*sizeof(int));
    struct FFElem *ff = mallocFFElem(m);
    initPoly(ff->el,m);
    struct FFElem *ffRet = mallocFFElem(m);
    struct FFElem *ffTmp = mallocFFElem(m);
    struct FFElem *ffTmp2 = mallocFFElem(m);
    struct FFElem *ffTmp3 = mallocFFElem(m);
    struct FFElem *ffTmp4 = mallocFFElem(m);
    
    struct FFElem **matmulCache = malloc(matLen*sizeof(struct FFElem));
    for(i=0;i<matLen;i++) matmulCache[i] = mallocFFElem(m);
    bool *matmulCacheCalced = malloc(matLen*sizeof(bool));
    
    bool *toTestIndicator = malloc(decompCount*sizeof(bool));
    struct Node **roots = malloc( decompCount*sizeof(struct Node) );
    struct Node **curRoots = malloc(decompCount*sizeof(struct Node*));
    for(i=0;i<decompCount;i++){
        roots[i] = malloc( sizeof(struct Node) );
        roots[i]->ff = 0;
        roots[i]->next = 0;
        curRoots[i] = roots[i];
        toTestIndicator[i] = true;
    }
    //------------------------------------------------------------------------
    
    int foundCounter = 0;
    initPoly(genCounts,decompCount);

    // chase for elements ----------------------------------------------------
    while(true){
        for(i=0;i<matLen;i++) matmulCacheCalced[i] = 0;
        int curGen = testAllSubmods(ff,mipo,decompCount,
                polys,polysCountPerDecomp,evalToZero,
                mats,frobPowers,toTestIndicator,
                m,tmp,ffTmp,ffTmp2,ffTmp3,
                matmulCache,matmulCacheCalced,
                multTable,addTable);
        if( curGen != -1 ){
            if(toTestIndicator[curGen] == true){
                genCounts[curGen]++;
                appendToEnd(roots[curGen], ff, m);
                foundCounter++;
                toTestIndicator[curGen] = false;
            }
            if(foundCounter == decompCount) break;
        }
        //generate next element
        // (for sure there is a more efficient method)
        ff->el[0] += 1;
        if( ff->el[0] == charac ){
            for(i=0; i<m-1 && ff->el[i]==charac; i++){
                ff->el[i] = 0;
                ff->el[i+1] += 1;
            }
            if( ff->el[m-1] == charac )
                break;
        }
        updateFFElem(ff,m);
    }
    if( foundCounter != decompCount ){
        printf("BAAAD ERROR!!! foundCounter=%i < decompCount=%i\n",
                foundCounter,decompCount);
        exit(0);
    }
    printf("finding time: %.2f\n", (double)(time(NULL)-TIME));
    //------------------------------------------------------------------------
    


    // Process found elements ------------------------------------------------
    int curDecompPosition = 0;
    for(i=0;i<decompCount-1;i++){
        calcSubmoduleElements(roots[i], mipo,
                polys[curDecompPosition]->lenPoly-1, // *** == maxLenPoly
                genCounts,i, // *** i == curGen
                polys+curDecompPosition, polysCountPerDecomp[i],
                evalToZero+curDecompPosition,
                mats, matLen, frobPowers+curDecompPosition,
                elementsF,
                m,q,tmp,
                ffTmp,ffTmp2,ffTmp3,ffTmp4,
                matmulCache,matmulCacheCalced,
                multTable,addTable);
        curDecompPosition += polysCountPerDecomp[i];
    }
    printf("all not last time: %.2f\n", (double)(time(NULL)-TIME));
    //------------------------------------------------------------------------
    
    // Process last Decomposition --------------------------------------------
    int curGen = decompCount-1;
    unsigned long long pcn = 
        processLastSubmoduleAndTestPrimitivity(roots,mipo,decompCount,
            polys[curDecompPosition]->lenPoly-1, // *** == maxLenPoly
            genCounts,
            polys+curDecompPosition,polysCountPerDecomp[curGen],
            evalToZero+curDecompPosition,
            mats,matLen,frobPowers+curDecompPosition,
            elementsF,
            m,q,
            barFactors,lenBarFactors,countBarFactors,
            commonBarFactor,lenCommonBarFactor,
            commonBiggestBarFactor,lenCommonBiggestBarFactor,
            matCharac,
            matmulCache,matmulCacheCalced,
            multTable,addTable);
    //------------------------------------------------------------------------

    //free variables
    for(i=0;i<decompCount;i++)
        freeNode(roots[i]);
    free(roots); free(curRoots);

    //free temporary variables
    free(tmp);
    freeFFElem(ff);
    freeFFElem(ffRet);
    freeFFElem(ffTmp);
    freeFFElem(ffTmp2);
    freeFFElem(ffTmp3);
    freeFFElem(ffTmp4);
    for(i=0;i<matLen;i++) freeFFElem(matmulCache[i]);
    free(matmulCache);
    free(matmulCacheCalced);
    free(toTestIndicator);

    
    printf("total time: %.2f\n", (double)(time(NULL)-TIME));
    return pcn;
}
\end{ccode}

Wie zu erkennen ist, erfolgt die Suche nach vollständigen Erzeugern zunächst
durch iterative Enumeration aller Elemente. Wurde ein vollständiger Erzeuger
gefunden, so wird die jeweilige Stelle des @toTestIndicator@s umgeschaltet,
wodurch der zugehörige verallgemeinerte Kreisteilungsmodul in 
@testAllSubmods@ nicht mehr berücksichtigt wird. Ist für jeden
Kreisteilungsmodul ein vollständiger Erzeuger gefunden werden wie oben
beschrieben durch @calcSubmoduleElements@ (\autoref{lst:calcSubmoduleElements})
alle, bis auf den letzten, verarbeitet. Dieser wird abschließend separat in
\autoref{lst:processLastSubmodule}
betrachtet und liefert die Anzahl der primitiven vollständig normalen Elemente.


\subsection{Top-Level-Implementierung in \sage}

Eingangs wurde zwar erwähnt, dass \sage nicht ausreichend performant ist, um
die hier angestrebten Ziele zu erreichen, doch wollen wir nicht gänzlich auf
die hochsprachlichen Funktionen dieses Computeralgebrasystems verzichten.
Insbesondere eignet sich \sage hier, die Daten für
@processFiniteField@ (\autoref{lst:processFiniteField}) bereitzustellen.

\subsubsection{Anwendung des Zerlegungssatzes}
Es ist klar, dass am Anfang der Berechnung von primitiv vollständig normalen
Elementen einer Erweiterung endlicher Körper stets die Anwendung des
Zerlegungssatzes (\thref{satz:zerlegungssatz}) steht.


\begin{sagecode}[caption={Aus \url{../Sage/enumeratePCNs.spyx}},
  firstnumber=544, label=lst:decompose]
# Application of the Decomposition Theorem (Section 19)
# for x^n-1 over F_p^e
def decompose(p,e, n):
    pi = largestDiv(p,n)
    return decompose_cycl_module(p,e, 1, n/pi, pi)
\end{sagecode}


\begin{sagecode}[caption={Aus \url{../Sage/enumeratePCNs.spyx}},
  firstnumber=571, label=lst:decompose_cycl_module]
# internal application of the Decomposition Theorem
# for Phi_k(x^(t*pi)) over F_p^e
def decompose_cycl_module(p,e, k,t,pi):
    if p.divides(k*t): print "ERROR p | kt"
    #test all prime divisors, start with largest one
    flag = False
    for r,l in reversed(factor(t)):
        if not (r**l).divides(ordn(squarefree(k*t),p**e)):
            R = largestDiv(r,t)
            return decompose_cycl_module(p,e, k, t/r, pi) \
                    + decompose_cycl_module(p,e, k*R, t/R, pi)
    return [(k,t,pi)]
\end{sagecode}

\begin{beispiel}
  Wollen wir einmal den Zerlegungssatz auf $E := \F_{3^{20}}$ über 
  $F := \F_3$ anwenden, so rufen wir "decompose(3,1,20)" auf und 
  erhalten
  \begin{center}
    "[(1, 1, 1), (2, 1, 1), (4, 1, 1), (5, 4, 1)]".
  \end{center}
  Umformuliert bedeutet das, dass
  \[ x^{20} - 1 \speq= \Phi_1(x)\ \Phi_2(x)\ \Phi_4(x)\ \Phi_5(x^4)\quad
    \in \F_3[x]\,,\]
  eine verträgliche Zerlegung ist. 
  Oder in Termen der erweiterten Kreisteilungsmoduln ist 
  \[ \C_{1,20} \speq= \C_{1,1} \oplus \C_{2,1} \oplus
    \C_{4,1} \oplus \C_{5,4}\]
  eine verträgliche Zerlegung über $\F_3$.
\end{beispiel}

Die benutzten Funktionen "largestDiv", "ordn" und "squarefree" sind dabei 
wie folgt gegeben.

\begin{sagecode}[caption={Aus \url{../Sage/enumeratePCNs.spyx}},
  firstnumber=586]
# returns the largest power of p dividing n
def largestDiv(p,n):
    l = 0
    while (p**l).divides(n):
        l = l+1
    return p**(l-1);
\end{sagecode}


\begin{sagecode}[caption={Aus \url{../Sage/enumeratePCNs.spyx}},
  firstnumber=538]
# computes ordn m(q) = min{ k: q ** k = 1 mod m }
def ordn(m,q):
    if m == 1: return 1
    for i in range(1,m+1):
        if (q ** i)%m == 1: return i;
\end{sagecode}  

\begin{sagecode}[caption={Aus \url{../Sage/enumeratePCNs.spyx}},
  firstnumber=534]
# computes the quadratic free part of an integer
def squarefree(n):
    return prod(map(lambda x: x[0], factor(Integer(n))))
\end{sagecode}  


\subsubsection{Ausnutzen einfacher Zerlegungen}

Zunächst müsste man für jeden erweiterten Kreisteilungsmodul
nun \emph{alle} Teiler des Modulcharakters testen, um vollständige Erzeuger zu
finden. Jedoch garantiert \thref{satz:einfache_erweiterungen}, dass dies in
manchen Fällen überflüssig ist, da bei einer einfachen Erweiterung ein Erzeuger
eines Kreisteilungsmoduls $\C_{k,t}$ über $\F_q$ bereits ein vollständiger
Erzeuger ist. Ist eine Erweiterung nicht einfach, so sollte man die Hoffnung
nach einer Vereinfachung der Suche nach vollständigen Erzeugern nicht aufgeben,
sondern sich überlegen, dass es einen Teiler $d \mid n$ geben kann, für den
die Erweiterung $\F_{q^n}$ über $\F_{q^d}$ einfach ist. Dann müssten keine
Teiler von Modulcharaktern getestet werden, die größer oder gleich $d$ wären, 
da -- wie man sich sehr leicht überlegt -- falls $\F_{q^n}$ über $\F_q$ einfach
ist, auch für alle Teiler $d\mid n$ $\F_{q^n}$ über $\F_{q^d}$ einfach ist.

Dies wollen wir nutzen in nachstehender Funktion, die
gerade zu betrachtenden Teiler einer Erweiterung liefert 
(und deren Benennung vielleicht etwas kontraintuitiv gewählt wurde).

\begin{sagecode}[caption={Aus \url{../Sage/enumeratePCNs.spyx}},
  firstnumber=594, label=lst:get_completely_basic_divisors]
# returns the NOT completely basic divisors of an 
# extension n over GF(p^e)
def get_completely_basic_divisors(p,e,n):
    n = Integer(n)
    q = Integer(p**e)
    divs = []
    for d in divisors(n):
        isComplBasic = True
        for r in prime_divisors(n/d):
            if r.divides(ordn(p_free_part(n/d/r,p),q**d)):
                isComplBasic = False
                break
        divs += [d]
        if isComplBasic: return divs
    return divs
\end{sagecode}

"p_free_part" gibt wie in \thref{satz:einfache_erweiterungen} (3) zu sehen ist,
gerade den größten Teiler des ersten Arguments an, der nicht mehr durch $p$,
dem zweiten Argument, teilbar ist. Es wird dabei nicht überprüft, ob das zweite
Argument eine Primzahl ist.


\begin{sagecode}[caption={Aus \url{../Sage/enumeratePCNs.spyx}},
  firstnumber=612]
# p-free part of t
def p_free_part(t,p):
    while p.divides(t):
        t /= p
    return t
\end{sagecode}




\subsubsection{Ausnutzen regulärer Kreisteilungsmoduln}

Sicherlich wollen wir auch Regularität (\thref{def:regulaer}) nicht unbeachtet
lassen, um uns die Suche nach vollständig normalen Elementen zu erleichtern.
Also haben wir auch einen Test auf Regularität nach \sage übersetzt.

\begin{sagecode}[caption={Aus \url{../Sage/enumeratePCNs.spyx}},
  firstnumber=431]
# tests if cyclotomic module C_k,t is regular over F_p^e
def isRegular(p,e, k,t,pi):
    return gcd( ordn( squarefree(k*p_free_part(t,p)), p**e ),  k*t*pi) == 1
\end{sagecode}

Ist ein Kreisteilungsmodul regulär, so ist ein Test auf vollständige
Erzeuger-Eigenschaft durch \thref{satz:regulare_erweiterungen} gegeben.
Da Regularität lediglich die Anzahl der Teiler des Erweiterungsgrades, deren
zugehörige Kreisteilungsmoduln auf vollständige Erzeuger getestet werden
müssen, reduziert, wird \thref{satz:regulare_erweiterungen} durch Rückgabe der
Teiler $\tau$ bzw. $\tau$ und $2\tau$ (in Notation dieses Satzes)
im ausfallenden Fall realisiert, wie die Funktion 
"get_tau_divisors" zeigt. Die zu übergebenden Parameter bestehen wieder aus 
$q = p^e$ und der Daten $(k,t,\pi)$ des zu betrachtenden Kreisteilungsmoduls 
$\C_{k,\,tpi}$ über $\F_q$.

\begin{sagecode}[caption={Aus \url{../Sage/enumeratePCNs.spyx}},
  firstnumber=436]
# returns tau-divisors for complete generator test of 
# the cyclotomic module C_k,t*pi over F_p^e
def get_tau_divisors(p,e, k,t,pi):
    if t != 1:
        print "ERROR get_tau_divisors: t != 1 for p=",p," e=",e\
                ," k=",k," t=",t," pi=",pi
        raise Exception("Error t!=1")
    q = p**e
    tau = ordn(k,q) / ordn(squarefree(k),q)
    tau = prod(map(lambda ra: ra[0]**floor(ra[1]/2), factor(tau)))
    if isExceptional(p,e, k):
        return [ tau, 2*tau ]
    else:
        return [ tau ]
\end{sagecode}

Wie in $\thref{satz:regular_dann_kanonische_zerlegnug}$ gezeigt, ist die
kanonische Zerlegung im regulären Fall verträglich. Daher tritt ein Fehler auf,
wird obiger Funktion ein Kreisteilungsmodul $\C_{l,m}$ übergeben mit 
$m \neq p^b$ für ein $b\geq 0$.

Es bleibt natürlich noch ein Test anzugeben, der überprüft, ob 
die Parameter $(p,e,k)$ ausfallend sind (vgl. \thref{def:ausfallend}).

\begin{sagecode}[caption={Aus \url{../Sage/enumeratePCNs.spyx}},
  firstnumber=452]
# tests if n is exceptional over F_p^e
def isExceptional(p,e, n):
    q = p**e
    c = 0
    nbar = n
    while Integer(2).divides(nbar):
        c += 1
        nbar /= 2
    if (q).mod(4) == 3  and c >= 3  and ordn(q, 2**c) == 2:
        return True
    return False
\end{sagecode}  


\subsubsection{Die zentrale \sage-Funktion 
  \texttt{countCompleteSubmoduleGenerators}}

Als übergeordnete Funktion, die die Anzahl aller (primitiven) vollständig
normale Elemente und aller vollständigen Erzeuger im Sinne des Zerlegungssatzes
liefert, stellen wir "countCompleteSubmoduleGenerators" bereit. Als Argumente
sind selbstredend ein endlicher Körper zu übergeben und der Grad der zu
betrachtenden Erweiterung. Ferner gibt es die Möglichkeit durch das optionale
Argument "binaryPowers=False" den Test auf Primitivität durch $p$-adische
Exponentiation durchführen zu lassen wie in dem Absatz vor 
\autoref{lst:isPrimitive} erwähnt wurde (vgl. auch 
\autoref{subsub:primitivitaetstest}). Der Test auf Primitivität lässt sich auch
vollständig deaktivieren durch die Übergabe von "testPrimitivity=False"
(vgl. \thref{bem:kein_test_auf_primitivitaet}).

Der Rückgabewert der Funktion enthält die Anzahl aller vollsändig normalen
Elemente der Erweiterung, die Anzahl aller primitiv vollständig normalen (oder
$0$, falls der Test auf Primitivität deaktiviert wurde), 
die Anzahl der jeweiligen vollständigen Erzeuger der Zerlegung in
verallgemeinerte Kreisteilungsmodule nach \thref{satz:zerlegungssatz} und
abschließend die Dauer der Berechnung.

Im Gegensatz zu den bisherigen Listings werden wir
"countCompleteSubmoduleGenerators" in mehrere Teile aufspalten, um ein besseres
Verständnis zu gewährleisten. Wir beginnen mit den ersten Zeilen, die in
offensichtlicher Weise die Datenstrukturen der Zerlegung bereitstellen, wie sie
in @testAllSubmods@ (\autoref{lst:testAllSubmods}) bzw. @testSubmod@ 
(\autoref{lst:testSubmod}) benötigt werden.


\begin{sagecode}[caption={Aus \url{../Sage/enumeratePCNs.spyx}},
  firstnumber=88]
def countCompleteSubmoduleGenerators(F,n, binaryPowers=True, \
        testPrimitivity=True):
    TIME = time.time()
    p = F.characteristic()
    q = F.order();
    e = q.log(p)
    E = F.extension(Integer(n),'a');
    P = E.prime_subfield()
    #generate factors
    polys = []
    polysCount = []
    evalToZero = []
    frobPowers = []
    notComplBasicDivisors = get_completely_basic_divisors(p,e,n)
    decomposition = decompose(p,e,n)
    for decomp in decomposition:
        k,t,pi = decomp
        divs = divisors(get_module_character(*decomp))
        divs = filter(lambda x: x in notComplBasicDivisors, divs)
        countPolysForThisDecomp = 0
        for d in divs:
            G = F.extension(Integer(d), 'c');
            Gx = PolynomialRing(G,'x'); 
            h = Hom(G,E)[0]
            cycl = Gx.cyclotomic_polynomial(squarefree(k))\
                    (Gx.gen()**(k*t*pi/squarefree(k)/d))
            polys += [map(lambda x: x.polynomial().list(),
                cycl.map_coefficients(h).list())]
            frobPowers += [d]
            evalToZero += [1]
            countPolysForThisDecomp += 1
            # add Co-Factors
            for f,mult in cycl.factor():
                g = cycl.quo_rem(f)[0]
                gE = g.map_coefficients(h)
                polys += [map(lambda x: x.polynomial().list(), gE.list())]
                frobPowers += [d]
                evalToZero += [0]
                countPolysForThisDecomp +=1
        polysCount += [countPolysForThisDecomp]
\end{sagecode}

Wie man gut erkennen kann, werden einfache Zerlegungen in den Zeilen
\texttt{101} und \texttt{106} ausgenutzt.

Anschließend berechnen wir, falls "testPrimitivity=True",
die Kofaktoren, wie sie beim Test auf Primitivität
in @isPrimitive@ (\autoref{lst:isPrimitive}) verwendet werden. Dabei ist zu
unterscheiden, ob die Faktoren in binärer (ab Zeile \texttt{151})
oder $p$-adischer Form (ab Zeile \texttt{156}) genutzt werden
sollen. Bei $p$-adischer Darstellung muss, wie in dem Absatz vor 
@powerFFElem@ (\autoref{lst:powerffelem}) erwähnt, die Länge des maximal
auftretenden $0$-Intervalls berechnet werden (ab Zeile \texttt{164}).

\begin{sagecode}[caption={\texttt{countCompleteSubmoduleGenerators}
  Fortsetzung (I)}, 
  firstnumber=128]
    charac = int(E.characteristic())
        #mipo
    mipo = E.modulus().list()
    m = len(mipo)-1

    #calc prime factors of order
    barFactors = []
    primitiveOrder = E.order()-1
    if testPrimitivity:
        factors = reversed(factor(primitiveOrder))
        for r,k in factors:
            barFactors += [primitiveOrder/r]
        countBarFactors = len(barFactors)
        commonBarFactor = gcd(barFactors)
        commonBiggestBarFactor = max(gcd(barFactors[1:]) / commonBarFactor,1)
        barFactors = map(lambda b: b/commonBarFactor, barFactors)
        curF = 0
        barFactors_tmp = [barFactors[0]]
        for b in barFactors[1:]:
            barFactors_tmp += [ b/commonBiggestBarFactor - curF]
            curF = b/commonBiggestBarFactor
        barFactors = barFactors_tmp
        
        if binaryPowers:
            barFactors = map(lambda b: get_padic_representation(b,2),barFactors)
            commonBarFactor = get_padic_representation(commonBarFactor,2)
            commonBiggestBarFactor = \
                    get_padic_representation(commonBiggestBarFactor,2)
        else:
            barFactors = map(lambda b: get_padic_representation(b,p),barFactors)
            commonBarFactor = get_padic_representation(commonBarFactor,p)
            commonBiggestBarFactor = \
                    get_padic_representation(commonBiggestBarFactor,p)
        lenCommonBarFactor = len(commonBarFactor)
        lenCommonBiggestBarFactor = len(commonBiggestBarFactor)

        lenBiggestZeroGap = 0
        if not binaryPowers:
            #find biggest gap (i.e. zero-interval)
            lenCurGap = 0
            for b in barFactors+[commonBarFactor]+[commonBiggestBarFactor]:
                i = 0
                while i < len(b):
                    lenCurGap = 0
                    while i<len(b) and b[i] == 0:
                        lenCurGap+= 1
                        i += 1
                    lenBiggestZeroGap = max(lenBiggestZeroGap, lenCurGap)
                    i += 1
    else:
        countBarFactors = 0
        barFactors = []
        commonBarFactor = []
        commonBiggestBarFactor = []
        lenBiggestZeroGap = 0
\end{sagecode}


Im letzten Teil der reinen \sage-Aufbereitung, liften wir die Elemente des
Grundkörpers mittels eines injektiven Körperhomomorphismus in den
Erweiterungskörper, wie sie in @calcSubmoduleElements@
(\autoref{lst:calcSubmoduleElements}) bzw.
@processLastSubmoduleAndTestPrimitivity@
(\autoref{lst:processLastSubmodule}) benötigt werden. Ferner stellen wir die 
Additions- und Multiplikationstabellen nach 
\autoref{sub:arithmetik_in_endlichen_körpern} auf.

\begin{sagecode}[caption={\texttt{countCompleteSubmoduleGenerators}
  Fortsetzung (II)}, 
  firstnumber=183]
        #generate F elements in E
    elementsF = []
    if e == 1:
        elementsF = map(lambda e: [e], list(F))
    else:
        h = Hom(F,E)[0]
        for e in itertools.product(xrange(p),repeat=e):
            elementsF += [h( F(list(reversed(e))) ).polynomial().list()]

        #calculate addition and multiplication tables
    ps = range(p)
    addTable = ps[P(-2*(p-1)):] + ps*2 + ps[:Integer(P(2*(p-1)))+1]
    multTable = ps[P(-(p-1)**2):] + ps*(2*(p-2)) + ps[:Integer(P((p-1)**2))+1]
\end{sagecode}  


Nun sind wir bereit alle Daten nach \Clang zu transferieren. Dies ist ein
notwendiges Übel, da die interne Repräsentation von \sage-Objekten nicht mit
denen in \Clang vereinbar sind. Beispielsweise sind Listen von Ganzzahlen
keineswegs Arrays, jedoch existiert gerade für diesen Fall die Möglichkeit 
die komfortable Syntax von \texttt{numpy}-Arrays zu nutzen, die direkt auf 
\Clang-Arrays basieren.\footnote{Siehe z.B.
\url{http://www.sagemath.org/doc/numerical_sage/numpy.html} für die Benutzung
von \texttt{numpy}-Arrays in \sage.}

Andere Datenstrukturen, wie die selbst erstellten @struct FFElem@s, müssen
händisch übersetzt werden. Da \cython das (etwas merkwürdig wirkende) Mischen
von \python und \Clang erlaubt, schieben wir die hierfür erstellten Funktionen
der Übersetzung von \python-Listen in die jeweilige \Clang-Datenstruktur kurz
ein.

\begin{sagecode}[caption={Aus \url{../Sage/enumeratePCNs.spyx}},
  firstnumber=55]
cdef FFElem *pyList2FFElem(element,int m):
    cdef FFElem *ff = mallocFFElem(<int>m)
    initPoly(ff.el,m)
    for i,e in enumerate(element):
        ff.el[i] = e
    updateFFElem(ff,m)
    return ff
\end{sagecode}  

\begin{sagecode}[caption={Aus \url{../Sage/enumeratePCNs.spyx}},
  firstnumber=63]
cdef FFElem **pyList2PointFFElem(pyList, int m):
    lenList = len(pyList)
    cdef FFElem **ffs = <FFElem**>malloc(lenList*sizeof(FFElem*))
    for i,e in enumerate(pyList):
        ffs[i] = pyList2FFElem(e,m)
    return ffs
\end{sagecode}

\begin{sagecode}[caption={Aus \url{../Sage/enumeratePCNs.spyx}},
  firstnumber=70]
cdef FFPoly *pyList2FFPoly(listPoly, int m):
    lenPoly = len(listPoly)
    cdef FFPoly *poly = <FFPoly*>malloc(sizeof(FFPoly))
    poly.poly = <FFElem**>malloc(lenPoly*sizeof(FFElem*))
    poly.lenPoly = lenPoly
    for i,e in enumerate(listPoly):
        poly.poly[i] = pyList2FFElem(e,m)
    return poly
\end{sagecode}

\begin{sagecode}[caption={Aus \url{../Sage/enumeratePCNs.spyx}},
  firstnumber=79]
cdef FFPoly **pyList2PointFFPoly(listPolys, int m):
    countPolys = len(listPolys)
    cdef FFPoly **polys = <FFPoly**>malloc(countPolys*sizeof(FFPoly*))
    for i,e in enumerate(listPolys):
        polys[i] = pyList2FFPoly(e,m)
    return polys
\end{sagecode}


Nun können wir die Beschreibung von "countCompleteSubmoduleGenerators"
fortsetzen und erkennen sofort die gerade vorgestellten Funktionen der
Übersetznug sowie die Benutzung der \texttt{numpy}-Arrays.

\begin{sagecode}[caption={\texttt{countCompleteSubmoduleGenerators}
  Fortsetzung (III)}, 
  firstnumber=196]
    # SETUP C DATA ===========================================================
    maxMatPower = max(map(lambda d: euler_phi(d[0])*d[1]*d[2], decomposition))
        # multiplication and addition table
    cdef np.ndarray[int,ndim=1,mode="c"] multTableRawC\
        = np.array(multTable, dtype=np.int32)
    cdef np.ndarray[int,ndim=1,mode="c"] addTableRawC\
        = np.array(addTable, dtype=np.int32)
    cdef int* multTableC = <int*>multTableRawC.data + <int>((p-1)**2)
    cdef int* addTableC = <int*>addTableRawC.data + <int>(2*(p-1))
        #setup mipo
    cdef FFElem *mipoC = pyList2FFElem(mipo,m+1)
       #setup matrices
    cdef FFElem **matsC  = genFrobMats(mipoC,m,maxMatPower,q,
            multTableC, addTableC)
        # mat charac
    cdef FFElem **matCharacC
    if binaryPowers:
        matCharacC = <FFElem**>0
    else:
        matCharacC = genFrobMats(mipoC,m,lenBiggestZeroGap+1,
                p, multTableC, addTableC)
    #setup polynomials, polyLength, frobPowers, evaltoZero
    decompCount = int(len(polysCount))
        #evalToZeroC
    cdef np.ndarray[char,ndim=1,mode="c",cast=True] evalToZeroC\
            = np.array(evalToZero, dtype=np.uint8)
        #frobPowersC
    cdef np.ndarray[int,ndim=1,mode="c"] frobPowersC\
            = np.array(frobPowers, dtype=np.int32)
        #polysCountC
    cdef np.ndarray[int,ndim=1,mode="c"] polysCountC\
            = np.array(polysCount, dtype=np.int32)
    cdef FFPoly **polysC = pyList2PointFFPoly(polys,m)
        # bar Factors
    cdef np.ndarray[int,ndim=1,mode="c"] barFactorsC \
        = np.array(list(itertools.chain(*barFactors)), dtype=np.int32)
    cdef np.ndarray[int,ndim=1,mode="c"] lenBarFactorsC \
        = np.array(map(len,barFactors), dtype=np.int32)
    cdef np.ndarray[int,ndim=1,mode="c"] commonBarFactorC \
        = np.array(commonBarFactor, dtype=np.int32)
    cdef np.ndarray[int,ndim=1,mode="c"] commonBiggestBarFactorC \
        = np.array(commonBiggestBarFactor, dtype=np.int32)
        # F elements in E
    cdef FFElem **elementsFC = pyList2PointFFElem(elementsF,m)
    #=========================================================================
\end{sagecode}

Es gilt anzumerken, dass die Erzeugung der Darstellungsmatrizen des Frobenius
in \Clang durch die Funktion @genFrobMats@ 
(die in \url{../Sage/enumeratePCNs.c} zu finden ist und hier nicht näher
erläutert wird, da sie weder vom mathematischen Standpunkt her besonders
spannend ist, noch besonderes programmiertechnisch besondere Aufmerksamkeit
verdient)
geschieht, wobei die maximal zu berechnende
Matrixpotenz gerade durch den Grad des größten auftretenden Polynoms der
Zerlegung gegeben ist. Wir wissen jedoch genau, wie der Grad eines
verallgemeinerten Kreisteilungspolynoms zu berechnen ist, wie Zeile
\texttt{197} erkennen lässt.

In einem letzten Schritt können wir (nun endlich) die bereitgestellte
\Clang-Funktion @processFiniteField@ (\autoref{lst:processFiniteField}) 
aufrufen und die Rückgabewerte verwalten. Hier gilt es anzumerken, dass die
Anzahl der vollständigen Erzeuger direkt in das Array @genCountsC@ geschrieben
wird und nicht als expliziter Rückgabewert erkennbar ist.


\begin{sagecode}[caption={\texttt{countCompleteSubmoduleGenerators}
  Fortsetzung (IV)}, 
  firstnumber=241]
    #setup return values
    cdef np.ndarray[int,ndim=1,mode="c"] genCountsC
    genCountsC = np.zeros(decompCount, dtype=np.int32)

    cdef unsigned long long pcn = \
            processFiniteField(mipoC, decompCount,
                    polysC,<int*>polysCountC.data,
                    <char*>evalToZeroC.data,
                    matsC,maxMatPower,<int*>frobPowersC.data,
                    <int*>genCountsC.data, m, p, q,
                    <int*>barFactorsC.data, <int*>lenBarFactorsC.data,
                    countBarFactors,
                    <int*>commonBarFactorC.data,lenCommonBarFactor,
                    <int*>commonBiggestBarFactorC.data,lenCommonBiggestBarFactor,
                    matCharacC,elementsFC,
                    multTableC,addTableC)

    genCounts = dict()
    for i,d in enumerate(decomposition):
        genCounts[d] = Integer(genCountsC[i])

    # Free all malloced variables at the end =================================
    freeFFElem(mipoC)
    freeFFElemMatrix(matsC,m*maxMatPower)
    for i in range(len(polys)):
        freeFFPoly(polysC[i])
    free(polysC)
    freeFFElemMatrix(matCharacC,m*(lenBiggestZeroGap+1))
    freeFFElemMatrix(elementsFC,len(elementsF))
    #=========================================================================
    return prod(genCounts.values()), Integer(pcn), genCounts,\
            strfdelta(datetime.timedelta(seconds=(time.time()-TIME)))
\end{sagecode}


\subsection{Ein ausführliches Beispiel}

Wir wollen nun einmal das gesamte Verfahren zur Berechnung Anzahl 
der primitiv vollständig normalen Elemente einer Erweiterung endlicher Körper
anhand eines Beispiels nachvollziehen. Dazu wählen wir $F := \F_2$ und 
$n := 6$, also $E := \F_{2^6}$. Die Wahl des Minimalpolynoms dieser Erweiterung
überlassen wir \sage und erhalten 
\[ E = \F_2[a] \big/ ( a^6 + a^4 + a^3 + a + 1 ) \,.\]

Gehen wir erneut den Code von "countCompleteSubmoduleGenerators"
Zeile für Zeile durch, so beginnen wir mit der Festlegung der grundlegenden
Parameter:
\[ p := 2,\qquad q := 2,\qquad e := 1,\qquad P := \F_2\,.\]


\paragraph{Berechnung der nicht einfachen Teiler} Im nächsten Schritt berechnen
wir die nicht einfachen Teiler mithilfe "get_completely_basic_divisors" 
(\autoref{lst:get_completely_basic_divisors}).
Dazu gehen wir alle Teiler von $n=6$ durch und überprüfen, ob die jeweiligen
Erweiterungen einfach sind, d.h. für jeden Teiler $d \mid n$ testen wir für
jeden Primteiler $r \mid \tfrac{n}{d}$, ob $r \nmid \ord_{(\frac{n}{dr})'}(q^d)$
(vgl. \thref{satz:einfache_erweiterungen}). Wir brechen jeweils ab, falls ein
$r$ die Teilbarkeitsbedingung nicht erfüllt.

\[ \begin{array}{l|l|l|l|l|ll} 
  d & \frac{n}{d} & r & (\frac{n}{dr})' & \ord_{(\frac{n}{dr})'}(q^d) & 
    \multicolumn{2}{l}{r \nmid \ord_{(\frac{n}{dr})'}(q^d)}\\\hline\hline
  1 & 6 & 2 & 3 & 2 & \lightning &\leadsto\text{\small nicht einfach}\\\hline
  2 & 3 & 3 & 1 & 1 & \checkmark\\
  &&&&&& \leadsto\text{\small einfach}
  \end{array}\]

Damit sind alle zu betrachtenden Teiler von $n$ gegeben durch
\[ \text{"notComplBasicDivisors"} := [1,2]\,. \]
Wie man erkennt, wollen wir in diesem Beispiel alle auftretenden Listen in der
\python/\sage-üblichen Notation $[\ ,\ ,\ldots]$ angeben.


\paragraph{Anwendung des Zerlegungssatzes} Anschließend folgt die Berechnung
der Zerlegung in Kreisteilungsmoduln durch den Zerlegungssatz. Da wir in der
konkreten Implementierung stets drei Parameter für die Angabe von
Kreisteilungsmoduln verwenden, d.h. Potenzen der Charakteristik immer
„ausklammern”, wollen wir dies auch hier so notieren. Der zu
$x^n-1 = x^6-1$ über $\F_2$ gehörige Kreisteilungsmodul ist offenbar
\[ \C_{1,6} \speq= \C_{1,3\cdot 2}\]
und wir erhalten damit das Parametertripel $(k,t,\pi) := (1,3,2)$.
Hier startet der Zerlegungssatz rekursiv und wie in "decompose_cycl_module" 
(\autoref{lst:decompose_cycl_module}) erkennbar, durchlaufen wir die Primteiler
von $t$ in der Größe nach absteigend sortierter Reihenfolge.

\begin{center}
  \begin{tikzpicture}[level distance=2cm,sibling distance=3cm]
    \node (root) {$(1,3,2)$}
      child {node {$(1,1,2)$}
        edge from parent
          node[above, sloped, 
            font=\scriptsize,text=gray!50]
            {$(k,\tfrac t r, \pi)$}}
      child {node {$(3,1,2)$}
        edge from parent
          node[above,sloped,
          font=\scriptsize,text=gray!50]
          {$(kr,\tfrac t r, \pi)$}};
    \begin{scope}[overlay]
      \node[right=0.5cm of root, fill=gray!5,
        font=\small] 
        {$r=3$ $\leadsto$ 
          $3^1 \nmid \ord_{\nu(kt')}(q) = \ord_{3}(2) = 2$};
    \end{scope}
  \end{tikzpicture}
\end{center}
Da an den beiden Blättern $t=1$ gilt, endet hier die Möglichkeit einer weiteren
Rekursionsstufe und wir fassen zusammen, dass
\[ x^6-1 \speq= \Phi_1(x)^2 \ \Phi_3(x)^2 \]
die feinste verträgliche Zerlegung des Kreisteilungsmoduls $\C_{1,6}$
über $\F_2$ ist.


\paragraph{Polynome aufstellen} Nun sind wir in der Lage, die Polynome zu
berechnen, die wir für den Test von vermeindlichen vollständigen Erzeugen
benötigen werden. 
\begin{enumerate}
  \item Wir starten beim ersten erweiterten Kreisteilungspolynom
    \[ \Phi_{1,1}^2 \speq= x^2 + 1 \qquad \in \F_2[x]\,. \]
    Es ist nun $(k,t,pi) := (1,1,2)$ und wir 
    müssten alle Teiler des Modulcharakters $\frac{k\,t\,\pi}{\nu(k)} = 2$,
    betrachten. Wie man an obig berechnetem "notComplBasicDivisors" erkennt, 
    lässt sich in diesem Fall auch keiner der beiden Teiler $\{1,2\}$
    streichen. Ein zweiter Kniff schafft aber eine Reduktion der Teilerzahl, da 
    $(1,1,2)$ regulär über $\F_2$ ist:
    \[ \ord_{\nu(k\,t')}(q) \speq= \ord_{1}(2) \speq= 1 \,. \]
    Da auch $(1,1,2)$ nicht ausfallend über $\F_2$ ist, reicht es den einzigen
    Teiler zu berechnen, den wir benötigen:
    \[ \tau(q,k) \speq= \tau(2,1) \speq= 1\,,\]
    da $\ord_k(q) = \ord_1(2) = \ord_{\nu(k)}(q)$.
    \begin{description}
      \item[$d=1.$] Nun sind alle Kofaktoren einer vollständigen Faktorisierung
        von $\Phi_{1,1}(x)^2$ über $\F_{2^d} = \F_2$ zu berechnen:
        \[ \Phi_{1,1}(x)^2 \speq= (x+1)^2\]
        und der einzige Kofaktor ist durch
        \[ g_{1,1,1}(x) \speq= x+1 \]
        gegeben.
    \end{description}
  \item Nun zum zweiten Kreisteilungsmodul $(k,t,\pi) := (3,1,2)$. Der
    Modulcharakter ist wiederum $\frac{k\,t\,\pi}{\nu(k)} = 2$. Auch hier
    können wir mit "notComplBasicDivisors" keinen Teiler wegdiskutieren. Anders
    als in obigem Fall ist dieser Kreisteilungsmodul nicht einmal regulär, da 
    \[ \ord_{\nu(kt')}(q) \speq= \ord_3(2) = 2\]
    nicht teilerfremd zu $kt=2$ ist.
    Also bleiben beide Teiler $\{1,2\}$ übrig.
    \begin{description}
      \item[$d=1.$] Wir faktorisieren 
        \[ \Phi_{3,1}(x)^2 \speq= (x^2+x+1)^2 \qquad \in \F_2[x] \]
        und erhalten als einzigen Kofaktor dieses Teilers
        \[ g_{2,1,1}(x) \speq= x^2+x+1\,.\]
      \item[$d=2.$] Blicken wir noch einmal in die Definition eines
        vollständigen Erzeugers (\thref{def:vollst_erzeuger}), so sehen wir,
        dass wir nun $\C_{3,1\cdot 2}$ als $\F_{2^2}[x]$-Modul betrachten
        müssen. Orientiert man sich an der Definition eines verallgemeinerten
        Kreisteilungsmoduls (\thref{def:verallgemeinerter_kreisteilungsmodul}),
        so sind wir gezwungen $\Phi_3(x^{\frac{2}{2}})$ über $\F_{2^2}$ zu
        faktorisieren. Dazu überlassen wir wiederum \sage die Repräsentation
        des endlichen Körpers
        \[ \F_{2^2} \speq= \F_2[b] \big/ (b^2+b+1)\]
        und faktorisieren
        \[ \Phi_{3,1}(x) \speq= (x+b) (x+b+1)\,. \]
        Ergo erhalten wir die beiden Kofaktoren in $\F_{2^2}[x]$:
        \begin{align*}
          g_{2,2,1}(x) &\speq{:=} x + b+1\,,\\
          g_{2,2,2}(x) &\speq{:=} x + b\,.
        \end{align*}
        Wie aber in der Beschreibung der Implementierung erwähnt, bietet es
        sich an, diese Polynome mittels eines injektiven Körperhomomorphismus
        in $E = \F_{2^6}$ zu lesen. Auch die Berechnung eines solchen
        überlassen wir \sage und wählen
        \[ h:\ \funcdef{\F_2[b]\big/(b^2+b+1) &\to& 
          \F_2[a] \big/ ( a^6 + a^4 + a^3 + a + 1 )\,,\\[10pt]
          b &\mapsto& a^2+a^2+a\,.}\]
        Damit schreiben wir obige Kofaktoren zu
        \begin{align*}
          g_{2,2,1}(x) &\speq{:=} x + a^3+a^2+a+1\,,\\
          g_{2,2,2}(x) &\speq{:=} x + a^3+a^2+a
        \end{align*}
        um, gelesen als Elemente von $\big(\F_2[a]\big/(a^6+a^4+a^3+a+1)\big)[x]$.
    \end{description}
\end{enumerate}
Als letzten Schritt des Aufstellens der Polynome fassen wir alle Ergebnisse
zusammen und erinnern uns an die Implementierung, wo neben den Polynomen auch
die Information, welche Polynome bei Vorliegen eines vollständigen Erzeugers in
der Frobenius-Auswertung zu Null ausgewertet werden müssen, und die Angabe der
Frobenius-Potenzen benötigt werden. Da alle Polynome in \emph{eine einzige}
Liste geschrieben werden, muss man selbstredend die Anzahl der Polynome des
jeweiligen Kreisteilungsmoduls abspeichern. Zusammengefasst erhalten wir
folgende Daten:
\[\small\begin{array}{r@{\ := [}llllll@{]}}
    \text{"polys"} &  x^2+1,& x+1, & x^4+x^2+1, &x^2+x+1, 
      & x+a^3+a^2+a+1, & x+a^3+a^2+a\\
    \text{"evalToZero"} & 1, & 0, & 1, & 0, & 0, & 0\\
    \text{"frobPowers"} & 1, & 1, & 1, & 1, & 2, & 2\\
    \text{"polysCount"} & 2, &    & 4  &    &    &\\
  \end{array}\]
Wie man sicherlich bemerkt, führen wir das den zweiten Kreisteilungsmodul
definierende Polynom $\Phi_{3,2}$ lediglich für den Teiler $d=1$ auf. Für den
Teiler $d=2$ hätten wir $\Phi_{3,1}$ jedoch mit Frobenius-Potenz $2$. Da ein
Element $u\in E$ jedoch genau dann $\Phi_{3,2}(\sigma)(u) = 0$ erfüllt, wenn 
$\Phi_{3,1}(\sigma^2)(u) = 0$, ist dieser Berechnungsschritt obsolet.

\paragraph{Daten für einen Primitivitätstest}
Für den in \autoref{lst:isPrimitive} beschriebenen Primitivitätstest, müssen
wir zunächst $q^n-1 = 2^6-1$ faktorisieren:
\[ 2^6-1 = 3^2\cdot 7\,.\]
Also sind die zu testenden Kofaktoren gerade $9$ und $21$. Wir erkennen sofort,
dass der größte gemeinsame Teiler beider Faktoren $3$ ist und setzen daher
in Benennung von "isPrimitive" (\autoref{lst:isPrimitive})
\[ \text{"commonBarFactor"}\ := 3\,.\]
Ergo reduzieren sich die Kofaktoren auf $3$ und $7$.
Im nächsten Schritt betrachten wir nur noch alle Kofaktoren, die den größten
Primfaktor obiger Faktorisierung enthalten. Hier ist dies nur einer:
$7$. Wieder berechnen wir den $\ggT$ all dieser: $7$. Damit haben wir alle
restlichen Daten:
\[ \begin{array}{r@{\ :=\ }l}
    \text{"commonBiggestBarFactor"} & 7\\
    \text{"barFactors"} & [3,1]
  \end{array} \]
Benutzen wir binäre Exponentiation so übersetzen wir die erhaltenen Zahlen ins
Binärsystem:
\[ \begin{array}{r@{\ :=\ }l}
    \text{"commonBarFactor"} & [1,1]\\
    \text{"commonBiggestBarFactor"} & [1,1,1]\\
    \text{"barFactors"} & \big[[1,1,1],\ [1]\big]
  \end{array} \]
In diesem Fall wären die Zahlen in $p$-adischer Schreibweise identisch, da ja
$p=2$.

\paragraph{Aufstellen der Frobenius-Matrizen}
Um den Frobenius von $F$, also 
$\bar F\to \bar F, x\mapsto x^2$,
effizient auf Elemente aus $E$ anwenden zu können,
müssen wir seine Darstellungsmatrix bezüglich der kanonischen Basis
\[\{ 1, a, a^2, a^3, a^4, a^5\} 
  \subseteq \F_2[a]\big/(a^6 + a^4 + a^3 + a + 1)\]
berechnen. Dazu fassen wir selbstredend die Elemente aus $E$ als Vektoren in
$\F_2^6$ auf:
\[\begin{array}{l@{\ =\ }l@{\quad\cong\quad}l}
  1^2 & 1 & \begin{bmatrix}1&0&0&0&0&0\end{bmatrix}^T\\
  a^2 & a^2 & \begin{bmatrix}0&0&1&0&0&0\end{bmatrix}^T\\
  (a^2)^2 & a^4 & \begin{bmatrix}0&0&0&0&1&0\end{bmatrix}^T\\
  (a^3)^2 & a^4+a^3+a+1 & \begin{bmatrix}1&1&0&1&1&0\end{bmatrix}^T\\
  (a^4)^2 & a^5 + a^4 + a^2 + a + 1 & \begin{bmatrix}1&1&1&0&1&1\end{bmatrix}^T\\
  (a^5)^2 & a^5+a^4+1 & \begin{bmatrix}1&0&0&0&1&1\end{bmatrix}^T
\end{array}\]

Damit erhalten wir eine Darstellungsmatrix des Frobenius:
\[\Gamma_\sigma \speq{:=} \begin{bmatrix}
  1 & 0 & 0 & 1 & 1 & 1 \\
  0 & 0 & 0 & 1 & 1 & 0 \\
  0 & 1 & 0 & 0 & 1 & 0 \\
  0 & 0 & 0 & 1 & 0 & 0 \\
  0 & 0 & 1 & 1 & 1 & 1 \\
  0 & 0 & 0 & 0 & 1 & 1 \\
  \end{bmatrix}\]

Wie man an den obigen Polynomen in "polys" erkennen kann, ist die maximale
Potenz des Frobenius gerade $4$. Daher bleibt noch $\Gamma_\sigma^2$,
$\Gamma_\sigma^3$ und $\Gamma_\sigma^4$ zu berechnen:

\[ \Gamma_\sigma^2 \speq{=}
  \begin{bmatrix}
    1 & 0 & 1 & 1 & 1 & 1 \\
    0 & 0 & 1 & 0 & 1 & 1 \\
    0 & 0 & 1 & 0 & 0 & 1 \\
    0 & 0 & 0 & 1 & 0 & 0 \\
    0 & 1 & 1 & 0 & 1 & 0 \\
    0 & 0 & 1 & 1 & 0 & 0 \\
    \end{bmatrix},
  \quad\Gamma_\sigma^3 \speq=
  \begin{bmatrix}
    1 & 1 & 1 & 1 & 0 & 1 \\
    0 & 1 & 1 & 1 & 1 & 0 \\
    0 & 1 & 0 & 0 & 0 & 1 \\
    0 & 0 & 0 & 1 & 0 & 0 \\
    0 & 1 & 1 & 0 & 1 & 1 \\
    0 & 1 & 0 & 1 & 1 & 0 \\
  \end{bmatrix},
  \quad\Gamma_\sigma^4 \speq=
  \begin{bmatrix}
    1 & 1 & 0 & 1 & 0 & 0 \\
    0 & 1 & 1 & 1 & 1 & 1 \\
    0 & 0 & 0 & 1 & 0 & 1 \\
    0 & 0 & 0 & 1 & 0 & 0 \\
    0 & 1 & 1 & 0 & 0 & 0 \\
    0 & 0 & 1 & 1 & 0 & 1 \\
  \end{bmatrix}.\]

Wie man in der Implementierung erkennen kann übergeben wir die
Frobenius-Matrizen stets als @FFElem **mats@, d.h. man sollte sich obige vier
Matrizen eher als eine $(24\times 6)$-Matrix vorstellen, deren Zeilen jeweils
aus einem @FFElem@ bestehen (vgl. \autoref{sec:impl_endl_körper}). 
Unter dieser Analogie ist dies gerade das Ergebnis der Funktion "genFrobMats".

\paragraph{Iteration von $E$ auf der Suche nach vollständigen Erzeugern}
Wie in der Beschreibung von @processFiniteField@
(\autoref{lst:processFiniteField}) angegeben, starten wir die Suche nach
vollständig normalen und primitiven Elementen bei einer Iteration des endlichen
Körpers $E$, bis wir für jeden Kreisteilungsmodul der Zerlegung einen
vollständigen Erzeuger gefunden haben. Die konkrete Iteration erfolgt dabei
lexikographisch in $\F_2^6$, wobei wir der besseren Lesbarkeit geschuldet
zwischen den verschiedenen Schreibweisen von Vektoren in $\F_2^6$ und
Polynomen in $\F_2[a]\big/(a^6 + a^4 + a^3 + a + 1)$ ohne besondere
Kennzeichnung wechseln werden.
\begin{description}
  \item[$u := \vec{0&0&0&0&0&0}.$] Hier gibt es nichts zu tun.
  \item[$u := \vec{1&0&0&0&0&0}.$] Wir blicken auf "polys" und berechnen
    \[ (x^2+1)(\sigma)(1) \speq= 0\ \checkmark,
    \qquad (x+1)(\sigma)(1) \speq= 0\ \lightning\,.\]
    Also ist $1$ kein Erzeuger von $\C_{1,1\cdot 2}$ über $\F_2$.
    Beim zweiten Kreisteilungsmodul scheitern wir bereits beim ersten Polynom:
    \[ (x^4+x+1)(\sigma)(1) \speq= 1\ \lightning\,.\]
  \item[\ldots] Hier sind weitere Elemente zu denken, die ebenfalls keine 
    vollständigen Erzeuger liefern.
  \item[$u := \vec{0&1&1&0&0&0}.$] Dieses Element liefert einen vollständigen
    Erzeuger des zweiten Kreisteilungsmoduls:
    \[\begin{array}{r@{\ =\ }l@{\quad}r@{\ =\ }l} 
      (x^4+x^2+1)(\sigma)(u) & 0, &
      (x^2+x+1)(\sigma)(u) & a^5+a^4+a^2+1, \\[8pt]
      (x+a^3+a^2+a^1)(\sigma^2)(u) & a^5 + a^4 + a^3 + a, &
      (x+a^3+a^2+a)(\sigma^2)(u) & a^5+a^4\,.
      \end{array}\]
    Die Anwendung des Frobenius ist dabei jeweils durch obige Matrizen zu
    denken.
  \item[\ldots]
  \item[$u := \vec{0&1&1&1&0&0}.$] Hier haben wir einen vollständigen Erzeuger
    des ersten Kreisteilungsmoduls, wie nachstehende Rechnung zeigt.
    \[\begin{array}{r@{\ =\ }l@{\qquad}r@{\ =\ }l} 
      (x^2+1)(\sigma)(u) & 0, &
      (x+1)(\sigma)(u) & 1\,.
      \end{array}\]
\end{description}
Die berechneten vollständigen Erzeuger speichern wir in einem Array aus
verketteten Listen (vgl. \autoref{subsub:verkettete_listen}). Die verketteten
Listen sowie das Array wollen wir hier jedoch wieder in \python-üblicher 
Notation angeben. Bisher haben wir also für jeden Kreisteilungsmodul einen
Erzeuger gefunden:
\[ \text{"roots"}\ =\ \big[\, [a^3+a^2+a],\ [a^2+a] \,\big]\]
Die Benennung "roots" ist hier konsistent mit @processFiniteField@
(\autoref{lst:processFiniteField}) gewählt. Jedoch sind die Elemente der Listen
natürlich wieder als @FFElem@ zu denken.


\paragraph{Enumeration der einzelnen Kreisteilungsmoduln}
An diesem Punkt haben wir für jeden Kreisteilungsmodul einen Erzeuger gefunden
und können anhand diesem den jeweiligen Modul vollständig enumerieren.
\begin{description}
  \item[$\Phi_{1,1}^2.$] Sei $u := a^3+a^2+a$ unser gefundener Erzeuger, so können
    wir nach \thref{lemma:moduln_durch_polys} den Modul durch Polynome über
    $F$, deren Grad kleiner $2$ ist, enumerieren:
    \[ \C_{1,1\cdot 2} \speq= \{ f(\sigma)(u):\ 
      f \in F[x]_{<2},\ \ggT(f,\Phi_{1,1}^2) = 1\}\,.\]
    Wie im Absatz nach \thref{lemma:moduln_durch_polys} erwähnt, führen wir die
    Berechnung des $\ggT$ nicht durch, sondern testen jedes Element auf
    vollständige Erzeuger-Eigenschaft für diesen Modul.
    \[\begin{array}{l|l|l}
      f(x) & f(\sigma)(u) & \text{vollst. Erz.}\\\hline
      1 & a^3+a^2+a & \checkmark\\
      x & a^3+a^2+a+1 & \checkmark\\
      x+1 & 1 & \lightning
      \end{array}\]
  \item [$\Phi_{3,1}^2.$] Sei in diesem Fall $u:= a^2+a$ der gefundene
    Erzeuger, so müssen wir Polynome bis zum Grad $3$ über $F$ betrachten:
    \[\begin{array}{l|l|l}
      f(x) & f(\sigma)(u) & \text{vollst. Erz.}\\\hline
      1 & a^2+a & \checkmark\\
      x & a^4+a^2 & \checkmark\\
      x+1 & a^4+a & \lightning\\
      x^2 & a^5+a^2+a+1 & \checkmark\\
      x^2+1 & a^5+1 & \checkmark\\
      x^2+x & a^5+a^4+a+1 & \lightning\\
      x^2+x+1 & a^5+a^4+a^2+1 & \lightning\\
      x^3 & a^5+a^2 & \checkmark\\
      x^3+1 & a^5+a & \lightning\\
      x^3+x & a^5+a^4 & \checkmark\\
      x^3+x+1 & a^5+a^4+a^2+a & \lightning\\
      x^3+x^2 & a+1 & \lightning\\
      x^3+x^2+1 & a^2+1 & \lightning\\
      x^3+x^2+x & a^4+a^2+a+1 & \lightning\\
      x^3+x^2+x+1 & a^4+1 & \lightning
      \end{array}\]
    In der konkreten Implementierung speichern wir diese Ergebnisse nicht ab,
    sondern erzeugen die weiteren Erzeuger des letzten Kreisteilungsmoduls
    dynamisch (vgl.  
    \autoref{sub:dynamische_enumeration}), was
    wir hier zur besseren Übersichtlichkeit nicht tun wollen.
\end{description}

Nun können wir die aktualisierte Liste "roots" angeben:
\[\text{"roots"}\ =\ \big[\, [a^3+a^2+a,\, a^3+a^2+a+1],\ 
  [a^2+a,\, a^4+a^2,\, a^5+a^2+a+1,\, a^5+1,\, a^5+a^2,\, a^5+a^4]\,\big]\]

An dieser Stelle können wir bereits festhalten, dass in der Erweiterung von
Grad $6$ über $\F_2$ genau $6\cdot 2=12$ vollständig normale Elemente
existieren.

\paragraph{Primitivitätstest}
Für einen Primitivitätstest müssen wir die $12$ vollständig normalen Elemente
natürlich erst einmal „zusammenbauen”. Dazu durchlaufen wir das kartesische
Produkt aus den Listen in "roots" und bilden jeweils die Summe der einzelnen
Elemente (vgl. \thref{def:vertraeglich}).
\begin{description}
  \item[$(a^3+a^2+a)\ +\ (a^2+a).$] 
    Wie in der Beschreibung zu @isPrimitive@ (\autoref{lst:isPrimitive})
    erläutert, berechnen wir zunächst $v^\texttt{\scriptsize commonBarFactor} = v^3$,
    wobei $v := a^3+a^2+a + a^2+a = a^3$ das zu testende Element ist.
    Dies führen wir mittels binärer Exponentiation durch, wie in 
    @powerFFElemSqM@ (\autoref{lst:powerffelemsqm}) beschrieben, geben hier
    jedoch nur das Ergebnis an. Es ist 
    \[ v^3 \speq=  a^5 + a^4 + a^2 + 1 \speq{=:} w\,.\]
    Da $w \neq 1$ müssen wir fortfahren mit dem ersten Faktor aus 
    @barFactors@:
    \[ w^3 \speq= a^5 + a^4 + a^2\,. \]
    Auch dies ist ungleich $1$, also fahren wir fort mit 
    $w^\texttt{\scriptsize commonBiggestBarFactor}$ wie in 
    @isPrimitive@ (\autoref{lst:isPrimitive}) angegeben:
    \[ w^7 \speq= 1\,.\]
    An dieser Stelle können wir abbrechen und wissen, dass $v$ kein
    primitives Element ist.
  \item[$(a^3+a^2+a+1)\ +\ (a^2+a).$]
    Auch hier beginnen wir mit $v := a^3+a^2+a+1 + a^2+a = a^3+1$ und 
    berechnen
    \[ v^3 \speq= a^5+a^2+a+1 \speq{=:} w \,.\]
    Wieder ist $w\neq 1$ und wir fahren fort mit dem ersten @barFactor@.
    \[ w^3 \speq= a^4+a^2+a\,.\]
    Für den Exponenten $\text{"biggestCommonBarFactor"} = 7$ erhalten wir:
    \[ w^7 \speq= a^3+a^2+a \speq{=:} z\,.\]
    Diesen müssen wir nun mit allen verbleibenden @barFactor@s potenzieren. In
    unserem Fall lediglich einer:
    \[ z^1 \speq= a^3+a^2+a \]
    und somit ist $v$ ein primitives Element in $E$.
\end{description}

Für alle weiteren Elemente wollen wir nur das Ergebnis der Primitivitätstests
in tabellarischer Form angeben.

\[\begin{array}{l|l|l|l}
  \text{Gen von } \C_{1,1\cdot 2} & \text{Gen von } \C_{3,1\cdot 2} &
    \text{Element} & 
    \text{primitiv} \\\hline
  a^3+a^2+a & a^4+a^2 & a^4+a^3 +a & \checkmark\\
  a^3+a^2+a+1 & a^4+a^2 & a^4+a^3+a+1 & \lightning\\
  a^3+a^2+a & a^5+a^2+a+1 & a^5+a^3+1 & \lightning\\
  a^3+a^2+a+1 &a^5+a^2+a+1 & a^5+a^3 & \checkmark\\
  a^3+a^2+a & a^5+1 & a^5 +a^3+a^2+a+1& \lightning\\
  a^3+a^2+a+1 &a^5+1 & a^5+a^3+a^2+a &\checkmark\\
  a^3+a^2+a & a^5+a^2 & a^5+a^3+a & \checkmark\\
  a^3+a^2+a+1 & a^5+a^2& a^5+a^3+a+1 &\lightning\\
  a^3+a^2+a & a^5+a^4 & a^5+a^4+a^3+a^2+a &\checkmark\\
  a^3+a^2+a+1 & a^5+a^4 & a^5+a^4+a^3+a^2+a+1 &\lightning\\
  \end{array}\]

Zusammenfassend existieren also $6$ primitiv vollständig normale Elemente in
der Erweiterung von Grad $6$ über $\F_2$.
