from sage.all import *
import re
import time
from multiprocessing import Pool, Value
import multiprocessing
import itertools
import datetime
import os
import numpy as np
cimport numpy as np
from libc.stdlib cimport malloc, free
from libc.stdint cimport int
from cpython.mem cimport PyMem_Malloc, PyMem_Free


#def isNormal(x, F):
#    E = x.parent();
#    q = F.order();
#    n = E.order().log(q);
#    m = matrix(E, n,n, lambda i, j: x**(q**(i+j)));
#    return m.is_invertible();
#
#
#def tau_order_old(x,F, factors=[]):
#    E = x.parent();
#    q = F.order();
#    n = E.order().log(q);
#    fac = factors;
#    if fac == []:
#        Fx = PolynomialRing(F,'x');
#        for (f,i) in (Fx.gen()**n-1).factor():
#            fac = fac + [f]*i
#    #print fac
#    for i in range(0,2**len(fac)):
#        f = combinePolys(fac, dec_to_bin(i));
#        #print "\tf = ", f, "\tfrob_eval(f,x) = ", frob_eval(f,x)
#        if frob_eval(f,x) == 0: 
#            return f;
#
#
#
def tau_order(x,F, factors=[], prods=[], sigmaPower=1):
    Fx = PolynomialRing(F,'x');
    E = x.parent();
    q = F.order();
    n = E.order().log(q);
    if factors == []:
        fac = (Fx.gen()**n-1).factor();
    else:
        fac = factors;
    pows = dict();
    pre = [];
    for idx,(f,mult) in enumerate(fac):
        for j in xrange(mult-1,-1,-1):
            g = f.parent().one();
            ev = pre + [j] + map(lambda i: i[1], fac[idx+1:]);
            if prods == []:
                #generate factor
                for kidx, k in enumerate(ev):
                    g *= fac[kidx][0]**k;
            else:
                g = prods[str(ev)];
            ret = E.zero();
            for i,g in enumerate(list(g)):
                if pows != []:
                    if pows.has_key(i):
                        xi = pows[i];
                    else:
                        xi = x**(q**i);
                        pows[i] = xi;
                else: xi = x**(q**i);
                try:
                    ret += g*xi;
                except:
                    h = Hom(F,E)[0];
                    ret += h(g)*xi;
            if ret != 0:
                pre += [j+1]; 
                break;
            elif j == 0: 
                pre += [0];
    if prods == []:
        g = f.parent().one();
        for jidx, j in enumerate(pre):
            g *= fac[jidx][0]**j;
    else:
        g = prods[str(pre)]
    gshifted = [Fx.zero()]*len(list(g))
    for i, gi in enumerate(g):
        if gi == 0: continue
        gshifted[int(i/sigmaPower)] = gi
    return Fx(gshifted)

#def isNormal(x,F, factors=[], prods=[]):
#    E = x.parent();
#    q = F.order();
#    n = E.order().log(q);
#    Fx = PolynomialRing(F,'x');
#    if factors == []:
#        fac = (Fx.gen()**n-1).factor();
#    else: fac = factors;
#    pows = dict();
#    for idx,(f,mult) in enumerate(fac):
#        # generate product key
#        ev = map(lambda i: fac[i][1], xrange(idx)) + \
#                [0] + map(lambda i: i[1], fac[idx+1:]); 
#        if prods != [] and prods.has_key(str(ev)):
#            g = prods[str(ev)];
#        else: #generate factor manually
#            g = f.parent().one();
#            for jidx, j in enumerate(ev):
#                g *= fac[jidx][0]**j;
#        ret = E.zero();
#        iold = 0
#        xiold = x
#        for i,g in enumerate(list(g)):
#            if pows.has_key(i):
#                xi = pows[i];
#                iold = i
#                xiold = xi
#            else:
#                xi = xiold**(q**(i-iold));
#                pows[i] = xi;
#                xiold = xi
#                iold = i
#            try:
#                ret += g*xi;
#            except:
#                h = Hom(F,E)[0];
#                ret += h(g)*xi;
#        if ret == 0: return False;
#    return True;
#
def isCompletelyNormal(x,F, fieldsAll=[], facAll=[], prodsAll=[]):
    if x == 0: return False
    E = x.parent();
    q = F.order();
    n = E.order().log(q);
    p = F.characteristic();
    e = q.log(p)
    divs = get_proper_subfield_divisors(p,e,n)
    if facAll == []:
        facAll = dict();
        prodsAll = dict();
        fieldsAll = dict();
        for d in divs:
            G = F.extension(Integer(d), 'c');
            Gx = PolynomialRing(G,'x');
            fieldsAll[d] = G;
            facAll[d] = list((Gx.gen()**(n/d)-1).factor());
            facAll[d] = list((Gx.gen()**(n/d)-1).factor());
            prodsAll[d] = dict();
            for idx,(f,mult) in enumerate(facAll[d]):
                prodsAll[d][idx] = (Gx.gen()**(n/d)-1).quo_rem(f)[0]
    #test isNormal for each divisor
    pows = dict()
    for d in divs:
        h = Hom(fieldsAll[d],E)[0];
        for idx,(f,mult) in enumerate(facAll[d]):
            g = prodsAll[d][idx];
            ret = E.zero();
            iold = 0
            xiold = x
            for i,gi in enumerate(list(g)):
                if pows.has_key(i*d):
                    xi = pows[i*d];
                    iold = i*d
                    xiold = xi
                else:
                    xi = xiold**(q**(d*i-iold));
                    pows[i*d] = xi;
                    xiold = xi
                    iold = i*d
                ret += h(gi)*xi
            if ret == 0: return False;
    return True
#
#
#def isCompletelyNormal_ggt(x,F):
#    if x == 0: return False
#    E = x.parent();
#    q = F.order();
#    n = E.order().log(q);
#    Ex = PolynomialRing(E,'x');
#    p = F.characteristic();
#    e = q.log(p)
#    divs = get_proper_subfield_divisors(p,e,n)
#    if x == 0: return False
#    #test isNormal for each divisor
#    #  ---------------------------
#    pows = dict()
#    for d in divs:
#        if d == n: continue
#        e = n/d
#        g = Ex.zero()
#        iold = 0
#        xiold = x
#        for i in xrange(e):
#            if pows.has_key(i*d):
#                xi = pows[i*d];
#                iold = i*d
#                xiold = xi
#            else:
#                xi = xiold**(q**(d*i-iold));
#                pows[i*d] = xi;
#                xiold = xi
#                iold = i*d
#            g += xi*Ex.gen()**(e-1-i)
#            #print g
#        if g.gcd(Ex.gen()**e-1) != 1: return False
#    return True
#
#
#def countCNAndPCN_parallel(F,n):
#    TIME = time.clock()
#    p = F.characteristic()
#    q = F.order();
#    e = q.log(p)
#    E = F.extension(Integer(n),'a');
#    #generate factors
#    facAll = dict();
#    prodsAll = dict();
#    fieldsAll = dict();
#    divs = get_proper_subfield_divisors(p,e,n)
#    for d in divs:
#        G = F.extension(Integer(d), 'c');
#        Gx = PolynomialRing(G,'x');
#        fieldsAll[d] = G;
#        facAll[d] = list((Gx.gen()**(n/d)-1).factor());
#        prodsAll[d] = dict();
#        for idx,(f,mult) in enumerate(facAll[d]):
#            prodsAll[d][idx] = (Gx.gen()**(n/d)-1).quo_rem(f)[0]
#    #count all elements
#    countCN = 0
#    countPCN = 0
#    TIME = (time.clock() - TIME)
#    num_processes = multiprocessing.cpu_count()
#    pool = Pool(num_processes)
#    for cn, pcn,t in pool.imap(func=_isCompletelyNormal\
#                , iterable=([x,F,q,divs,fieldsAll,facAll,prodsAll] for x in E) \
#                , chunksize=100):
#        countCN += cn
#        countPCN += pcn
#        TIME += t
#    pool.close()
#    pool.join()
#    return countCN, countPCN, TIME/num_processes
#
#
#def _isCompletelyNormal(data):
#    TIME = time.clock()
#    x,F,q,divs,fieldsAll,facAll,prodsAll = data
#    if x == 0: return 0,0,0
#    E = x.parent()
#    isCn = True
#    #test isNormal for each divisor
#    #  ---------------------------
#    pows = dict()
#    for d in divs:
#        if not isCn: break
#        for idx,(f,mult) in enumerate(facAll[d]):
#            if not isCn: break
#            g = prodsAll[d][idx];
#            ret = E.zero();
#            iold = 0
#            xiold = x
#            for i,gi in enumerate(list(g)):
#                h = Hom(fieldsAll[d],E)[0];
#                if pows.has_key(i*d):
#                    xi = pows[i*d];
#                    iold = i*d
#                    xiold = xi
#                else:
#                    xi = xiold**(q**(d*i-iold));
#                    pows[i*d] = xi;
#                    xiold = xi
#                    iold = i*d
#                try:
#                    ret += gi*xi;
#                except:
#                    ret += h(gi)*xi;
#            if ret == 0: isCn = False;
#    #  ---------------------------
#    if isCn:
#        if x.multiplicative_order() == E.order()-1:
#            return 1,1, (time.clock()-TIME)
#        else : return 1,0 , (time.clock()-TIME) 
#    return 0,0 , (time.clock()-TIME) 
#
#
#
#def countCNAndPCN(F,n):
#    TIME = time.clock();
#    p = F.characteristic()
#    q = F.order();
#    e = q.log(p)
#    E = F.extension(Integer(n),'a');
#    qn = q**n
#    #generate factors
#    facAll = dict();
#    prodsAll = dict();
#    fieldsAll = dict();
#    # only consider factors obtained by the Decomposition Theorem
#    divs = get_proper_subfield_divisors(p,e,n)
#    #divs = divisors(n)
#    for d in divs:
#        G = F.extension(Integer(d), 'c');
#        Gx = PolynomialRing(G,'x');
#        fieldsAll[d] = G;
#        facAll[d] = list((Gx.gen()**(n/d)-1).factor());
#        prodsAll[d] = dict();
#        for idx, (f,mult) in enumerate(facAll[d]):
#            prodsAll[d][idx] = (Gx.gen()**(n/d)-1).quo_rem(f)[0]
#    #count all elements
#    countCN = 0;
#    countPCN = 0;
#    for idx,x in enumerate(E):
#        isCn = True
#        if x == 0: isCn = False
#        #test isNormal for each divisor
#        #  ---------------------------
#        pows = dict()
#        for d in divs:
#            if not isCn: break
#            if d == n: continue
#            for idx,(f,mult) in enumerate(facAll[d]):
#                if not isCn: break
#                g = prodsAll[d][idx];
#                ret = E.zero();
#                iold = 0
#                xiold = x
#                for i,gi in enumerate(list(g)):
#                    h = Hom(fieldsAll[d],E)[0];
#                    if pows.has_key(i*d):
#                        xi = pows[i*d];
#                        iold = i*d
#                        xiold = xi
#                    else:
#                        xi = xiold**(q**(d*i-iold));
#                        pows[i*d] = xi;
#                        xiold = xi
#                        iold = i*d
#                    try:
#                        ret += gi*xi;
#                    except:
#                        ret += h(gi)*xi;
#                if ret == 0: isCn = False;
#        #  ---------------------------
#        if isCn: countCN += 1;
#        if isCn and x.multiplicative_order() == qn-1:
#            countPCN += 1;
#    return countCN, countPCN, (time.clock()-TIME)
#
#def countCompleteSubmoduleGenerators(F,n):
#    TIME = time.time()
#    p = F.characteristic()
#    q = F.order();
#    e = q.log(p)
#    E = F.extension(Integer(n),'a');
#    #generate factors
#    data = dict();
#    decomposition = decompose(p,e,n)
#    for decomp in decomposition:
#        data[decomp] = dict()
#        k,t,pi = decomp
#        divs = divisors(get_module_character(*decomp))
#        data[decomp][-1] = divs
#        for d in divs:
#            G = F.extension(Integer(d), 'c');
#            Gx = PolynomialRing(G,'x'); 
#            cycl = Gx.cyclotomic_polynomial(squarefree(k))\
#                    (Gx.gen()**(k*t*pi/squarefree(k)/d))
#            factors = []
#            for f,mult in cycl.factor():
#                factors += [cycl.quo_rem(f)[0]]
#            data[decomp][d] = (G,cycl,factors)
#    #count all elements
#    generators = dict()
#    for d in decomposition:
#        generators[d] = set()
#    num_processes = multiprocessing.cpu_count()
#    pool = Pool(num_processes)
#    hoursOld = 0
#    counter = 0
#    for d,gen in pool.imap_unordered(func=_isCompleteSubmoduleGenerator\
#                , iterable=([x,F,q,decomposition,data] for x in E) \
#                , chunksize=10):
#        if d != -1:
#            generators[d].add(gen)
#        counter += 1
#        hoursNow = floor((time.time()-TIME)/3600)
#        if hoursNow > hoursOld:
#            print "\t",strfdelta(datetime.timedelta(seconds=(time.time()-TIME))),\
#                    "elapsed -> ", round(100*counter/E.order(),3),\
#                    "% processed"
#            hoursOld = hoursNow
#        if counter == 10000:
#            print "\teta", strfdelta(datetime.timedelta(\
#                    seconds=long(E.order()/counter*(time.time()-TIME))))
#    countGens = []
#    # count generators
#    for d in decomposition:
#        countGens += [(d, len(generators[d]))]
#    # calc primitive ones
#    countPrims = 0
#    for cP in pool.imap_unordered(func=_isPrimitive\
#            , iterable=itertools.product(*[generators[d] for d in decomposition])
#            , chunksize=100):
#        countPrims += cP
#    pool.close()
#    pool.join()
#    
#    return prod(map(lambda c: c[1],countGens)), countPrims,\
#            countGens, \
#            strfdelta(datetime.timedelta(seconds=(time.time()-TIME)))
#
#
#def _isPrimitive(y):
#    x = sum(y)
#    E = x.parent()
#    if x.multiplicative_order() == E.order()-1:
#        return 1
#    return 0
#
#
#def _isCompleteSubmoduleGenerator(input):
#    x,F,q,decomposition,data = input
#    E = x.parent()
#    if x == 0: return -1,0
#    # test complete generator for each cyclotomic module of the 
#    # complete decomposition
#    #  ---------------------------
#    pows = dict()
#    for decomp in decomposition:
#        #print "test compl gen for decomp=",decomp
#        isCompleteGen = True
#        for d in data[decomp][-1]:
#            #print "\ttest d=",d
#            if not isCompleteGen: break
#            G, cycl, factors = data[decomp][d]
#            h = Hom(G,E)[0];
#            # test submodules of cycl
#            for g in factors:
#                if not isCompleteGen: break
#                ret = E.zero();
#                iold = 0
#                xiold = x
#                for i,gi in enumerate(list(g)):
#                    if pows.has_key(i*d):
#                        xi = pows[i*d];
#                        iold = i*d
#                        xiold = xi
#                    else:
#                        xi = xiold**(q**(d*i-iold));
#                        pows[i*d] = xi;
#                        xiold = xi
#                        iold = i*d
#                    try:
#                        ret += gi*xi;
#                    except:
#                        ret += h(gi)*xi;
#                if ret == 0: isCompleteGen = False;
#            #print "\t->factor test: ",isCompleteGen
#            if isCompleteGen:
#                # test cyclotomic polynomial
#                ret = E.zero();
#                iold = 0
#                xiold = x
#                for i, gi in enumerate(list(cycl)):
#                    if pows.has_key(i*d):
#                        xi = pows[i*d];
#                        iold = i*d
#                        xiold = xi
#                    else:
#                        xi = xiold**(q**(d*i-iold));
#                        pows[i*d] = xi;
#                        xiold = xi
#                        iold = i*d
#                    try:
#                        ret += gi*xi;
#                    except:
#                        ret += h(gi)*xi;
#                #print "\t->cycl(x)=",ret
#                if ret != 0: isCompleteGen = False
#        if isCompleteGen: 
#            return decomp, x
#    return -1, 0

cdef extern from "./powertest.c":
    unsigned long long processFFElements(int *x_mipo, int decompCount,\
        int *polys, int *polysLen, int *polysCoeffDegs, int *polysCount, \
        char *evalToZero, int *mats, int matLen, int *frobPowers, \
        int *genCounts, int m, int charac, int shiftSize,\
        int *barFactors, int *lenBarFactors, int countBarFactors, \
        int *matCharac)
    unsigned long long processFFElements_useGens(int *x_mipo, int decompCount,\
        int *polys, int *polysLen, int *polysCoeffDegs, int *polysCount, \
        char *evalToZero, int *mats, int matLen, int *frobPowers, \
        int *genCounts, int m, int charac, int q, \
        int *barFactors, int *lenBarFactors, int countBarFactors, \
        int *biggestPrimeFactor, int lenBiggestPrimeFactor, \
        int *matCharac, int *elementsF, int *elementsFDegs, \
        int *multTable, int initialMultShift, 
        int *addTable, int initialAddShift)
    double eta_processFFElements(int *x_mipo, int decompCount,\
        int *polys, int *polysLen, int *polysCoeffDegs, int *polysCount, \
        char *evalToZero, int *mats, int matLen, int *frobPowers, \
        int *genCounts, int m, int charac, int shiftSize)
    void findAnyPCN(int *x, int *x_mipo, \
        int *polys, int *polysLen, int *polysCount, char *evalToZero,\
        int *mats, int *frobPowers, \
        int m, int charac, \
        int *barFactors, int *lenBarFactors, int countBarFactors,\
        int *matCharac)
    char findAnyPCN_useGen(int *x, int *generator, int *x_mipo, \
        int *polys, int *polysLen, int *polysCoeffDegs, \
        int polysCount, \
        int *mats, int matLen, int *frobPowers, \
        int m, int charac, \
        int *powerTable, int lenPowerTable)
    void genMats(int *mipo, int m, int *mats, int maxPower, int charac, \
            int q)


def countCompleteSubmoduleGenerators_internalC_useGens(F,n, maxEta=0):
    TIME = time.time()
    p = F.characteristic()
    q = F.order();
    e = q.log(p)
    E = F.extension(Integer(n),'a');
    P = E.prime_subfield()
    #generate factors
    polys = []
    polysLen = []
    polysCount = []
    polysCoeffDegs = []
    evalToZero = []
    frobPowers = []
    notComplBasicDivisors = get_completely_basic_divisors(p,e,n)
    decomposition = decompose(p,e,n)
    for decomp in decomposition:
        k,t,pi = decomp
        divs = divisors(get_module_character(*decomp))
        #print "for decomp=",decomp, "consider divs=",divs
        divs = filter(lambda x: x in notComplBasicDivisors, divs)
        #print "\tnow only", divs
        countPolysForThisDecomp = 0
        for d in divs:
            G = F.extension(Integer(d), 'c');
            Gx = PolynomialRing(G,'x'); 
            h = Hom(G,E)[0]
            cycl = Gx.cyclotomic_polynomial(squarefree(k))\
                    (Gx.gen()**(k*t*pi/squarefree(k)/d))
            polys += [cycl.map_coefficients(h)]
            polysLen += [len(list(cycl))]
            polysCoeffDegs += map(lambda gi: gi.polynomial().degree(), \
                    cycl.map_coefficients(h))
            #print "\tcylcE=",cycl.map_coefficients(h)
            #print "\tcoeffDegs=", map(lambda gi: gi.polynomial().degree(), cycl.map_coefficients(h)) 
            frobPowers += [d]
            evalToZero += [1]
            countPolysForThisDecomp += 1
            #print "\ti.e. cycl=",cycl
            # add Co-Factors
            for f,mult in cycl.factor():
                g = cycl.quo_rem(f)[0]
                gE = g.map_coefficients(h)
                #print "\tgE=",gE
                polys += [gE]
                polysLen += [len(list(g))]
                polysCoeffDegs += map(lambda gi: gi.polynomial().degree(), gE)
                #print "\tcoeffDegs=", map(lambda gi: gi.polynomial().degree(), gE) 
                frobPowers += [d]
                evalToZero += [0]
                countPolysForThisDecomp +=1
        polysCount += [countPolysForThisDecomp]
    #print "decomp = ",decomposition
    #print "polys= ",polys, "len=",len(polys)
    #print "polysLen=",polysLen, "len=",len(polysLen)
    #print "polysCoeffDegs=", polysCoeffDegs
    #print "evalToZero=",evalToZero, "len=",len(evalToZero)
    #print "frobPowers=",frobPowers, "len=",len(frobPowers)
    #print "polysCount=",polysCount, "len=",len(polysCount)

    charac = int(E.characteristic())
        #mipo, idcsMipo
    mipo = E.modulus()
    m = mipo.degree()
    idcsMipo = []
    listMipo = list(mipo)
    for i in range(m,-1,-1):
        if listMipo[i] != 0:
            idcsMipo += [i]
    lenMipo = len(idcsMipo)


    #calc prime factors of order
    barFactors = []
    primitiveOrder = E.order()-1
    #for r,k in factor(primitiveOrder):
        #for i in range(1,k+1):
            #barFactors += [primitiveOrder/(r**i)]
    biggestPrimeFactor = factor(primitiveOrder)[-1][0]
    for r,k in factor(primitiveOrder):
        barFactors += [primitiveOrder/r]
    countBarFactors = len(barFactors)
    #print "barFactors=", barFactors
    curF = 0
    barFactors_tmp = [barFactors[-1]]
    for b in reversed(barFactors[:-1]):
        barFactors_tmp += [ b/biggestPrimeFactor - curF]
        curF = b/biggestPrimeFactor
    barFactors = barFactors_tmp
    #print "barFactors=", barFactors
    #print "biggestPrimeFactor=", biggestPrimeFactor
    barFactors = map(\
            lambda b: get_padic_representation(Integer(b),Integer(p))\
            ,barFactors)
    biggestPrimeFactor = get_padic_representation(biggestPrimeFactor,Integer(p))
    lenBiggestPrimeFactor = len(biggestPrimeFactor)
    #find biggest gap (i.e. zero-interval)
    lenBiggestZeroGap = 0
    lenCurGap = 0
    for b in barFactors+[biggestPrimeFactor]:
        i = 0
        while i < len(b):
            lenCurGap = 0
            while i<len(b) and b[i] == 0:
                lenCurGap+= 1
                i += 1
            lenBiggestZeroGap = max(lenBiggestZeroGap, lenCurGap)
            i += 1
    #print "barFactors=",barFactors
    #print "biggestPrimeFactor=", biggestPrimeFactor
    #print "lenBiggestZeroGap=",lenBiggestZeroGap

        #generate F elements in E
    h = Hom(F,E)[0]
    elementsF = []
    elementsFDegs = []
    if p != q:
        elementsF = []
        for e in itertools.product(xrange(p),repeat=e):
            elementsF += [list( h( F(list(reversed(e))) ).polynomial() )]
        elementsFDegs = map(lambda e: len(e)-1, elementsF)

        # multiplication and addition table for prime field
    multTable = [0]*(2*(p-1)**2+1)
    addTable = [0]*(2*2*(p-1)+1)
    for i in range(-p+1,p):
        for j in range(-p+1,p):
            #print i,"*",j, " = ", (i*j+p**2)%p
            multTable[(p-1)**2 + i*j] = (i*j+p**2)%p
            addTable[2*(p-1) + i+j] = (i+j + 2*p)%p
    #print "multTable=",multTable, " len=", len(multTable)
    #print "addTable=", addTable, " len=", len(addTable)

    
    #--------------------
    #setup C data
    maxMatPower = max(map(lambda d: euler_phi(d[0])*d[1]*d[2], decomposition))
    #setup matrices
    cdef np.ndarray[int,ndim=3,mode="c"] matsC
    matsC = genMatsPy(E,F,maxMatPower+1)
    #setup mipo
    cdef np.ndarray[int,ndim=1,mode="c"] xmipoC \
            = np.array(list(mipo), dtype=np.int32)
    cdef np.ndarray[int,ndim=1,mode="c"] idcsMipoC\
            = np.array(idcsMipo, dtype=np.int32)
    #setup polynomials, polyLength, frobPowers, evaltoZero
    decompCount = int(len(polysCount))
        #evalToZeroC
    cdef np.ndarray[char,ndim=1,mode="c",cast=True] evalToZeroC\
            = np.array(evalToZero, dtype=np.uint8)
        #frobPowersC
    cdef np.ndarray[int,ndim=1,mode="c"] frobPowersC\
            = np.array(frobPowers, dtype=np.int32)
        #polysCountC
    cdef np.ndarray[int,ndim=1,mode="c"] polysCountC\
            = np.array(polysCount, dtype=np.int32)
        #polysCoeffDegsC
    cdef np.ndarray[int,ndim=1,mode="c"] polysCoeffDegsC\
            = np.array(polysCoeffDegs, dtype=np.int32)
        #polysLenC
    cdef np.ndarray[int,ndim=1,mode="c"] polysLenC\
            = np.array(polysLen, dtype=np.int32)
        #polys
    cdef np.ndarray[int,ndim=2,mode="c"] polysC\
            = np.zeros((sum(polysLen),m), dtype=np.int32)
    curPos = 0
    for idx,g in enumerate(polys):
        g = map(lambda gi: list(gi.polynomial()),list(g))
        for i in range(len(g)):
            for j in range(len(g[i])):
                polysC[curPos+i][j] = <int>g[i][j]
        curPos += polysLen[idx]
        # prime Factors
    cdef np.ndarray[int,ndim=1,mode="c"] barFactorsC \
        = np.array(list(itertools.chain(*barFactors)), dtype=np.int32)
    cdef np.ndarray[int,ndim=1,mode="c"] lenBarFactorsC \
        = np.array(map(len,barFactors), dtype=np.int32)
    cdef np.ndarray[int,ndim=1,mode="c"] biggestPrimeFactorC \
        = np.array(biggestPrimeFactor, dtype=np.int32)
        # mat charac
    P = E.prime_subfield()
    gen = mipo.parent().gen()
    matCharac = matrix(P, m,m)
    for i in xrange(m):
        for j, fi in enumerate(((gen**i)**p).mod(mipo)):
            matCharac[i,j] = fi
    matCharac = matCharac.transpose()
    cdef np.ndarray[int,ndim=3,mode="c"] matCharacC\
        = np.zeros((lenBiggestZeroGap+1,m,m), dtype=np.int32)
    tmpMat = matCharac
    for i in range(lenBiggestZeroGap+1):
        tmpMat = matCharac**(i+1)
        for j in range(m):
            for k in range(m):
                matCharacC[i][j][k] = tmpMat[j][k]
    idcsMatCharac = []
    lenMatCharac = []
    for i in range(lenBiggestZeroGap+1):
        for j in range(m):
            countCurRow = 0
            for k in range(m-1,-1,-1):
                if matCharacC[i][j][k] != 0:
                    idcsMatCharac += [k]
                    countCurRow += 1
            lenMatCharac += [countCurRow]
    cdef np.ndarray[int,ndim=1,mode="c"] idcsMatCharacC \
        = np.array(idcsMatCharac, dtype=np.int32)
    cdef np.ndarray[int,ndim=1,mode="c"] lenMatCharacC \
        = np.array(lenMatCharac, dtype=np.int32)

        # F elements in E
    cdef np.ndarray[int,ndim=1,mode="c"] elementsFDegsC\
        = np.array(elementsFDegs, dtype=np.int32)
    cdef np.ndarray[int,ndim=2,mode="c"] elementsFC\
        = np.zeros((q,m), dtype=np.int32)
    for i,e in enumerate(elementsF):
        for j in range(len(e)):
            elementsFC[i][j] = e[j]
        # multiplication and addition table
    cdef np.ndarray[int,ndim=1,mode="c"] multTableC\
        = np.array(multTable, dtype=np.int32)
    cdef np.ndarray[int,ndim=1,mode="c"] addTableC\
        = np.array(addTable, dtype=np.int32)

    #end setup C data
    #--------------------
    #print "matsC=", matsC
    #print "polysC= ",polysC, "len=",len(polysC)
    #print "polysLenC=",polysLenC, "len=",len(polysLenC)
    #print "evalToZeroC=",evalToZeroC, "len=",len(evalToZeroC)
    #print "frobPowersC=",frobPowersC, "len=",len(frobPowersC)
    #print "polysCountC=",polysCountC, "len=",len(polysCountC)
    #print "xmipoC=",xmipoC
    #print "barFactorsC=",barFactorsC
    #print "lenBarFactorsC=",lenBarFactorsC
    #print "matCharacC=", matCharacC
    #print "elementsFC=", elementsFC
    #print "elementsFDegsC=",elementsFDegsC
    #print "multTableC=",multTableC
    #print "addTableC=",addTableC

    #--------------------
    # prepare C output
    #print "int polys[] = {"
    #for i in range(sum(polysLen)):
        #for j in range(m):
            #sys.stdout.write(str(polysC[i][j]))
            #if j < m-1 or i < sum(polysLen)-1:
                #sys.stdout.write(", ")
        #printf("\n")
    #print "};"
    #print "int mats[] = {"
    #for i in range(maxMatPower+1):
        #for j in range(m):
            #for k in range(m):
                #sys.stdout.write(str(matsC[i][j][k]))
                #if i < maxMatPower or j<m-1 or k<m-1:
                    #sys.stdout.write(", ")
            #printf("\n")
    #print "};"

    #print "int matLen = ",maxMatPower+1,";"
    
    #print "int matsCharac[] = {"
    #for j in range(m):
        #for k in range(m):
            #sys.stdout.write(str(matCharacC[j][k]))
            #if j<m-1 or k<m-1:
                #sys.stdout.write(", ")
        #printf("\n")
    #print "};"

    #sys.stdout.write("int polysLen[] = {")
    #for i in range(len(polysLen)):
        #sys.stdout.write(str(polysLenC[i]))
        #if i< len(polysLen)-1:
                #sys.stdout.write(", ")
    #print "};"
    
    #sys.stdout.write("int polysCoeffDegs[] = {")
    #for i in range(len(polysCoeffDegs)):
        #sys.stdout.write(str(polysCoeffDegsC[i]))
        #if i< len(polysCoeffDegs)-1:
                #sys.stdout.write(", ")
    #print "};"

    #sys.stdout.write("bool evalToZero[] = {")
    #for i in range(len(evalToZero)):
        #sys.stdout.write(str(evalToZeroC[i]))
        #if i< len(evalToZero)-1:
                #sys.stdout.write(", ")
    #print "};"
    
    #sys.stdout.write("int frobPowers[] = {")
    #for i in range(len(frobPowers)):
        #sys.stdout.write(str(frobPowersC[i]))
        #if i< len(frobPowers)-1:
                #sys.stdout.write(", ")
    #print "};"
  
    #sys.stdout.write("int polysCount[] = {")
    #for i in range(len(polysCount)):
        #sys.stdout.write(str(polysCountC[i]))
        #if i< len(polysCount)-1:
                #sys.stdout.write(", ")
    #print "};"
    
    #sys.stdout.write("int xmipo[] = {")
    #for i in range(len(list(mipo))):
        #sys.stdout.write(str(xmipoC[i]))
        #if i< len(list(mipo))-1:
                #sys.stdout.write(", ")
    #print "};"

    #sys.stdout.write("int barFactors[] = {")
    #for i in range(barFactorsC.shape[0]):
        #sys.stdout.write(str(barFactorsC[i]))
        #if i< barFactorsC.shape[0]-1:
                #sys.stdout.write(", ")
    #print "};"
    
    #sys.stdout.write("int lenBarFactors[] = {")
    #for i in range(lenBarFactorsC.shape[0]):
        #sys.stdout.write(str(barFactorsC[i]))
        #if i< lenBarFactorsC.shape[0]-1:
                #sys.stdout.write(", ")
    #print "};"
    #print "int countBarFactors = ", len(barFactors),";"
    
    #sys.stdout.write("int elementsF[] = {")
    #for i in range(elementsFC.shape[0]):
        #for j in range(elementsFC.shape[1])
            #sys.stdout.write(str(elementsFC[i][j]))
            #if i< elementsFC.shape[0]-1 and j < elementsFC.shape[1]-1:
                    #sys.stdout.write(", ")
    #print "};"
    
    #sys.stdout.write("int elementsFDegs[] = {")
    #for i in range(elementsFDegsC.shape[0]):
        #sys.stdout.write(str(elementsFDegsC[i]))
        #if i< elementsFDegsC.shape[0]-1:
                #sys.stdout.write(", ")
    #print "};"
    
    #sys.stdout.write("int multTable[] = {")
    #for i in range(multTableC.shape[0]):
        #sys.stdout.write(str(multTableC[i]))
        #if i< multTableC.shape[0]-1:
                #sys.stdout.write(", ")
    #print "};"
    #sys.stdout.write("int addTable[] = {")
    #for i in range(addTableC.shape[0]):
        #sys.stdout.write(str(addTableC[i]))
        #if i< addTableC.shape[0]-1:
                #sys.stdout.write(", ")
    #print "};"

    #print "int decompCount = ", decompCount, ";"
    #print "int m = ", m, ";"
    #print "int charac = ",p,";"
    #print "int q = ",q,";"

    #return

    #--------------------
    #setup return and tmp values
    cdef np.ndarray[int,ndim=1,mode="c"] genCountsC
    genCountsC = np.zeros(decompCount, dtype=np.int32)


    ## calc shiftsize
    #shifter = 1
    #shiftSize = 0
    #while shifter < charac:
        #shiftSize +=1
        #shifter <<= 1

    #get eta
    #eta = eta_processFFElements(<int*>xmipoC.data \
            #,<int>decompCount \
            #,<int*>polysC.data, <int*>polysLenC.data \
            #,<int*>polysCoeffDegsC.data \
            #,<int*>polysCountC.data \
            #,<char*>evalToZeroC.data \
            #,<int*>matsC.data, <int>maxMatPower+1, <int*>frobPowersC.data \
            #,<int*>genCountsC.data \
            #,<int>m,<int>p)
    #print "(p,e,n) = (",p,",",e,",",n,") eta = ",eta,"s"
    #if maxEta != 0 and eta > maxEta:
        #return

    cdef unsigned long long pcn
    pcn = processFFElements_useGens(<int*>xmipoC.data \
            ,<int>decompCount \
            ,<int*>polysC.data, <int*>polysLenC.data \
            ,<int*>polysCoeffDegsC.data \
            ,<int*>polysCountC.data \
            ,<char*>evalToZeroC.data \
            ,<int*>matsC.data, <int>maxMatPower+1, <int*>frobPowersC.data \
            ,<int*>genCountsC.data \
            ,<int>m,<int>p, <int>q \
            ,<int*>barFactorsC.data, <int*>lenBarFactorsC.data\
            ,<int>countBarFactors \
            ,<int*>biggestPrimeFactorC.data, <int>lenBiggestPrimeFactor
            ,<int*>matCharacC.data \
            ,<int*>elementsFC.data, <int*>elementsFDegsC.data \
            ,<int*>multTableC.data, <int>(p-1)**2\
            ,<int*>addTableC.data, <int>2*(p-1))
            #,<int*>tmpC.data ,<int*>tmp2C.data \
            #,<int*>xC.data, <int*>retC.data \
            #, rootsC, curRootsC, combinedElements)

    
    #--------------------
    #test primitivity
    #primOrder = E.order()-1
    #countPrims = 0;
    #for line in open(filepath,'r'):
        ##decodeArr(combinedElements.x,<int*>curEl.data,m, shiftSize)
        #curEl = map(int,line.split(' ')[0:m])
        ##print "test curEl=",curEl
        #if E(list(curEl)).multiplicative_order() == primOrder:
            #countPrims += 1
    #os.remove(filepath)

    #--------------------
    genCounts = dict()
    for i,d in enumerate(decomposition):
        genCounts[d] = genCountsC[i]
    return prod(list(genCountsC)), Integer(pcn), genCounts,\
            strfdelta(datetime.timedelta(seconds=(time.time()-TIME)))



#def countCompleteSubmoduleGenerators_internalC(F,n, maxEta=0):
#    TIME = time.time()
#    p = F.characteristic()
#    q = F.order();
#    e = q.log(p)
#    E = F.extension(Integer(n),'a');
#    #generate factors
#    polys = []
#    polysLen = []
#    polysCount = []
#    polysCoeffDegs = []
#    evalToZero = []
#    frobPowers = []
#    notComplBasicDivisors = get_completely_basic_divisors(F,n)
#    decomposition = decompose(p,e,n)
#    for decomp in decomposition:
#        k,t,pi = decomp
#        divs = divisors(get_module_character(*decomp))
#        #print "for decomp=",decomp, "consider divs=",divs
#        divs = filter(lambda x: x in notComplBasicDivisors, divs)
#        #print "\tnow only", divs
#        countPolysForThisDecomp = 0
#        for d in divs:
#            G = F.extension(Integer(d), 'c');
#            Gx = PolynomialRing(G,'x'); 
#            h = Hom(G,E)[0]
#            cycl = Gx.cyclotomic_polynomial(squarefree(k))\
#                    (Gx.gen()**(k*t*pi/squarefree(k)/d))
#            polys += [cycl.map_coefficients(h)]
#            polysLen += [len(list(cycl))]
#            polysCoeffDegs += map(lambda gi: gi.polynomial().degree(), \
#                    cycl.map_coefficients(h))
#            #print "\tcylcE=",cycl.map_coefficients(h)
#            #print "\tcoeffDegs=", map(lambda gi: gi.polynomial().degree(), cycl.map_coefficients(h)) 
#            frobPowers += [d]
#            evalToZero += [1]
#            countPolysForThisDecomp += 1
#            #print "\ti.e. cycl=",cycl
#            # add Co-Factors
#            for f,mult in cycl.factor():
#                g = cycl.quo_rem(f)[0]
#                gE = g.map_coefficients(h)
#                #print "\tgE=",gE
#                polys += [gE]
#                polysLen += [len(list(g))]
#                polysCoeffDegs += map(lambda gi: gi.polynomial().degree(), gE)
#                #print "\tcoeffDegs=", map(lambda gi: gi.polynomial().degree(), gE) 
#                frobPowers += [d]
#                evalToZero += [0]
#                countPolysForThisDecomp +=1
#        polysCount += [countPolysForThisDecomp]
#    #print "decomp = ",decomposition
#    #print "polys= ",polys, "len=",len(polys)
#    #print "polysLen=",polysLen, "len=",len(polysLen)
#    #print "polysCoeffDegs=", polysCoeffDegs
#    #print "evalToZero=",evalToZero, "len=",len(evalToZero)
#    #print "frobPowers=",frobPowers, "len=",len(frobPowers)
#    #print "polysCount=",polysCount, "len=",len(polysCount)
#
#    #calc prime factors of order
#    barFactors = []
#    primitiveOrder = E.order()-1
#    for r,k in factor(primitiveOrder):
#        for i in range(1,k+1):
#            barFactors += [primitiveOrder/(r**i)]
#    countBarFactors = len(barFactors)
#    #print "barFactors=", barFactors
#    barFactors = map(\
#            lambda b: get_padic_representation(Integer(b),Integer(p))\
#            ,barFactors)
#    #print "barFactors=",barFactors
#    
#    #--------------------
#    #setup C data
#    charac = int(E.characteristic())
#    mipo = E.modulus()
#    m = mipo.degree()
#    maxMatPower = max(map(lambda d: euler_phi(d[0])*d[1]*d[2], decomposition))
#    #setup matrices
#    cdef np.ndarray[int,ndim=3,mode="c"] matsC
#    matsC = genMatsPy(E,F,maxMatPower+1)
#    #setup mipo
#    cdef np.ndarray[int,ndim=1,mode="c"] xmipoC \
#            = np.array(list(mipo), dtype=np.int32)
#    #setup polynomials, polyLength, frobPowers, evaltoZero
#    decompCount = int(len(polysCount))
#        #evalToZeroC
#    cdef np.ndarray[char,ndim=1,mode="c",cast=True] evalToZeroC\
#            = np.array(evalToZero, dtype=np.uint8)
#        #frobPowersC
#    cdef np.ndarray[int,ndim=1,mode="c"] frobPowersC\
#            = np.array(frobPowers, dtype=np.int32)
#        #polysCountC
#    cdef np.ndarray[int,ndim=1,mode="c"] polysCountC\
#            = np.array(polysCount, dtype=np.int32)
#        #polysCoeffDegsC
#    cdef np.ndarray[int,ndim=1,mode="c"] polysCoeffDegsC\
#            = np.array(polysCoeffDegs, dtype=np.int32)
#        #polysLenC
#    cdef np.ndarray[int,ndim=1,mode="c"] polysLenC\
#            = np.array(polysLen, dtype=np.int32)
#        #polys
#    cdef np.ndarray[int,ndim=2,mode="c"] polysC\
#            = np.zeros((sum(polysLen),m), dtype=np.int32)
#    curPos = 0
#    for idx,g in enumerate(polys):
#        g = map(lambda gi: list(gi.polynomial()),list(g))
#        for i in range(len(g)):
#            for j in range(len(g[i])):
#                polysC[curPos+i][j] = <int>g[i][j]
#        curPos += polysLen[idx]
#        # prime Factors
#    cdef np.ndarray[int,ndim=1,mode="c"] barFactorsC \
#        = np.array(list(itertools.chain(*barFactors)), dtype=np.int32)
#    cdef np.ndarray[int,ndim=1,mode="c"] lenBarFactorsC \
#        = np.array(map(len,barFactors), dtype=np.int32)
#        # mat charac
#    P = E.prime_subfield()
#    gen = mipo.parent().gen()
#    matCharac = matrix(P, m,m)
#    for i in xrange(m):
#        for j, fi in enumerate(((gen**i)**p).mod(mipo)):
#            matCharac[i,j] = fi
#    matCharac = matCharac.transpose()
#    cdef np.ndarray[int,ndim=2,mode="c"] matCharacC\
#        = np.zeros((m,m), dtype=np.int32)
#    for j in range(m):
#        for k in range(m):
#            matCharacC[j][k] = matCharac[j][k]
#
#    #end setup C data
#    #--------------------
#    #print "matsC=", matsC
#    #print "polysC= ",polysC, "len=",len(polysC)
#    #print "polysLenC=",polysLenC, "len=",len(polysLenC)
#    #print "evalToZeroC=",evalToZeroC, "len=",len(evalToZeroC)
#    #print "frobPowersC=",frobPowersC, "len=",len(frobPowersC)
#    #print "polysCountC=",polysCountC, "len=",len(polysCountC)
#    #print "xmipoC=",xmipoC
#    #print "barFactorsC=",barFactorsC
#    #print "lenBarFactorsC=",lenBarFactorsC
#    #print "matCharacC=", matCharacC
#
#    #--------------------
#    # prepare C output
#    #print "int polys[] = {"
#    #for i in range(sum(polysLen)):
#        #for j in range(m):
#            #sys.stdout.write(str(polysC[i][j]))
#            #if j < m-1 or i < sum(polysLen)-1:
#                #sys.stdout.write(", ")
#        #printf("\n")
#    #print "};"
#    #print "int mats[] = {"
#    #for i in range(maxMatPower+1):
#        #for j in range(m):
#            #for k in range(m):
#                #sys.stdout.write(str(matsC[i][j][k]))
#                #if i < maxMatPower or j<m-1 or k<m-1:
#                    #sys.stdout.write(", ")
#            #printf("\n")
#    #print "};"
#
#    #sys.stdout.write("int polysLen[] = {")
#    #for i in range(len(polysLen)):
#        #sys.stdout.write(str(polysLenC[i]))
#        #if i< len(polysLen)-1:
#                #sys.stdout.write(", ")
#    #print "};"
#
#    #sys.stdout.write("bool evalToZero[] = {")
#    #for i in range(len(evalToZero)):
#        #sys.stdout.write(str(evalToZeroC[i]))
#        #if i< len(evalToZero)-1:
#                #sys.stdout.write(", ")
#    #print "};"
#    
#    #sys.stdout.write("int frobPowers[] = {")
#    #for i in range(len(frobPowers)):
#        #sys.stdout.write(str(frobPowersC[i]))
#        #if i< len(frobPowers)-1:
#                #sys.stdout.write(", ")
#    #print "};"
#  
#    #sys.stdout.write("int polysCount[] = {")
#    #for i in range(len(polysCount)):
#        #sys.stdout.write(str(polysCountC[i]))
#        #if i< len(polysCount)-1:
#                #sys.stdout.write(", ")
#    #print "};"
#    
#    #sys.stdout.write("int xmipo[] = {")
#    #for i in range(len(list(mipo))):
#        #sys.stdout.write(str(xmipoC[i]))
#        #if i< len(list(mipo))-1:
#                #sys.stdout.write(", ")
#    #print "};"
#
#    #sys.stdout.write("int primFactors[] = {")
#    #for i in range(lenPrimFacs):
#        #sys.stdout.write(str(primFactors[i]))
#        #if i< lenPrimFacs-1:
#                #sys.stdout.write(", ")
#    #print "};"
#    #sys.stdout.write("int coFactors[] = {")
#    #for i in range(lenPrimFacs):
#        #sys.stdout.write(str(coFactors[i]))
#        #if i< lenPrimFacs-1:
#                #sys.stdout.write(", ")
#    #print "};"
#    #sys.stdout.write("int barFactors[] = {")
#    #for i in range(lenPrimFacs):
#        #sys.stdout.write(str(barFactors[i]))
#        #if i< lenPrimFacs-1:
#                #sys.stdout.write(", ")
#    #print "};"
#
#    #print "int decompCount = ", decompCount, ";"
#    #print "int m = ", m, ";"
#    #print "int charac = ",p,";"
#
#    #return
#
#    #--------------------
#    #setup return and tmp values
#    cdef np.ndarray[int,ndim=1,mode="c"] genCountsC
#    genCountsC = np.zeros(decompCount, dtype=np.int32)
#
#
#    # calc shiftsize
#    shifter = 1
#    shiftSize = 0
#    while shifter < charac:
#        shiftSize +=1
#        shifter <<= 1
#
#    #get eta
#    eta = eta_processFFElements(<int*>xmipoC.data \
#            ,<int>decompCount \
#            ,<int*>polysC.data, <int*>polysLenC.data \
#            ,<int*>polysCoeffDegsC.data \
#            ,<int*>polysCountC.data \
#            ,<char*>evalToZeroC.data \
#            ,<int*>matsC.data, <int>maxMatPower+1, <int*>frobPowersC.data \
#            ,<int*>genCountsC.data \
#            ,<int>m,<int>p, <int>shiftSize)
#    print "(p,e,n) = (",p,",",e,",",n,") eta = ",eta,"s"
#    if maxEta != 0 and eta > maxEta:
#        return
#
#    cdef unsigned long long pcn
#    pcn = processFFElements(<int*>xmipoC.data \
#            ,<int>decompCount \
#            ,<int*>polysC.data, <int*>polysLenC.data \
#            ,<int*>polysCoeffDegsC.data \
#            ,<int*>polysCountC.data \
#            ,<char*>evalToZeroC.data \
#            ,<int*>matsC.data, <int>maxMatPower+1, <int*>frobPowersC.data \
#            ,<int*>genCountsC.data \
#            ,<int>m,<int>p, <int>shiftSize\
#            ,<int*>barFactorsC.data, <int*>lenBarFactorsC.data\
#            ,<int>countBarFactors \
#            ,<int*>matCharacC.data)
#            #,<int*>tmpC.data ,<int*>tmp2C.data \
#            #,<int*>xC.data, <int*>retC.data \
#            #, rootsC, curRootsC, combinedElements)
#
#    
#    #--------------------
#    #test primitivity
#    #primOrder = E.order()-1
#    #countPrims = 0;
#    #for line in open(filepath,'r'):
#        ##decodeArr(combinedElements.x,<int*>curEl.data,m, shiftSize)
#        #curEl = map(int,line.split(' ')[0:m])
#        ##print "test curEl=",curEl
#        #if E(list(curEl)).multiplicative_order() == primOrder:
#            #countPrims += 1
#    #os.remove(filepath)
#
#    #--------------------
#    genCounts = dict()
#    for i,d in enumerate(decomposition):
#        genCounts[d] = genCountsC[i]
#    return prod(list(genCountsC)), Integer(pcn), genCounts,\
#            strfdelta(datetime.timedelta(seconds=(time.time()-TIME)))

#def findAnyPCN_internalC(F,n):
#    TIME = time.time()
#    p = F.characteristic()
#    q = F.order();
#    e = q.log(p)
#    E = F.extension(Integer(n),'a');
#    #generate factors
#    polys = []
#    polysLen = []
#    polysCount = []
#    evalToZero = []
#    frobPowers = []
#    divs = get_proper_subfield_divisors(p,e,n)
#    countPolysForThisDecomp = 0
#    #print "for decomp=",decomp, "consider divs=",divs
#    for d in divs:
#        G = F.extension(Integer(d), 'c');
#        Gx = PolynomialRing(G,'x'); 
#        h = Hom(G,E)[0]
#        cycl = (Gx.gen()**(n/d)-1)
#        polys += [cycl.map_coefficients(h)]
#        polysLen += [len(list(cycl))]
#        frobPowers += [d]
#        evalToZero += [1]
#        countPolysForThisDecomp += 1
#        #print "\ti.e. cycl=",cycl
#        # add Co-Factors
#        for f,mult in cycl.factor():
#            g = cycl.quo_rem(f)[0]
#            #print "\tfac=",g
#            polys += [g.map_coefficients(h)]
#            polysLen += [len(list(g))]
#            frobPowers += [d]
#            evalToZero += [0]
#            countPolysForThisDecomp +=1
#    polysCount += [countPolysForThisDecomp]
#    #calc prime factors of order
#    barFactors = []
#    primitiveOrder = E.order()-1
#    for r,k in factor(primitiveOrder):
#        for i in range(1,k+1):
#            barFactors += [primitiveOrder/(r**i)]
#    countBarFactors = int(len(barFactors))
#    
#    #print "decomp = ",decomposition
#    #print "polys= ",polys, "len=",len(polys)
#    #print "polysLen=",polysLen, "len=",len(polysLen)
#    #print "evalToZero=",evalToZero, "len=",len(evalToZero)
#    #print "frobPowers=",frobPowers, "len=",len(frobPowers)
#    #print "polysCount=",polysCount, "len=",len(polysCount)
#    #--------------------
#    #setup C data
#    charac = int(E.characteristic())
#    mipo = E.modulus()
#    m = mipo.degree()
#    #setup matrices
#    cdef np.ndarray[int,ndim=3,mode="c"] matsC
#    matsC = genMatsPy(E,F,n+1)
#    #setup mipo
#    cdef np.ndarray[int,ndim=1,mode="c"] xmipoC \
#            = np.array(list(mipo), dtype=np.int32)
#    #setup polynomials, polyLength, frobPowers, evaltoZero
#    decompCount = int(len(polysCount))
#        #evalToZeroC
#    cdef np.ndarray[char,ndim=1,mode="c",cast=True] evalToZeroC\
#            = np.array(evalToZero, dtype=np.uint8)
#        #frobPowersC
#    cdef np.ndarray[int,ndim=1,mode="c"] frobPowersC\
#            = np.array(frobPowers, dtype=np.int32)
#        #polysCountC
#    cdef np.ndarray[int,ndim=1,mode="c"] polysCountC\
#            = np.array(polysCount, dtype=np.int32)
#        #polysLenC
#    cdef np.ndarray[int,ndim=1,mode="c"] polysLenC\
#            = np.array(polysLen, dtype=np.int32)
#        #polys
#    cdef np.ndarray[int,ndim=2,mode="c"] polysC\
#            = np.zeros((sum(polysLen),m), dtype=np.int32)
#    curPos = 0
#    for idx,g in enumerate(polys):
#        g = map(lambda gi: list(gi.polynomial()),list(g))
#        for i in range(len(g)):
#            for j in range(len(g[i])):
#                polysC[curPos+i][j] = <int>g[i][j]
#        curPos += polysLen[idx]
#    # prime Factors
#    print barFactors
#    return
#    cdef np.ndarray[char,ndim=2,mode="c"] barFactorsC \
#        = np.array(map(lambda f: [int(i) for i in bin(f)[2:]],barFactors), dtype=np.uint8) 
#    cdef np.ndarray[int,ndim=1,mode="c"] lenBarFactorsC \
#        = np.array(map(len,barFactorsC), dtype=np.int32)
#    #end setup C data
#    #--------------------
#    
#    print "matsC=", matsC
#    print "polysC= ",polysC, "len=",len(polysC)
#    print "polysLenC=",polysLenC, "len=",len(polysLenC)
#    print "evalToZeroC=",evalToZeroC, "len=",len(evalToZeroC)
#    print "frobPowersC=",frobPowersC, "len=",len(frobPowersC)
#    print "polysCountC=",polysCountC, "len=",len(polysCountC)
#    print "xmipoC=",xmipoC
#    print "barFactorsC=",barFactorsC
#    print "lenBarFactorsC=",lenBarFactorsC
#    print "countBarFactors=",countBarFactors
#    return
#
#
#    #--------------------
#    #setup return and tmp values
#    cdef np.ndarray[int,ndim=1,mode="c"] xC \
#        = np.zeros(m, dtype=np.int32) 
#    cdef np.ndarray[int,ndim=1,mode="c"] tmpC \
#        = np.zeros(m, dtype=np.int32) 
#    cdef np.ndarray[int,ndim=1,mode="c"] tmp_xC \
#        = np.zeros(m, dtype=np.int32) 
#    cdef np.ndarray[int,ndim=1,mode="c"] tmp2C \
#        = np.zeros(2*m, dtype=np.int32) 
#    cdef np.ndarray[int,ndim=1,mode="c"] retC \
#        = np.zeros(m, dtype=np.int32) 
#
#    findAnyPCN(<int*>xC.data, <int*>xmipoC.data \
#        ,<int*>polysC.data, <int*>polysLenC.data \
#        ,<int*>polysCountC.data \
#        ,<char*>evalToZeroC.data \
#        ,<int*>matsC.data, <int*>frobPowersC.data \
#        ,<int>m,<int>p \
#        ,<char*>barFactorsC.data, <int*>lenBarFactorsC.data\
#        ,<int>countBarFactors)
#        #print "test x=",list(xC)
#    if xC[0] != -1:
#        return list(xC)
#    return False
#
def findAnyPCN_useGen_internalC(F,n):
    TIME = time.time()
    p = F.characteristic()
    q = F.order();
    e = q.log(p)
    E = F.extension(Integer(n),'a');
    #generate factors
    polys = []
    polysLen = []
    polysCount = []
    evalToZero = []
    frobPowers = []
    polysCoeffDegs = []
    divs = get_proper_subfield_divisors(p,e,n)
    countPolysForThisDecomp = 0
    maxMatPower = 0
    biggestZeroGap = 0
    #print "for decomp=",decomp, "consider divs=",divs
    for d in divs:
       #print "div = ",d
       G = F.extension(Integer(d), 'c');
       Gx = PolynomialRing(G,'x'); 
       h = Hom(G,E)[0]
       cycl = (Gx.gen()**(n/d)-1)
       #polys += [cycl.map_coefficients(h)]
       #polysLen += [len(list(cycl))]
       #frobPowers += [d]
       #evalToZero += [1]
       #countPolysForThisDecomp += 1
       #print "\ti.e. cycl=",cycl
       # add Co-Factors
       for f,mult in cycl.factor():
            g = cycl.quo_rem(f)[0]
            if g.degree() > maxMatPower: maxMatPower = g.degree()
            gE = map(lambda gi: list(h(gi).polynomial()), list(g))
            #get biggest gap
            i=0
            while i < len(gE):
                curGap = 0
                while g[i] == 0:
                    curGap += 1
                    i += 1
                if curGap > biggestZeroGap: biggestZeroGap = curGap
                i += 1
            #print "g=",g
            #print "\tgE = ",gE
            polys += [gE]
            polysLen += [len(gE)]
            frobPowers += [d]
            #evalToZero += [0]
            countPolysForThisDecomp += 1
            polysCoeffDegs += map(lambda gi: len(gi)-1, gE)
    polysCount = countPolysForThisDecomp
        ##generate F elements in E
    #h = Hom(F,E)[0]
    #elementsF = []
    #elementsFDegs = []
    #if p != q:
        #elementsF = []
        #for e in itertools.product(xrange(p),repeat=e):
            #elementsF += [list( h( F(list(reversed(e))) ).polynomial() )]
        #elementsFDegs = map(lambda e: len(e)-1, elementsF)

        # multiplication and addition table for prime field
#    multTable = [0]*(2*(p-1)**2+1)
#    addTable = [0]*(2*2*(p-1)+1)
#    for i in range(-p+1,p):
#        for j in range(-p+1,p):
#            #print i,"*",j, " = ", (i*j+p**2)%p
#            multTable[(p-1)**2 + i*j] = (i*j+p**2)%p
#            addTable[2*(p-1) + i+j] = (i+j + 2*p)%p
    #print "multTable=",multTable, " len=", len(multTable)
    #print "addTable=", addTable, " len=", len(addTable)

    #print "decomp = ",decomposition
    #print "polys= ",polys, "len=",len(polys)
    #print "polysLen=",polysLen, "len=",len(polysLen)
    #print "evalToZero=",evalToZero, "len=",len(evalToZero)
    #print "frobPowers=",frobPowers, "len=",len(frobPowers)
    #print "polysCount=",polysCount, "len=",len(polysCount)
    #print "biggestZeroGap=",biggestZeroGap
    #--------------------
    #setup C data
    charac = int(E.characteristic())
    mipo = E.modulus()
    m = mipo.degree()
        #setup mipo
    cdef np.ndarray[int,ndim=1,mode="c"] xmipoC \
            = np.array(list(mipo), dtype=np.int32)
    #setup polynomials, polyLength, frobPowers, evaltoZero
        #evalToZeroC
    cdef np.ndarray[char,ndim=1,mode="c",cast=True] evalToZeroC\
            = np.array(evalToZero, dtype=np.uint8)
        #frobPowersC
    cdef np.ndarray[int,ndim=1,mode="c"] frobPowersC\
            = np.array(frobPowers, dtype=np.int32)
        #polysLenC
    cdef np.ndarray[int,ndim=1,mode="c"] polysLenC\
            = np.array(polysLen, dtype=np.int32)
        #polysCoeffDegsC
    cdef np.ndarray[int,ndim=1,mode="c"] polysCoeffDegsC\
            = np.array(polysCoeffDegs, dtype=np.int32)
        #polys
    cdef np.ndarray[int,ndim=2,mode="c"] polysC\
            = np.zeros((sum(polysLen),m), dtype=np.int32)
    curPos = 0
    for idx,g in enumerate(polys):
        #g = map(lambda gi: list(gi.polynomial()),g)
        for i in range(len(g)):
            for j in range(len(g[i])):
                polysC[curPos+i][j] = <int>g[i][j]
        curPos += polysLen[idx]
 
        # primitive element
    cdef np.ndarray[int,ndim=1,mode="c"] generatorC\
            = np.zeros(m, dtype=np.int32)
    for i, xi in enumerate(E.primitive_element().polynomial()):
        generatorC[i] = xi
    #cdef np.ndarray[int,ndim=3,mode="c"] matsC\
           #= genMatsPy(E,F,n+1)
        ## F elements in E
    #cdef np.ndarray[int,ndim=1,mode="c"] elementsFDegsC\
        #= np.array(elementsFDegs, dtype=np.int32)
    #cdef np.ndarray[int,ndim=2,mode="c"] elementsFC\
        #= np.zeros((q,m), dtype=np.int32)
    #for i,e in enumerate(elementsF):
        #for j in range(len(e)):
            #elementsFC[i][j] = e[j]
        # multiplication and addition table
    #cdef np.ndarray[int,ndim=1,mode="c"] multTableC\
        #= np.array(multTable, dtype=np.int32)
    #initialMultShift = int((p-1)**2)
    #cdef np.ndarray[int,ndim=1,mode="c"] addTableC\
        #= np.array(addTable, dtype=np.int32)
    #initialAddShift = int(2*(p-1))
        #setup matrices
    cdef np.ndarray[int,ndim=3,mode="c"] matsC\
            = np.zeros((biggestZeroGap+1,m,m),dtype=np.int32)
    gens = map(lambda i: E.gen()**i, range(m))
    for i in range(1,biggestZeroGap+1):
        for j in range(m):
            gens[j] = gens[j]**q
            genq = list(gens[j].polynomial())
            for k in range(len(genq)):
                matsC[i][k][j] = genq[k]
    #genMats(<int*>xmipoC.data, m, <int*>matsC.data, 0,charac,q)
   
    #end setup C data
    #--------------------
    
    #print "matsC=", matsC
    #print "matLen=",n
    #print "polysC= ",polysC, "len=",len(polysC)
    #print "polysLenC=",polysLenC, "len=",len(polysLenC)
    #print "evalToZeroC=",evalToZeroC, "len=",len(evalToZeroC)
    #print "frobPowersC=",frobPowersC, "len=",len(frobPowersC)
    #print "polysCountC=",polysCountC, "len=",len(polysCountC)
    #print "xmipoC=",xmipoC
    #print "multTable=",multTable
    #print "addTable=",addTable
 
 
    #--------------------
    #setup return and tmp values
    cdef np.ndarray[int,ndim=1,mode="c"] xC \
        = np.zeros(m, dtype=np.int32) 
    cdef np.ndarray[int,ndim=1,mode="c"] tmpC \
        = np.zeros(m, dtype=np.int32) 
    cdef np.ndarray[int,ndim=1,mode="c"] tmp_xC \
        = np.zeros(m, dtype=np.int32) 
    cdef np.ndarray[int,ndim=1,mode="c"] tmp2C \
        = np.zeros(2*m, dtype=np.int32) 
    cdef np.ndarray[int,ndim=1,mode="c"] retC \
        = np.zeros(m, dtype=np.int32) 
 
    #setup powers of generator
    cdef np.ndarray[int,ndim=1,mode="c"] powerTableC
    orderE = E.order()-1
    lastPower = 1
    curPower = 1
    powerTable = [0]
    
    #do tests
    pcnFound = False
    while not pcnFound and curPower < orderE:
            # generate powers
        for i in xrange(10):
            curPower += 1
            if curPower >= orderE: 
                break
            if gcd(curPower, orderE) == 1:
                powerTable += [curPower-lastPower]
                lastPower = curPower
        powerTableC = np.array(powerTable, dtype=np.int32)
 
        #print "test till curPower=",curPower, " of orderE=",orderE
#        pcnFound = findAnyPCN_useGen(<int*>xC.data \
#                ,<int*>generatorC.data, <int*>xmipoC.data \
#                ,<int*>polysC.data, <int*>polysLenC.data \
#                ,<int*>polysCoeffDegsC.data, <int>polysCount \
#                ,<int*>matsC.data, <int>maxMatPower+1, <int*>frobPowersC.data \
#                ,<int>m,<int>p \
#                ,<int*>powerTableC.data, <int>len(powerTable))
#        if pcnFound:
#            #test result
#            el = E(list(xC))
#            if not isCompletelyNormal(el,F) \
#                    or not el.multiplicative_order() == orderE:
#                print "FATAL ERROR F=",F," E=",E
#                print "el=",el, "isCn: ", isCompletelyNormal(el,F)\
#                        , " isPrimitive: ",(el.multiplicative_order()==orderE)
#                return False
#            return list(xC)
        return False
        powerTable = []
    return False


def findAnyPCN_useGen_internalC_wrapper(n):
    counter = 0
    border = n**4
    for p in primes(border):
        r = 1
        q = p**r
        while q < border:
            findAnyPCN_useGen_internalC(GF(q,'a'),Integer(n))
            print p,", ",r, " done"
            r += 1
            q = p**r
            counter += 1
            if counter > 100: return


def findAnyPCN_useGen_Py(n):
    counter = 0
    for p in primes(n**4):
        r = 1
        q = p**r
        while q < n**4:
            F = GF(q,'a')
            E = F.extension(Integer(n),'a')
            orderE = E.order()-1
            lastPower = 1
            curPower = 1
            pcnFound = False
            x = E.primitive_element()
            y = x
            while not pcnFound and curPower < orderE:
                curPower += 1
                if gcd(curPower, orderE) == 1:
                    y = y*x**(curPower-lastPower)
                    if isCompletelyNormal(y, F):
                        pcnFound = True
                        print p,'\t',r,'\t',y.minpoly()
                        break
                    lastPower = curPower
            r += 1
            q = p**r
            counter += 1


#def findAnyPCN_useTrinom(n):
#    counter = 0
#    for p in primes(n**4):
#        r = 1
#        q = p**r
#        while q < n**4:
#            F = GF(q,'a')
#            Fx = PolynomialRing(F,'x')
#            E = F.extension(Integer(n),'a')
#            orderE = E.order()-1
#            lastPower = 1
#            curPower = 1
#            pcnFound = False
#            primF = F.primitive_element()
#            for i in range(1,q):
#                if gcd(i,q-1) == 1:
#                    polyL[0] = primF**i
#                    for l in itertools.product(range(q):)
#            while not pcnFound and curPower < orderE:
#                curPower += 1
#                if gcd(curPower, orderE) == 1:
#                    y = y*x**(curPower-lastPower)
#                    if isCompletelyNormal(y, F):
#                        pcnFound = True
#                        print p,'\t',r,'\t',y.minpoly()
#                        break
#                    lastPower = curPower
#            r += 1
#            q = p**r
#            counter += 1


#
## helper to print C array
#cdef printArr(int *x, int m):
#    for i in range(m):
#        printf(" %i",x[i])
#    printf("\n")


# generates Matrices for powers [0..n-1] of Frobenius
# returns c_int matrix
def genMatsPy(E, F, n):
    q = F.order()
    mipo = E.modulus()
    P = E.prime_subfield()
    Px = mipo.parent()
    gen = Px.gen()
    m = int(E.order().log(E.characteristic()))
    mat = matrix(P, m,m)
    for i in xrange(m):
        for j, fi in enumerate(((gen**i)**q).mod(mipo)):
            mat[i,j] = fi
    cdef np.ndarray[int,ndim=3,mode="c"] matC
    matC = np.zeros((n,m,m), dtype=np.int32)
    for i in range(n):
        matPow = (mat**i).transpose()
        for j in range(m):
            for k in range(m):
                matC[i][j][k] = matPow[j][k]
    return matC

def get_padic_representation(number, p):
    ret = []
    q = number
    while q > 0:
        q,r = q.quo_rem(Integer(p));
        ret += [r]
    return list(reversed(ret))


#def findPCNElement(F,n):
#    TIME = time.clock();
#    p = F.characteristic()
#    q = F.order();
#    e = q.log(p)
#    E = F.extension(Integer(n),'a');
#    #generate factors
#    facAll = dict();
#    prodsAll = dict();
#    fieldsAll = dict();
#    # only consider factors obtained by the Decomposition Theorem
#    divs = get_proper_subfield_divisors(p,e,n)
#    #divs = divisors(n)
#    for d in divs:
#        G = F.extension(Integer(d), 'c');
#        Gx = PolynomialRing(G,'x');
#        fieldsAll[d] = G;
#        facAll[d] = list((Gx.gen()**(n/d)-1).factor());
#        prodsAll[d] = dict();
#        for idx, (f,mult) in enumerate(facAll[d]):
#            prodsAll[d][idx] = (Gx.gen()**(n/d)-1).quo_rem(f)[0]
#    #count all elements
#    hasPCN = False
#    TIME = (time.clock() - TIME)
#    num_processes = multiprocessing.cpu_count()
#    pool = Pool(num_processes)
#    for cn, pcn,t in pool.imap_unordered(func=_isCompletelyNormal\
#                , iterable=([x,F,q,divs,fieldsAll,facAll,prodsAll] for x in E) \
#                , chunksize=100):
#        if pcn == 1: 
#            hasPCN = True
#            break
#        TIME += t
#    pool.close()
#    pool.join()
#    if hasPCN:
#        return True, TIME/num_processes
#    return False, TIME/num_processes
#
#
#
#def countCNAndPCN_ggt(F,n):
#    TIME = time.clock();
#    p = F.characteristic()
#    q = F.order();
#    e = q.log(p)
#    E = F.extension(Integer(n),'a');
#    Ex = PolynomialRing(E,'x')
#    qn = q**n
#    #generate factors
#    facAll = dict();
#    prodsAll = dict();
#    fieldsAll = dict();
#    # only consider factors obtained by the Decomposition Theorem
#    divs = get_proper_subfield_divisors(p,e,n)
#    #divs = divisors(n)
#    #count all elements
#    countCN = 0;
#    countPCN = 0;
#    for idx,x in enumerate(E):
#        isCn = True
#        if x == 0: isCn = False
#        #test isNormal for each divisor
#        #  ---------------------------
#        pows = dict()
#        for d in divs:
#            if not isCn: break
#            if d == n: continue
#            e = n/d
#            g = Ex.zero()
#            iold = 0
#            xiold = x
#            for i in xrange(e):
#                if pows.has_key(i*d):
#                    xi = pows[i*d];
#                    iold = i*d
#                    xiold = xi
#                else:
#                    xi = xiold**(q**(d*i-iold));
#                    pows[i*d] = xi;
#                    xiold = xi
#                    iold = i*d
#                g += xi*Ex.gen()**(e-1-i)
#            if g.gcd(Ex.gen()**e-1) != 1: isCn = False
#        #  ---------------------------
#        if isCn: countCN += 1;
#        if isCn and x.multiplicative_order() == qn-1:
#            countPCN += 1;
#    return countCN, countPCN, (time.clock()-TIME)
#
## facs is list of polynoms 
## bins a list of 0,1 
## is bins is of shorter length then bins is headed by zeros
## returns product of facs where i-th factor is used iff bins[i] = 1
#def combinePolys(facs, bins):
#    b = (len(facs)-len(bins))*[0] + bins
#    ret = facs[0].parent().one();
#    for i in range(0,len(b)):
#        if b[i] == 1: ret = ret * facs[i]
#    return ret
#
#
#def dec_to_bin(x):
#    return map(int,bin(x)[2:])
#
#
#
# evaluate Frob of E|F in Polynom
# where
# f Polynom in Polynomialring over F
# x Element in E
# pows a list of powers of x, i.e. pows[i] = x^(q^i).
def frob_eval(f, x, pows = []):
  E = x.parent();
  P = f.parent();
  F = P.base_ring();
  R = PolynomialRing(E, 'z');
  q = F.order();
  n = E.order().log(q);
  #try:
      #h = Hom(F,E)[0];
      #f = f.map_coefficients(lambda i: h(i), E)
  #except: pass
  glist = f.list();
  ret = E.zero();
  for i,g in enumerate(glist):
      #print "frob: i=",i,"gi=",g
      if pows != []:
          if pows.has_key(i):
              xi = pows[i];
          else:
              xi = x**(q**i);
              pows[i] = xi;
      else: xi = x**(q**i);
      #print "\t->x^(q^i)=",xi
      try:
          ret += g*xi;
      except:
          h = Hom(F,E)[0];
          ret += h(g)*xi;
      #print "\t\t->ret=",ret

  #print floor((time.clock()-curTime)*1000),"ms";
  return ret;

#def _frob_eval(E, F, n, q, f, x, pows):
#    glist = f.list();
#    ret = E.zero();
#    for i,g in enumerate(glist):
#        if pows != []:
#            if pows.has_key(i):
#                xi = pows[i];
#            else:
#                xi = x**(q**i);
#                pows[i] = xi;
#        else: xi = x**(q**i);
#        try:
#            ret += g*xi;
#        except:
#            h = Hom(F,E)[0];
#            ret += h(g)*xi;
#
#    #print floor((time.clock()-curTime)*1000),"ms";
#    return ret;
#

#def geometricTest(p,e,n):
#    p = Integer(p)
#    e = Integer(e)
#    n = Integer(n)
#    q = p**e
#    subfield_divs = get_proper_subfield_divisors(p,e,n)
#    decomposition = decompose(p,e,n)
#
#    print "p = ",p," e = ",e, " n = ",n, " -> divs = ", subfield_divs
#    print "\twith decomposition    ", decomposition
#    print "\tand module characters ", \
#            map(lambda d: get_module_character(*d), decomposition)
#
#    decomp = decomposition[-1]
#    modChar = get_module_character(*decomp)
#    #print "consider decomp = ",decomp, "with modChar = ",modChar
#
#    F = GF(Integer(p**e),'a')
#    E = F.extension(Integer(n), 'b')
#
#    Fx = PolynomialRing(F,'x')
#    Ex = PolynomialRing(E,'x')
#
#    for decomp in decomposition:
#        k,t,pi = decomp
#        modChar = get_module_character(*decomp)
#        print "---------------------------"
#        print "consider decomp = ",decomp, "with modChar = ",modChar
#
#        if modChar == 1:
#            print "NOT GOOOD"
#            continue
#        K = F.extension(Integer(modChar),'b')
#        Kx = PolynomialRing(K,'x')
#        hK = Hom(K,E)[0]
#        print "find element with (K,sigma_K) = q^"+str(modChar)+" order "\
#                , (squarefree(k), k*t*pi/squarefree(k)/modChar)
#
#        print "splitting extension of ", (k,1), " is ", ordn(k,q)
#        if ordn(k,q**modChar) != 1:
#            print "\t=> BAD EXTENSION"
#            continue
#        
#        cycl = Kx.cyclotomic_polynomial(squarefree(k))\
#                (Kx.gen()**(k*t*pi/squarefree(k)/modChar))
#
#        print "cycl decompose in factors of deg = "\
#                ,euler_phi(squarefree(k))/ordn(squarefree(k),q**modChar)
#        print "first factor of cycl = ", cycl.factor()[0]
#        l = (-cycl.factor()[0][0][0]).multiplicative_order()
#        print "\twith multiplicative_order l = ", l
#        m = l*((q**modChar)-1)
#        print "look for l*(q^[K:F]-1) = "+str(m)+" th root of unity"
#        u = - Ex.cyclotomic_polynomial(m).factor()[0][0][0]
#        print "\t=>u has multiplicative_order = ", u.multiplicative_order()
#        lenCyclF = ordn(k,q)
#        print "split according factor scheme over F into factors of deg "\
#                ,lenCyclF
#        facsF = Fx.cyclotomic_polynomial(squarefree(k)).factor()
#        print "complete generator must have orders"\
#                , [(squarefree(k),k*t*pi/squarefree(k)/d) for d in divisors(modChar)]
#        totalGens = 1
#        for cos in cosets(k,q):
#            if cos[0] == 0: continue
#            cos = cos[1]
#            if not len(cos) == lenCyclF: continue
#            print "gens for cos ", cos, ":"
#            print "gens = u^",[i for i in cos]
#            print "test:"
#            gens = [u**i for i in cos]
#            g = Fx.one()
#            for f,i in facsF:
#                if tau_order(gens[0],F) == f.subs(x=Fx.gen()**(k*t*pi/squarefree(k))):
#                    g = f
#                    break
#            print "right factor is ("+str(g)+")(x^"+str(k*t*pi/squarefree(k))+")"
#            counter = 0
#            for x in itertools.product(K,repeat=len(gens)):
#                if any((i==0 for i in x)):
#                    continue
#                y = sum([hK(a)*b for (a,b) in zip(x,gens)])
#                #print tau_order(y,F)
#                isComplGen = True
#                for d in divisors(modChar)[:-1]:
#                    G = F.extension(d,'c')
#                    Gx = PolynomialRing(G,'x')
#                    hG = Hom(F,G)[0]
#                    #print tau_order(y,G), "  <=>  ", g.map_coefficients(hG).subs(x=Gx.gen()**(k*t*pi/squarefree(k)/d))
#                    if tau_order(y,G) != g.map_coefficients(hG).subs(x=Gx.gen()**(k*t*pi/squarefree(k)/d)):
#                        isComplGen = False
#                if isComplGen:
#                    counter += 1
#            print "==> compl gens: ", counter
#            totalGens *= counter
#        print "===> Num of Complete Generators for ",decomp,": ", totalGens
#
#
## calculate pi_m(q) = max{k: k | q, nu(k) | nu(m) }
#def pim(m,q):
#    num = squarefree(m);
#    for k in reversed(sage.all.divisors(q)):
#        if num%squarefree(k) == 0:
#            return k;
#
# computes the quadratic free part of an integer
def squarefree(n):
    return sage.all.prod(map(lambda x: x[0], sage.all.factor(Integer(n))))

# computes ordn m(q) = min{ k: q ** k = 1 mod m }
def ordn(m,q):
    if m == 1: return 1
    for i in range(1,m+1):
        if (q ** i)%m == 1: return i;

## returns the i-th Dickson-Polynom D_i(X,a) over the
## Polynomialring P
#def dickson(i,a, P):
#    if i == 0: return 2 * P.base_ring().gen();
#    if i == 1: return P.gen();
#    else: return P.gen() * dickson(i-1,a,P) - a * dickson(i-2,a,P)
#
#
#def gen_irred_dickson(n,P):
#    F = P.base_ring();
#    for a in F:
#        for b in F:
#            if a == 0 or b == 0: continue;
#            f = dickson(n,a,P) - b;
#            if f.is_irreducible(): return a, b, f;
#
#
## calcs V_g as subset of E where g is irreducible(!), monic divisor of 
## a Phi_n(x) over F
#def calc_V_g(n,g):
#    Fx = g.parent();
#    F = Fx.base_ring();
#    q = F.order();
#    s = ordn(squarefree(n),q)
#    l = pim(n,q**s-1);
#    E = F.extension(Fx.cyclotomic_polynomial(n*l).factor()[0][0],'u');
#    u = E.gen();
#    print "---- Calc V_g for"
#    print "\tg =",g
#    print "\t F = GF("+str(q)+"); "+\
#            "E = GF(q^(n*l)) = GF(q^("+str(n)+"*"+str(l)+"))=",E
#    print "where u is primitive n*l="+str(n*l)+" root of unity,",\
#            multiplicative_order(u) == n*l;
#    print "Minpoly(u) =", u.minpoly();
#    for f in Fx.monics(g.degree()):
#        v = frob_eval(f,u);
#        print "f.u == (f mod g).u", v == frob_eval(f.mod(g),u);
#        #print "f=", f, "f.u=",v, \
#                #"\tOrd_q(v)=",tau_order(v,F),\
#                #" == ", tau_order(frob_eval(f.mod(g),u),F);
#        #print "f=",f, " f.u =",v, \
#                #"\tOrd_q(v) =", tau_order(v,F),\
#                #"\tMinpol(f.u) =", v.minpoly();
#        #print "\tord(v) =", multiplicative_order(v).factor();
#
#def multiplicative_order(x):
#    try:
#        return x.multiplicative_order();
#    except:
#        for i in range(1,1000):
#            if x**i == 1: return Integer(i);
#    return Integer(1);
#
#
## finds minimal polynomial for BINOM f
## i.e. if f = X^k - b it returns prod_(i=0)^(s-1) (X^k - b^(frobPower^i))
#def mipo(q,s,f):
#    P = f.parent();
#    ret = P.one();
#    b = f[0];
#    k = f.degree();
#    x = P.gen();
#    for i in range(0,s):
#        ret = ret * (x**k - (-b)**(q**i))
#    return ret;
#
#
## computes Trace_(E | F) (x)
#def trace(E,F,x):
#    #E = x.parent();
#    ret = E.zero();
#    q = F.order();
#    n = E.order().log(q);
#    xi = x;
#    ret = x;
#    for i in range(1,n):
#        xi = xi**q;
#        ret = ret + xi;
#    Fx = PolynomialRing(F,'x');
#    return F(Fx.gen()-Fx(ret.minpoly('x')).factor()[0][0]);
#    #retSubs = re.sub(str(E.gen()), 'x', str(ret));
#    #for h in Hom(F,E):
#        #hSubs = re.sub(str(E.gen()), 'x', str(h(F.gen())));
#        #Fx = PolynomialRing(F,'x');
#        #f = Fx(hSubs+'-'+str(F.gen()));
#        #print "ret  = ", ret;
#        #print "f = ", f;
#        #print "ret.mod(f) = ", Fx(retSubs).mod(f);
#        #if Fx(retSubs).mod(f).is_constant():
#            #return F(Fx(retSubs).mod(f));
#
def cosets(n,q):
   L = []
   Ls = []
   l = ordn(n,q)
   for k in range(0,n):
       cs = coset_l(n,q,k);
       if not cs in Ls: #and len(cs) == l:
           Ls = Ls + [cs];
           L = L + [(k,cs)];
   return L

def coset_l(n,q,l):
   return sorted(list(set(map(lambda i: (l*q**i)%n, range(0,n)))));

def print_cosets(n,q):
   for (k,cs) in cosets(n,q):
       print k, cs

#
#def isNormal_bruteforce(x,F):
#    E = x.parent();
#    q = F.order();
#    n = E.order().log(q);
#    l = ordn(n,q);
#    Fx = PolynomialRing(F,'x');
#    S = set();
#    for i in xrange(0,n):
#        for f in Fx.monics(i):
#            for e in F:
#                S.add(sum(map(lambda fi: fi[0]*x**(q**fi[1]) , zip(list(f+e*Fx.gen()), xrange(0,100)))))
#    if len(S) == E.order():
#        return True;
#    return False;
#
#
# Application of the Decomposition Theorem (Section 19)
# for x^n-1 over F_p^e
def decompose(p,e, n):
    pi = largestDiv(p,n)
    return decompose_cycl_module(p,e, 1, n/pi, pi)


## returns the module characters of a decomposition
## the module character of U_F,Phi_k(x^t) is k*t / nu(k)
def get_module_characters(decomp):
   return uniq(map(lambda l: l[0]*l[1]*l[2] / squarefree(l[0]),decomp))

# returns the module characters of a cyclotomic module
# the module character of U_F,Phi_k(x^t)^pi is k*t*pi / nu(k)
def get_module_character(k,t,pi):
    return Integer(k*t*pi/squarefree(k))

# returns all divisors of the module characters of an extension
# capped with the complete basic divisors
# i.e. all intermediate fields that must be considered
def get_proper_subfield_divisors(p,e, n):
    basList = get_completely_basic_divisors(p,e,n)
    return filter(lambda d: d in basList, \
            list(uniq(itertools.chain(*map(divisors,\
           get_module_characters(decompose(p,e,n)))))))


# internal application of the Decomposition Theorem
# for Phi_k(x^(t*pi)) over F_p^e
def decompose_cycl_module(p,e, k,t,pi):
    if p.divides(k*t): print "ERROR p | kt"
    #test all prime divisors, start with largest one
    flag = False
    for r,l in reversed(factor(t)):
        if not (r**l).divides(ordn(squarefree(k*t),p**e)):
            R = largestDiv(r,t)
            return decompose_cycl_module(p,e, k, t/r, pi) + decompose_cycl_module(p,e, k*R, t/R, pi)
    return [(k,t,pi)]



# returns the largest power of p dividing n
def largestDiv(p,n):
    l = 0
    while (p**l).divides(n):
        l = l+1
    return p**(l-1);


def get_completely_basic_divisors(p,e,n):
    n = Integer(n)
    q = Integer(p**e)
    divs = []
    for d in divisors(n):
        isComplBasic = True
        for r in prime_divisors(n/d):
            if r.divides(ordn(p_free_part(n/d/r,p),q**d)):
                isComplBasic = False
                break
        divs += [d]
        if isComplBasic: return divs
    return divs



# p-free part of t
def p_free_part(t,p):
    while p.divides(t):
        t /= p
    return t




# formats timedelta objects to nice string
def strfdelta(tdelta):
    d = {}
    d["hours"], rem = divmod(tdelta.seconds, 3600)
    d["hours"] += int(tdelta.days*24)
    d["minutes"], d["seconds"] = divmod(rem, 60)
    return "{hours}:{minutes}:{seconds}".format(**d)





##############################################################################
def powertestPy():
    F = GF(6007)
    E = F.extension(Integer(30),'a')
    x = E([1,1,1,1,1,1,1,1,1,1,1,1,1,1,1])
    return x**1695074347458169655952410436001



cdef extern from "./powertest.c":
    void matmulTest(int *mipo, \
        int *polys, int *polysLen, int *polysCoeffDegs, \
        int polysCount, \
        int *mats, int matLen, int *frobPowers, \
        int m, int charac, \
        int *multTable, int initialMultShift, \
        int *addTable, int initialAddShift)
    

def matmulTest_wrapper():
    F = GF(3)
    Fx = PolynomialRing(F,'x')
    n = Integer(20)
    p = F.characteristic()
    q = F.order();
    e = q.log(p)
    E = F.extension(Integer(n),'a');
    P = E.prime_subfield()
    #generate factors
    polys = []
    polysLen = []
    polysCount = 0
    polysCoeffDegs = []
    evalToZero = []
    frobPowers = []
    countPolysForThisDecomp = 0
    cycl = Fx('x^20-1')
    h = Hom(F,E)[0]
    for f,mult in cycl.factor():
        g = cycl.quo_rem(f)[0]
        gE = g.map_coefficients(h)
        #print "\tgE=",gE
        polys += [gE]
        polysLen += [len(list(g))]
        polysCoeffDegs += map(lambda gi: gi.polynomial().degree(), gE)
        #print "\tcoeffDegs=", map(lambda gi: gi.polynomial().degree(), gE) 
        frobPowers += [1]
        evalToZero += [0]
        polysCount +=1

        # multiplication and addition table for prime field
    multTable = [0]*(2*(p-1)**2+1)
    addTable = [0]*(2*2*(p-1)+1)
    for i in range(-p+1,p):
        for j in range(-p+1,p):
            #print i,"*",j, " = ", (i*j+p**2)%p
            multTable[(p-1)**2 + i*j] = (i*j+p**2)%p
            addTable[2*(p-1) + i+j] = (i+j + 2*p)%p
    #print "multTable=",multTable, " len=", len(multTable)
    #print "addTable=", addTable, " len=", len(addTable)

    
    #--------------------
    #setup C data
    charac = int(E.characteristic())
    mipo = E.modulus()
    m = mipo.degree()
    maxMatPower = n
    #setup matrices
    cdef np.ndarray[int,ndim=3,mode="c"] matsC
    matsC = genMatsPy(E,F,maxMatPower+1)
    #setup mipo
    cdef np.ndarray[int,ndim=1,mode="c"] xmipoC \
            = np.array(list(mipo), dtype=np.int32)
    #setup polynomials, polyLength, frobPowers, evaltoZero
        #evalToZeroC
    cdef np.ndarray[char,ndim=1,mode="c",cast=True] evalToZeroC\
            = np.array(evalToZero, dtype=np.uint8)
        #frobPowersC
    cdef np.ndarray[int,ndim=1,mode="c"] frobPowersC\
            = np.array(frobPowers, dtype=np.int32)
        #polysCoeffDegsC
    cdef np.ndarray[int,ndim=1,mode="c"] polysCoeffDegsC\
            = np.array(polysCoeffDegs, dtype=np.int32)
        #polysLenC
    cdef np.ndarray[int,ndim=1,mode="c"] polysLenC\
            = np.array(polysLen, dtype=np.int32)
        #polys
    cdef np.ndarray[int,ndim=2,mode="c"] polysC\
            = np.zeros((sum(polysLen),m), dtype=np.int32)
    curPos = 0
    for idx,g in enumerate(polys):
        g = map(lambda gi: list(gi.polynomial()),list(g))
        for i in range(len(g)):
            for j in range(len(g[i])):
                polysC[curPos+i][j] = <int>g[i][j]
        curPos += polysLen[idx]
        # multiplication and addition table
    cdef np.ndarray[int,ndim=1,mode="c"] multTableC\
        = np.array(multTable, dtype=np.int32)
    cdef np.ndarray[int,ndim=1,mode="c"] addTableC\
        = np.array(addTable, dtype=np.int32)

    #end setup C data
    #--------------------

    matmulTest(<int*>xmipoC.data \
            ,<int*>polysC.data, <int*>polysLenC.data \
            ,<int*>polysCoeffDegsC.data \
            ,<int>polysCount \
            ,<int*>matsC.data, <int>maxMatPower+1, <int*>frobPowersC.data \
            ,<int>m,<int>p \
            ,<int*>multTableC.data, <int>(p-1)**2\
            ,<int*>addTableC.data, <int>2*(p-1))

    
cdef extern from "./powertest.c":
    void primitiveTest(int *mipo, \
            int m, int charac,\
            int *barFactors, int *lenBarFactors, int countBarFactors, \
            int *biggestPrimeFactor, int lenBiggestPrimeFactor,\
            int *matCharac, \
            int *multTable, int initialMultShift,\
            int *addTable, int initialAddShift) 
    void primitiveTest_2(int *mipo, int *idcsMipo, int lenMipo, \
        int m, int charac, \
        int *barFactors, int *lenBarFactors, int countBarFactors,  \
        int *biggestPrimeFactor, int lenBiggestPrimeFactor, \
        int *matCharac, int *idcsMatCharac, int *lenMatCharac, \
        int *multTable, int initialMultShift, \
        int *addTable, int initialAddShift)



def primitiveTest_wrapper():
    #F = GF(next_prime(6000))
    F = GF(3)
    P = F.prime_subfield()
    Fx = PolynomialRing(F,'x')
    n = Integer(20)
    p = F.characteristic()
    q = F.order();
    e = q.log(p)
    E = F.extension(Integer(n),'a');
    P = E.prime_subfield()
    
    charac = int(E.characteristic())
        #mipo, idcsMipo
    mipo = E.modulus()
    m = mipo.degree()
    idcsMipo = []
    listMipo = list(mipo)
    for i in range(m,-1,-1):
        if listMipo[i] != 0:
            idcsMipo += [i]
    lenMipo = len(idcsMipo)
        #calc prime factors of order
    barFactors = []
    primitiveOrder = E.order()-1
    #for r,k in factor(primitiveOrder):
        #for i in range(1,k+1):
            #barFactors += [primitiveOrder/(r**i)]
    biggestPrimeFactor = factor(primitiveOrder)[-1][0]
    for r,k in factor(primitiveOrder):
        barFactors += [primitiveOrder/r]
    countBarFactors = len(barFactors)
    #print "barFactors=", barFactors
    curF = 0
    barFactors_tmp = [barFactors[-1]]
    for b in reversed(barFactors[:-1]):
        barFactors_tmp += [ b/biggestPrimeFactor - curF]
        curF = b/biggestPrimeFactor
    barFactors = barFactors_tmp
    #print "barFactors=", barFactors
    #print "biggestPrimeFactor=", biggestPrimeFactor
    barFactors = map(\
            lambda b: get_padic_representation(Integer(b),Integer(p))\
            ,barFactors)
    biggestPrimeFactor = get_padic_representation(biggestPrimeFactor,Integer(p))
    lenBiggestPrimeFactor = len(biggestPrimeFactor)
        #find biggest gap (i.e. zero-interval)
    lenBiggestZeroGap = 0
    lenCurGap = 0
    for b in barFactors+[biggestPrimeFactor]:
        i = 0
        while i < len(b):
            lenCurGap = 0
            while i<len(b) and b[i] == 0:
                lenCurGap+= 1
                i += 1
            lenBiggestZeroGap = max(lenBiggestZeroGap, lenCurGap)
            i += 1

        ## multiplication and addition table for prime field
    #multTable = [0]*(2*(p-1)**2+1)
    #addTable = [0]*(2*2*(p-1)+1)
    #for i in range(-p+1,p):
        #for j in range(-p+1,p):
            ##print i,"*",j, " = ", (i*j+p**2)%p
            #multTable[(p-1)**2 + i*j] = (i*j+p**2)%p
            #addTable[2*(p-1) + i+j] = (i+j + 2*p)%p
    #print "multTable=",multTable, " len=", len(multTable)
    #print "addTable=", addTable, " len=", len(addTable)
    ps = range(p)
    addTable = ps[P(-2*(p-1)):] + ps*2 + ps[:Integer(P(2*(p-1)))+1]
    multTable = ps[P(-(p-1)**2):] + ps*(2*(p-2)) + ps[:Integer(P((p-1)**2))+1]

    
    #--------------------
    #setup C data
    #setup mipo
    cdef np.ndarray[int,ndim=1,mode="c"] xmipoC \
            = np.array(listMipo, dtype=np.int32)
    cdef np.ndarray[int,ndim=1,mode="c"] idcsMipoC\
            = np.array(idcsMipo, dtype=np.int32)
    #setup polynomials, polyLength, frobPowers, evaltoZero
        # multiplication and addition table
    cdef np.ndarray[int,ndim=1,mode="c"] multTableC\
        = np.array(multTable, dtype=np.int32)
    cdef np.ndarray[int,ndim=1,mode="c"] addTableC\
        = np.array(addTable, dtype=np.int32)
        
        # prime Factors
    cdef np.ndarray[int,ndim=1,mode="c"] barFactorsC \
        = np.array(list(itertools.chain(*barFactors)), dtype=np.int32)
    cdef np.ndarray[int,ndim=1,mode="c"] lenBarFactorsC \
        = np.array(map(len,barFactors), dtype=np.int32)
    cdef np.ndarray[int,ndim=1,mode="c"] biggestPrimeFactorC \
        = np.array(biggestPrimeFactor, dtype=np.int32)
        # mat charac
    P = E.prime_subfield()
    gen = mipo.parent().gen()
    matCharac = matrix(P, m,m)
    for i in xrange(m):
        for j, fi in enumerate(((gen**i)**p).mod(mipo)):
            matCharac[i,j] = fi
    matCharac = matCharac.transpose()
    cdef np.ndarray[int,ndim=3,mode="c"] matCharacC\
        = np.zeros((lenBiggestZeroGap+1,m,m), dtype=np.int32)
    tmpMat = matCharac
    for i in range(lenBiggestZeroGap+1):
        tmpMat = matCharac**(i+1)
        for j in range(m):
            for k in range(m):
                matCharacC[i][j][k] = tmpMat[j][k]
    idcsMatCharac = []
    lenMatCharac = []
    for i in range(lenBiggestZeroGap+1):
        for j in range(m):
            countCurRow = 0
            for k in range(m):
                if matCharacC[i][j][k] != 0:
                    idcsMatCharac += [k]
                    countCurRow += 1
            lenMatCharac += [countCurRow]
    cdef np.ndarray[int,ndim=1,mode="c"] idcsMatCharacC \
        = np.array(idcsMatCharac, dtype=np.int32)
    cdef np.ndarray[int,ndim=1,mode="c"] lenMatCharacC \
        = np.array(lenMatCharac, dtype=np.int32)



    #print "matCharac = ",matCharacC
    #print "multTable=",multTable
    #print "addTable=",addTable
    #print "lenBarFactors=", lenBarFactorsC
    #print "lenBiggestPrimeFactor=", lenBiggestPrimeFactor
    #end setup C data
    #--------------------

    print "------------------ primitive test"
    primitiveTest(<int*>xmipoC.data \
            ,<int>m,<int>p \
            ,<int*>barFactorsC.data, <int*>lenBarFactorsC.data \
            ,<int>countBarFactors \
            ,<int*>biggestPrimeFactorC.data, <int>lenBiggestPrimeFactor \
            ,<int*>matCharacC.data \
            ,<int*>multTableC.data, <int>(p-1)**2\
            ,<int*>addTableC.data, <int>2*(p-1))
    
    print "------------------ primitive test 2"
    primitiveTest_2(<int*>xmipoC.data, <int*>idcsMipoC.data, <int>lenMipo \
            ,<int>m,<int>p \
            ,<int*>barFactorsC.data, <int*>lenBarFactorsC.data \
            ,<int>countBarFactors \
            ,<int*>biggestPrimeFactorC.data, <int>lenBiggestPrimeFactor \
            ,<int*>matCharacC.data, <int*>idcsMatCharacC.data \
            ,<int*>lenMatCharacC.data \
            ,<int*>multTableC.data, <int>(p-1)**2\
            ,<int*>addTableC.data, <int>2*(p-1))
