from sage.all import *
import re
import time
from multiprocessing import Pool
import itertools

def isNormal(x, F):
    E = x.parent();
    q = F.order();
    n = E.order().log(q);
    m = matrix(E, n,n, lambda i, j: x**(q**(i+j)));
    return m.is_invertible();


def tau_order_old(x,F, factors=[]):
    E = x.parent();
    q = F.order();
    n = E.order().log(q);
    fac = factors;
    if fac == []:
        Fx = PolynomialRing(F,'x');
        for (f,i) in (Fx.gen()**n-1).factor():
            fac = fac + [f]*i
    #print fac
    for i in range(0,2**len(fac)):
        f = combinePolys(fac, dec_to_bin(i));
        #print "\tf = ", f, "\tfrob_eval(f,x) = ", frob_eval(f,x)
        if frob_eval(f,x) == 0: 
            return f;



def tau_order(x,F, factors=[], prods=[]):
    Fx = PolynomialRing(F,'x');
    E = x.parent();
    q = F.order();
    n = E.order().log(q);
    if factors == []:
        fac = (Fx.gen()**n-1).factor();
    else:
        fac = factors;
    pows = dict();
    pre = [];
    for idx,(f,mult) in enumerate(fac):
        for j in xrange(mult-1,-1,-1):
            g = f.parent().one();
            ev = pre + [j] + map(lambda i: i[1], fac[idx+1:]);
            if prods == []:
                #generate factor
                for kidx, k in enumerate(ev):
                    g *= fac[kidx][0]**k;
            else:
                g = prods[str(ev)];
            ret = E.zero();
            for i,g in enumerate(list(g)):
                if pows != []:
                    if pows.has_key(i):
                        xi = pows[i];
                    else:
                        xi = x**(q**i);
                        pows[i] = xi;
                else: xi = x**(q**i);
                try:
                    ret += g*xi;
                except:
                    h = Hom(F,E)[0];
                    ret += h(g)*xi;
            if ret != 0:
                pre += [j+1]; 
                break;
            elif j == 0: 
                pre += [0];
    if prods == []:
        g = f.parent().one();
        for jidx, j in enumerate(pre):
            g *= fac[jidx][0]**j;
        return g;
    else:
        return prods[str(pre)];

def isNormal(x,F, factors=[], prods=[]):
    E = x.parent();
    q = F.order();
    n = E.order().log(q);
    Fx = PolynomialRing(F,'x');
    if factors == []:
        fac = (Fx.gen()**n-1).factor();
    else: fac = factors;
    pows = dict();
    for idx,(f,mult) in enumerate(fac):
        # generate product key
        ev = map(lambda i: fac[i][1], xrange(idx)) + \
                [0] + map(lambda i: i[1], fac[idx+1:]); 
        if prods != [] and prods.has_key(str(ev)):
            g = prods[str(ev)];
        else: #generate factor manually
            g = f.parent().one();
            for jidx, j in enumerate(ev):
                g *= fac[jidx][0]**j;
        ret = E.zero();
        iold = 0
        xiold = x
        for i,g in enumerate(list(g)):
            if pows.has_key(i):
                xi = pows[i];
                iold = i
                xiold = xi
            else:
                xi = xiold**(q**(i-iold));
                pows[i] = xi;
                xiold = xi
                iold = i
            try:
                ret += g*xi;
            except:
                h = Hom(F,E)[0];
                ret += h(g)*xi;
        if ret == 0: return False;
    return True;

def isCompletelyNormal(x,F, fieldsAll=[], facAll=[], prodsAll=[]):
    E = x.parent();
    q = F.order();
    n = E.order().log(q);
    divs = divisors(n);
    if facAll == []:
        facAll = dict();
        prodsAll = dict();
        fieldsAll = dict();
        for d in divs:
            G = F.extension(d, 'c');
            Gx = PolynomialRing(G,'x');
            fieldsAll[d] = G;
            facAll[d] = list((Gx.gen()**(n/d)-1).factor());
            prodsAll[d] = dict();
            for idx,(f,mult) in enumerate(facAll[d]):
                ev = map(lambda i: facAll[d][i][1], xrange(idx)) + \
                    [facAll[d][idx][1]-1] + map(lambda i: i[1], facAll[d][idx+1:]); 
                pr = Gx.one();
                for jidx, j in enumerate(ev):
                    pr *= facAll[d][jidx][0]**j;
                prodsAll[d][str(ev)] = pr;
    #test isNormal for each divisor
    pows = dict()
    for d in divs[:len(divs)-1]:
        h = Hom(fieldsAll[d],E)[0];
        for idx,(f,mult) in enumerate(facAll[d]):
            # generate product key
            ev = map(lambda i: facAll[d][i][1], xrange(idx)) + \
                [facAll[d][idx][1]-1] + map(lambda i: i[1], facAll[d][idx+1:]); 
            g = prodsAll[d][str(ev)];
            ret = E.zero();
            iold = 0
            xiold = x
            for i,gi in enumerate(list(g)):
                if pows.has_key(i*d):
                    xi = pows[i*d];
                    iold = i*d
                    xiold = xi
                else:
                    xi = xiold**(q**(d*i-iold));
                    pows[i*d] = xi;
                    xiold = xi
                    iold = i*d
                try:
                    ret += gi*xi;
                except:
                    ret += h(gi)*xi;
            if ret == 0: return False;
    return True


def isCompletelyNormal_ggt(x,F):
    if x == 0: return False
    E = x.parent();
    q = F.order();
    n = E.order().log(q);
    Ex = PolynomialRing(E,'x');
    for d in divisors(n):
        e = n/d;
        xem1 = Ex.gen()**e-1;
        f = Ex.one();
        for i in xrange(e):
            f += x**(q**(d*(e-1-i)))*Ex.gen()**i
        if xem1.gcd(f) != 1:
            return False
    return True


def countCNAndPCN_parallel(F,n):
    TIME = time.clock()
    q = F.order();
    E = F.extension(Integer(n),'a');
    #generate factors
    facAll = dict();
    prodsAll = dict();
    fieldsAll = dict();
    divs = divisors(n);
    for d in divs:
        G = F.extension(d, 'c');
        Gx = PolynomialRing(G,'x');
        fieldsAll[d] = G;
        facAll[d] = list((Gx.gen()**(n/d)-1).factor());
        prodsAll[d] = dict();
        for idx,(f,mult) in enumerate(facAll[d]):
            ev = map(lambda i: facAll[d][i][1], xrange(idx)) + \
                    [facAll[d][idx][1]-1] + map(lambda i: i[1], facAll[d][idx+1:]); 
            pr = Gx.one();
            for jidx, j in enumerate(ev):
                pr *= facAll[d][jidx][0]**j;
            prodsAll[d][str(ev)] = pr;
    #count all elements
    pool = Pool()
    results = pool.map(_isCompletelyNormal, \
                itertools.izip(E\
                , itertools.repeat(F)\
                , itertools.repeat(q)\
                , itertools.repeat(divs)\
                , itertools.repeat(fieldsAll)\
                , itertools.repeat(facAll)\
                , itertools.repeat(prodsAll)))
    countCN, countPCN = zip(*results)
    return sum(countCN), sum(countPCN), (time.clock()-TIME)


def _isCompletelyNormal(data):
    x = data[0]
    E = x.parent()
    F = data[1]
    q = data[2]
    divs = data[3]
    fieldsAll = data[4]
    facAll = data[5]
    prodsAll = data[6]
    countCN = 0
    countPCN = 0
    isCn = True
    #test isNormal for each divisor
    #  ---------------------------
    pows = dict()
    for d in divs[:len(divs)-1]:
        if not isCn: break
        for idx,(f,mult) in enumerate(facAll[d]):
            if not isCn: break
            # generate product key
            ev = map(lambda i: facAll[d][i][1], xrange(idx)) + \
                    [facAll[d][idx][1]-1] + map(lambda i: i[1], facAll[d][idx+1:]); 
            g = prodsAll[d][str(ev)];
            ret = E.zero();
            iold = 0
            xiold = x
            for i,gi in enumerate(list(g)):
                h = Hom(fieldsAll[d],E)[0];
                if pows.has_key(i*d):
                    xi = pows[i*d];
                    iold = i*d
                    xiold = xi
                else:
                    xi = xiold**(q**(d*i-iold));
                    pows[i*d] = xi;
                    xiold = xi
                    iold = i*d
                try:
                    ret += gi*xi;
                except:
                    ret += h(gi)*xi;
            if ret == 0: isCn = False;
    #  ---------------------------
    if isCn: countCN += 1;
    if isCn and x.multiplicative_order() == E.order()-1:
        countPCN += 1;
    return countCN, countPCN



def countCNAndPCN(F,n):
    TIME = time.clock();
    q = F.order();
    E = F.extension(Integer(n),'a');
    #generate factors
    facAll = dict();
    prodsAll = dict();
    fieldsAll = dict();
    divs = divisors(n);
    for d in divs:
        G = F.extension(d, 'c');
        Gx = PolynomialRing(G,'x');
        fieldsAll[d] = G;
        facAll[d] = list((Gx.gen()**(n/d)-1).factor());
        prodsAll[d] = dict();
        for idx,(f,mult) in enumerate(facAll[d]):
            ev = map(lambda i: facAll[d][i][1], xrange(idx)) + \
                    [facAll[d][idx][1]-1] + map(lambda i: i[1], facAll[d][idx+1:]); 
            pr = Gx.one();
            for jidx, j in enumerate(ev):
                pr *= facAll[d][jidx][0]**j;
            prodsAll[d][str(ev)] = pr;
    #count all elements
    countCN = 0;
    countPCN = 0;
    for idx,x in enumerate(E):
        isCn = True
        #test isNormal for each divisor
        #  ---------------------------
        pows = dict()
        for d in divs[:len(divs)-1]:
            if not isCn: break
            for idx,(f,mult) in enumerate(facAll[d]):
                if not isCn: break
                # generate product key
                ev = map(lambda i: facAll[d][i][1], xrange(idx)) + \
                        [facAll[d][idx][1]-1] + map(lambda i: i[1], facAll[d][idx+1:]); 
                g = prodsAll[d][str(ev)];
                ret = E.zero();
                iold = 0
                xiold = x
                for i,gi in enumerate(list(g)):
                    h = Hom(fieldsAll[d],E)[0];
                    if pows.has_key(i*d):
                        xi = pows[i*d];
                        iold = i*d
                        xiold = xi
                    else:
                        xi = xiold**(q**(d*i-iold));
                        pows[i*d] = xi;
                        xiold = xi
                        iold = i*d
                    try:
                        ret += gi*xi;
                    except:
                        ret += h(gi)*xi;
                if ret == 0: isCn = False;
        #  ---------------------------
        if isCn: countCN += 1;
        if isCn and x.multiplicative_order() == E.order()-1:
            countPCN += 1;
    return countCN, countPCN, (time.clock()-TIME)


def findPCNElement(F,n):
    TIME = time.clock();
    q = F.order();
    E = F.extension(Integer(n),'a');
    #generate factors
    facAll = dict();
    prodsAll = dict();
    fieldsAll = dict();
    divs = divisors(n);
    for d in divs:
        G = F.extension(d, 'c');
        Gx = PolynomialRing(G,'x');
        fieldsAll[d] = G;
        facAll[d] = list((Gx.gen()**(n/d)-1).factor());
        prodsAll[d] = dict();
        for idx,(f,mult) in enumerate(facAll[d]):
            ev = map(lambda i: facAll[d][i][1], xrange(idx)) + \
                    [facAll[d][idx][1]-1] + map(lambda i: i[1], facAll[d][idx+1:]); 
            pr = Gx.one();
            for jidx, j in enumerate(ev):
                pr *= facAll[d][jidx][0]**j;
            prodsAll[d][str(ev)] = pr;
    #count all elements
    countCN = 0;
    countPCN = 0;
    for idx,x in enumerate(E):
        isCn = True
        #test isNormal for each divisor
        #  ---------------------------
        pows = dict()
        for d in divs[:len(divs)-1]:
            if not isCn: break
            for idx,(f,mult) in enumerate(facAll[d]):
                if not isCn: break
                # generate product key
                ev = map(lambda i: facAll[d][i][1], xrange(idx)) + \
                        [facAll[d][idx][1]-1] + map(lambda i: i[1], facAll[d][idx+1:]); 
                g = prodsAll[d][str(ev)];
                ret = E.zero();
                iold = 0
                xiold = x
                for i,gi in enumerate(list(g)):
                    h = Hom(fieldsAll[d],E)[0];
                    if pows.has_key(i*d):
                        xi = pows[i*d];
                        iold = i*d
                        xiold = xi
                    else:
                        xi = xiold**(q**(d*i-iold));
                        pows[i*d] = xi;
                        xiold = xi
                        iold = i*d
                    try:
                        ret += gi*xi;
                    except:
                        ret += h(gi)*xi;
                if ret == 0: isCn = False;
        #  ---------------------------
        if isCn and x.multiplicative_order() == E.order()-1:
            return x
    return False



# facs is list of polynoms 
# bins a list of 0,1 
# is bins is of shorter length then bins is headed by zeros
# returns product of facs where i-th factor is used iff bins[i] = 1
def combinePolys(facs, bins):
    b = (len(facs)-len(bins))*[0] + bins
    ret = facs[0].parent().one();
    for i in range(0,len(b)):
        if b[i] == 1: ret = ret * facs[i]
    return ret


def dec_to_bin(x):
    return map(int,bin(x)[2:])



# evaluate Frob of E|F in Polynom
# where
# f Polynom in Polynomialring over F
# x Element in E
# pows a list of powers of x, i.e. pows[i] = x^(q^i).
def frob_eval(f, x, pows = []):
    E = x.parent();
    P = f.parent();
    F = P.base_ring();
    R = PolynomialRing(E, 'z');
    q = F.order();
    n = E.order().log(q);
    #try:
        #h = Hom(F,E)[0];
        #f = f.map_coefficients(lambda i: h(i), E)
    #except: pass
    glist = f.list();
    ret = E.zero();
    for i,g in enumerate(glist):
        print "frob: i=",i,"gi=",g
        if pows != []:
            if pows.has_key(i):
                xi = pows[i];
            else:
                xi = x**(q**i);
                pows[i] = xi;
        else: xi = x**(q**i);
        print "\t->x^(q^i)=",xi
        try:
            ret += g*xi;
        except:
            h = Hom(F,E)[0];
            ret += h(g)*xi;
        print "\t\t->ret=",ret

    #print floor((time.clock()-curTime)*1000),"ms";
    return ret;

def _frob_eval(E, F, n, q, f, x, pows):
    glist = f.list();
    ret = E.zero();
    for i,g in enumerate(glist):
        if pows != []:
            if pows.has_key(i):
                xi = pows[i];
            else:
                xi = x**(q**i);
                pows[i] = xi;
        else: xi = x**(q**i);
        try:
            ret += g*xi;
        except:
            h = Hom(F,E)[0];
            ret += h(g)*xi;

    #print floor((time.clock()-curTime)*1000),"ms";
    return ret;

# calculate pi_m(q) = max{k: k | q, nu(k) | nu(m) }
def pim(m,q):
    num = squarefree(m);
    for k in reversed(sage.all.divisors(q)):
        if num%squarefree(k) == 0:
            return k;

# computes the quadratic free part of an integer
def squarefree(n):
    return sage.all.prod(map(lambda x: x[0], sage.all.factor(Integer(n))))

# computes ordn m(q) = min{ k: q ** k = 1 mod m }
def ordn(m,q):
    for i in range(1,m+1):
        if (q ** i)%m == 1: return i;

# returns the i-th Dickson-Polynom D_i(X,a) over the
# Polynomialring P
def dickson(i,a, P):
    if i == 0: return 2 * P.base_ring().gen();
    if i == 1: return P.gen();
    else: return P.gen() * dickson(i-1,a,P) - a * dickson(i-2,a,P)


def gen_irred_dickson(n,P):
    F = P.base_ring();
    for a in F:
        for b in F:
            if a == 0 or b == 0: continue;
            f = dickson(n,a,P) - b;
            if f.is_irreducible(): return a, b, f;


# calcs V_g as subset of E where g is irreducible(!), monic divisor of 
# a Phi_n(x) over F
def calc_V_g(n,g):
    Fx = g.parent();
    F = Fx.base_ring();
    q = F.order();
    s = ordn(squarefree(n),q)
    l = pim(n,q**s-1);
    E = F.extension(Fx.cyclotomic_polynomial(n*l).factor()[0][0],'u');
    u = E.gen();
    print "---- Calc V_g for"
    print "\tg =",g
    print "\t F = GF("+str(q)+"); "+\
            "E = GF(q^(n*l)) = GF(q^("+str(n)+"*"+str(l)+"))=",E
    print "where u is primitive n*l="+str(n*l)+" root of unity,",\
            multiplicative_order(u) == n*l;
    print "Minpoly(u) =", u.minpoly();
    for f in Fx.monics(g.degree()):
        v = frob_eval(f,u);
        print "f.u == (f mod g).u", v == frob_eval(f.mod(g),u);
        #print "f=", f, "f.u=",v, \
                #"\tOrd_q(v)=",tau_order(v,F),\
                #" == ", tau_order(frob_eval(f.mod(g),u),F);
        #print "f=",f, " f.u =",v, \
                #"\tOrd_q(v) =", tau_order(v,F),\
                #"\tMinpol(f.u) =", v.minpoly();
        #print "\tord(v) =", multiplicative_order(v).factor();

def multiplicative_order(x):
    try:
        return x.multiplicative_order();
    except:
        for i in range(1,1000):
            if x**i == 1: return Integer(i);
    return Integer(1);


# finds minimal polynomial for BINOM f
# i.e. if f = X^k - b it returns prod_(i=0)^(s-1) (X^k - b^(frobPower^i))
def mipo(q,s,f):
    P = f.parent();
    ret = P.one();
    b = f[0];
    k = f.degree();
    x = P.gen();
    for i in range(0,s):
        ret = ret * (x**k - (-b)**(q**i))
    return ret;


# computes Trace_(E | F) (x)
def trace(E,F,x):
    #E = x.parent();
    ret = E.zero();
    q = F.order();
    n = E.order().log(q);
    xi = x;
    ret = x;
    for i in range(1,n):
        xi = xi**q;
        ret = ret + xi;
    Fx = PolynomialRing(F,'x');
    return F(Fx.gen()-Fx(ret.minpoly('x')).factor()[0][0]);
    #retSubs = re.sub(str(E.gen()), 'x', str(ret));
    #for h in Hom(F,E):
        #hSubs = re.sub(str(E.gen()), 'x', str(h(F.gen())));
        #Fx = PolynomialRing(F,'x');
        #f = Fx(hSubs+'-'+str(F.gen()));
        #print "ret  = ", ret;
        #print "f = ", f;
        #print "ret.mod(f) = ", Fx(retSubs).mod(f);
        #if Fx(retSubs).mod(f).is_constant():
            #return F(Fx(retSubs).mod(f));

def cosets(n,q):
    L = []
    Ls = []
    l = ordn(n,q)
    for k in range(0,n):
        cs = coset_l(n,q,k);
        if not cs in Ls: #and len(cs) == l:
            Ls = Ls + [cs];
            L = L + [(k,cs)];
    return L

def coset_l(n,q,l):
    return sorted(list(set(map(lambda i: (l*q**i)%n, range(0,n)))));

def print_cosets(n,q):
    for (k,cs) in cosets(n,q):
        print k, cs


def isNormal_bruteforce(x,F):
    E = x.parent();
    q = F.order();
    n = E.order().log(q);
    l = ordn(n,q);
    Fx = PolynomialRing(F,'x');
    S = set();
    for i in xrange(0,n):
        for f in Fx.monics(i):
            for e in F:
                S.add(sum(map(lambda fi: fi[0]*x**(q**fi[1]) , zip(list(f+e*Fx.gen()), xrange(0,100)))))
    if len(S) == E.order():
        return True;
    return False;


def hasPCNs(q,n):
    TIME = time.clock();

    #setup
    n = Integer(n);
    q = Integer(q);
    F = GF(q,'a');
    E = F.extension(n,'b');
    facAll = dict();
    prodsAll = dict();
    fieldsAll = dict();
    divs = divisors(n);
    for d in divs:
        G = F.extension(d, 'c');
        Gx = PolynomialRing(G,'x');
        fieldsAll[d] = G;
        facAll[d] = list((Gx.gen()**(n/d)-1).factor());
        prodsAll[d] = dict();
        # setup all products of factors of x^(n/d)-1
        #for i in xmrange(map(lambda f: f[1]+1, facAll[d])):
            #pr = Gx.one();
            #for jidx, j in enumerate(i):
                #pr *= facAll[d][jidx][0]**j;
            #prodsAll[d][str(i)] = pr;
    #print facAll
    #print prodsAll
    #print fieldsAll
    # do test
    countPCN = 0;

    perOld = 0;
    for idx,x in enumerate(E):
        if x == 0: continue;
        if not x.multiplicative_order() == E.order()-1:
            continue;
        isCn = True;
        #isCnBrute = True;
        for d in divs[:len(divs)-1]:
            if not isNormal(x,fieldsAll[d],facAll[d],[]):
            #if trace(E,fieldsAll[d],x) == 0:
                isCn = False;
            #if not isNormal_bruteforce(x,fieldsAll[d]):
                #isCnBrute = False;
        #if isCn != isCnBrute:
            #print "x = ",x
        if isCn: 
            print "PCN found for q = ",q, "n = ",n;
            return True;
            countPCN += 1;
        #per = idx/E.order();
        #if floor(100*per) > perOld: 
            #print round(100*per),"% tested."
        #perOld = floor(100*per);
    #print "q = ",q,", n = ",n,", PCN = ",countPCN;
    #print "\tTIME = ",time.clock()-TIME,"s";
    print "NO PCN found for q = ",q," n = ", n;
    return False;
