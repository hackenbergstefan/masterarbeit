from sage.all import *
import re
import time
from multiprocessing import Pool, Value
import multiprocessing
import itertools
import datetime
import time
import os
import ast

def findAnyPCN_polynom(p,r,n):
    if r == 1:
        return findAnyPCN_polynom_prime(p,n)

    q = p**r
    F = GF(q,'a')

    E = F.extension(n,'a')
    P = E.prime_subfield()

    Px = PolynomialRing(P,'x')
    Fx = PolynomialRing(F,'x')
    Ex = PolynomialRing(E,'x')
    h = Hom(F,E)[0]
    primOrder = E.order()-1
    
    primitives = []

    Flist = F.list()
    # correct list
    Flist = [F.zero()]
    for i in xrange(r):
        Flist += map(lambda f: F(list(f)), Px.polynomials(i))


    firstRun = True
    # first test trinoms!
    for coeffT in xrange(1,q):
        coeffTF = Flist[coeffT]
        if firstRun:
            for coeffN in xrange(1,q):
                coeffNF = Flist[coeffN]
                if coeffNF.multiplicative_order() != F.order()-1: continue
                primitives += [coeffNF]
                f = Fx.gen()**n + coeffTF*Fx.gen()**(n-1) + coeffNF
                #print f
                if not f.is_irreducible(): continue
                for fac,mul in Ex(f.map_coefficients(h)).factor():
                    if fac.degree() == 1:
                        x = -fac[0]
                        if isCompletelyNormal(x,F) and \
                                x.multiplicative_order() == primOrder:
                            #print "x = ",x,"\tcn: ",isCompletelyNormal(x,F),\
                                #"prim: ", (x.multiplicative_order() == E.order()-1)
                            return x,f
                        else: break
                    else: break
            firstRun = False
        else:
            for coeffNF in primitives:
                f = Fx.gen()**n + coeffTF*Fx.gen()**(n-1) + coeffNF
                #print "not first:",f
                if not f.is_irreducible(): continue
                for fac,mul in Ex(f.map_coefficients(h)).factor():
                    if fac.degree() == 1:
                        x = -fac[0]
                        if isCompletelyNormal(x,F) and \
                                x.multiplicative_order() == primOrder:
                            #print "x = ",x,"\tcn: ",isCompletelyNormal(x,F),\
                                #"prim: ", (x.multiplicative_order() == E.order()-1)
                            return x,f
                        else: break
                    else: break
    # test rest
    for length in xrange(1,n-2):
        for idcs in itertools.combinations(xrange(1,n-1),length):
            for xs in itertools.product(xrange(1,q),repeat=length+1):
                for x in primitives:
                    f = Fx.gen()**n + Flist[xs[0]]*Fx.gen()**(n-1) + x
                    for j,j2 in enumerate(idcs):
                        f += Flist[xs[j+1]] * Fx.gen() ** j2
                    if not f.is_irreducible(): continue
                    for fac,mul in Ex(f.map_coefficients(h)).factor():
                        if fac.degree() == 1:
                            y = -fac[0]
                            if isCompletelyNormal(y,F) and \
                                    y.multiplicative_order() == primOrder:
                                #print "x = ",x,"\tcn: ",isCompletelyNormal(x,F),\
                                    #"prim: ", (x.multiplicative_order() == E.order()-1)
                                return y,f
                            else: break
                        else: break

# special function for testing extensions of PrimeFields
def findAnyPCN_polynom_prime(p,n):
    p = Integer(p)
    n = Integer(n)
    F = GF(p)
    
    Fx = PolynomialRing(F,'x')
    
    orderE = p**n
    primOrder = orderE-1

    
    primitives = []



    firstRun = True
    # first test trinoms!
    for coeffT in xrange(1,p):
        if firstRun:
            for coeffN in xrange(1,p):
                if F(coeffN).multiplicative_order() != p-1: continue
                primitives += [coeffN]
                f = Fx.gen()**n + coeffT*Fx.gen()**(n-1) + coeffN
                #print f
                if not f.is_irreducible(): continue
                
                E = GF(orderE, name='a', modulus=f)

                if E.gen().multiplicative_order() == primOrder \
                        and isCompletelyNormal(E.gen(),F):
                    return E.gen(),f
            firstRun = False
        else:
            for coeffN in primitives:
                f = Fx.gen()**n + coeffT*Fx.gen()**(n-1) + coeffN
                #print "not first:",f
                if not f.is_irreducible(): continue
                E = GF(orderE, name='a', modulus=f)

                if E.gen().multiplicative_order() == primOrder \
                        and isCompletelyNormal(E.gen(),F):
                    return E.gen(),f
    # test rest
    for length in xrange(1,n-2):
        for idcs in itertools.combinations(xrange(1,n-1),length):
            for xs in itertools.product(xrange(1,p),repeat=length+1):
                for x in primitives:
                    f = Fx.gen()**n + xs[0]*Fx.gen()**(n-1) + x
                    for j,j2 in enumerate(idcs):
                        f += xs[j+1] * Fx.gen() ** j2
                    if not f.is_irreducible(): continue
                    E = GF(orderE, name='a', modulus=f)

                    if E.gen().multiplicative_order() == primOrder \
                            and isCompletelyNormal(E.gen(),F):
                        return E.gen(),f

#def findAnyPCN_polynom_parallel(F,n):
#    q = F.order();
#    p = F.characteristic();
#    r = q.log(p)
#
#    E = F.extension(n,'a')
#    P = E.prime_subfield()
#
#    Px = PolynomialRing(P,'x')
#    Fx = PolynomialRing(F,'x')
#    Ex = PolynomialRing(E,'x')
#    h = Hom(F,E)[0]
#    primOrder = E.order()-1
#    
#    primitives = []
#
#    Flist = F.list()
#    # correct list
#    if r != 1:
#        Flist = [F.zero()]
#        for i in xrange(r):
#            Flist += map(lambda f: F(list(f)), Px.polynomials(i))
#
#
#    firstRun = True
#    # first test trinoms!
#    for coeffN in xrange(1,q):
#        coeffNF = Flist[coeffN]
#        if coeffNF.multiplicative_order() != F.order()-1: continue
#        primitives += [coeffNF]
#        f = Fx.gen()**n + Fx.gen()**(n-1) + coeffNF
#        #print f
#        if not f.is_irreducible(): continue
#        for fac,mul in Ex(f.map_coefficients(h)).factor():
#            if fac.degree() == 1:
#                x = -fac[0]
#                if isCompletelyNormal(x,F) and \
#                        x.multiplicative_order() == primOrder:
#                    #print "x = ",x,"\tcn: ",isCompletelyNormal(x,F),\
#                        #"prim: ", (x.multiplicative_order() == E.order()-1)
#                    return x,f
#                else: break
#            else: break
#
#    pool = Pool()
#    for res in pool.imap(_testPoly,\
#            ([n,q,primOrder,F,h,Fx,Ex,Flist, [], []]))
#
#
#    for coeffT in xrange(1,q):
#        coeffTF = Flist[coeffT]
#            for coeffNF in primitives:
#                f = Fx.gen()**n + coeffTF*Fx.gen()**(n-1) + coeffNF
#                #print "not first:",f
#                if not f.is_irreducible(): continue
#                for fac,mul in Ex(f.map_coefficients(h)).factor():
#                    if fac.degree() == 1:
#                        x = -fac[0]
#                        if isCompletelyNormal(x,F) and \
#                                x.multiplicative_order() == primOrder:
#                            #print "x = ",x,"\tcn: ",isCompletelyNormal(x,F),\
#                                #"prim: ", (x.multiplicative_order() == E.order()-1)
#                            return x,f
#                        else: break
#                    else: break
#    # test rest
#    myPolyIterator = polyIterator(n,q,primitives)
#    for res in pool.imap(_testPoly, \
#            ([n,q,primOrder,F,h,Fx, Ex, Flist, idcs,xs,x] \
#            for idcs,xs, x in myPolyIterator),\
#            chunksize=10):
#        if res != False:
#            pool.close()
#            pool.join()
#            return res
#
#    pool.close()
#    pool.join()
#    return res
#
#def polyIterator(n,q,primitives):
#    for length in xrange(1,n-2):
#        for idcs in itertools.combinations(xrange(1,n-1),length):
#            for xs in itertools.product(xrange(1,q),repeat=length+1):
#                for x in primitives:
#                    yield idcs, xs, x
#
#
#
#
#def _testPoly(data):
#    n,q,primOrder,F,h,Fx, Ex, Flist, idcs, xs, x = data
#
#    f = Fx.gen()**n + Flist[xs[0]]*Fx.gen()**(n-1) + x
#    for j,j2 in enumerate(idcs):
#        f += Flist[xs[j+1]] * Fx.gen() ** j2
#
#    if not f.is_irreducible(): return False
#
#    for fac,mul in Ex(f.map_coefficients(h)).factor():
#        if fac.degree() == 1:
#            x = -fac[0]
#            if isCompletelyNormal(x,F) and \
#                    x.multiplicative_order() == primOrder:
#                #print "x = ",x,"\tcn: ",isCompletelyNormal(x,F),\
#                    #"prim: ", (x.multiplicative_order() == E.order()-1)
#                return x,f
#            else: break
#        else: break
#    return False



def findAnyPCN_polynom_wrapper(n, border=lambda n:n**4, \
        fileoutput=False, filepath="pcns_trinom_", \
        startPrime=1, stopPrime=0, onlyR=None):
    if fileoutput:
        st = datetime.datetime.\
                fromtimestamp(time.time()).strftime('%Y-%m-%d_%H:%M:%S')
        filepath += str(n)+"_"
        if onlyR != None: filepath += str(onlyR)+"_"
        filepath += st
    border = border(n)
    p = startPrime
    if onlyR != None and p**onlyR > border: return
    while p < border :
        if stopPrime != 0 and p > stopPrime: return
        p = next_prime(p)
        # consider only one r
        if onlyR != None:
            r = onlyR
            if p**r > border: continue
            if r == 1:
                x,pol = findAnyPCN_polynom_prime(p,n)
            else: 
                x,pol = findAnyPCN_polynom(p,r,n)
            print "(",p,", ",r,") = ", pol
            if fileoutput:
                with open(filepath,'a') as f:
                    f.write(str(p)+"\t"+str(r)
                            +"\t"+str(pol)+"\n")
                f.close();
            continue
        # consider all rs
        r = 1
        q = p**r
        while q < border:
            if r == 1:
                x,pol = findAnyPCN_polynom_prime(p,n)
            else: 
                x,pol = findAnyPCN_polynom(p,r,n)
            print "(",p,", ",r,") = ", pol
            if fileoutput:
                with open(filepath,'a') as f:
                    f.write(str(p)+"\t"+str(r)
                            +"\t"+str(pol)+"\n")
                f.close();
            #if not isCompletelyNormal(x,F) or \
                   #x.multiplicative_order() != q**n-1:
                #print "FATAL ERROR on p=",p," r=",r," x=",x.polynomial().list()
                #break;
            r += 1
            q = p**r







##############################################################################
## Slow Py Algorithms for testing ############################################
##############################################################################


def isCompletelyNormal(x,F, fieldsAll=[], facAll=[], prodsAll=[]):
    if x == 0: return False
    E = x.parent();
    q = F.order();
    n = E.order().log(q);
    p = F.characteristic();
    e = q.log(p)
    divs = get_proper_subfield_divisors(p,e,n)
    if facAll == []:
        facAll = dict();
        prodsAll = dict();
        fieldsAll = dict();
        for d in divs:
            G = F.extension(Integer(d), 'c');
            #G = getExtension(F,Integer(d))
            Gx = PolynomialRing(G,'x');
            fieldsAll[d] = G;
            facAll[d] = list((Gx.gen()**(n/d)-1).factor());
            facAll[d] = list((Gx.gen()**(n/d)-1).factor());
            prodsAll[d] = dict();
            for idx,(f,mult) in enumerate(facAll[d]):
                prodsAll[d][idx] = (Gx.gen()**(n/d)-1).quo_rem(f)[0]
    #test isNormal for each divisor
    pows = dict()
    for d in divs:
        h = Hom(fieldsAll[d],E)[0];
        for idx,(f,mult) in enumerate(facAll[d]):
            g = prodsAll[d][idx];
            ret = E.zero();
            iold = 0
            xiold = x
            for i,gi in enumerate(list(g)):
                if pows.has_key(i*d):
                    xi = pows[i*d];
                    iold = i*d
                    xiold = xi
                else:
                    xi = xiold**(q**(d*i-iold));
                    pows[i*d] = xi;
                    xiold = xi
                    iold = i*d
                ret += h(gi)*xi
            if ret == 0: return False;
    return True


def getExtension(F,d):
    p = F.characteristic()
    P = F.prime_subfield()
    q = F.order()
    e = q.log(p)
    Fx = PolynomialRing(P,'x')
    f = Fx.irreducible_element(d*e)
    if f:
        return GF(q**d, name='b', modulus=f)
    return None


##############################################################################
## Helper ####################################################################
##############################################################################


def get_padic_representation(number, p):
    number = Integer(number)
    p = Integer(p)
    ret = []
    q = number
    while q > 0:
        q,r = q.quo_rem(Integer(p));
        ret += [r]
    return list(reversed(ret))



# computes the quadratic free part of an integer
def squarefree(n):
    return sage.all.prod(map(lambda x: x[0], sage.all.factor(Integer(n))))

# computes ordn m(q) = min{ k: q ** k = 1 mod m }
def ordn(m,q):
    if m == 1: return 1
    for i in range(1,m+1):
        if (q ** i)%m == 1: return i;

# Application of the Decomposition Theorem (Section 19)
# for x^n-1 over F_p^e
def decompose(p,e, n):
    pi = largestDiv(p,n)
    return decompose_cycl_module(p,e, 1, n/pi, pi)


## returns the module characters of a decomposition
## the module character of U_F,Phi_k(x^t) is k*t / nu(k)
def get_module_characters(decomp):
   return uniq(map(lambda l: l[0]*l[1]*l[2] / squarefree(l[0]),decomp))

# returns the module characters of a cyclotomic module
# the module character of U_F,Phi_k(x^t)^pi is k*t*pi / nu(k)
def get_module_character(k,t,pi):
    return Integer(k*t*pi/squarefree(k))

# returns all divisors of the module characters of an extension
# capped with the complete basic divisors
# i.e. all intermediate fields that must be considered
def get_proper_subfield_divisors(p,e, n):
    basList = get_not_completely_basic_divisors(p,e,n)
    return filter(lambda d: d in basList, \
            list(uniq(itertools.chain(*map(divisors,\
           get_module_characters(decompose(p,e,n)))))))


# internal application of the Decomposition Theorem
# for Phi_k(x^(t*pi)) over F_p^e
def decompose_cycl_module(p,e, k,t,pi):
    if p.divides(k*t): print "ERROR p | kt"
    #test all prime divisors, start with largest one
    flag = False
    for r,l in reversed(factor(t)):
        if not (r**l).divides(ordn(squarefree(k*t),p**e)):
            R = largestDiv(r,t)
            return decompose_cycl_module(p,e, k, t/r, pi) + decompose_cycl_module(p,e, k*R, t/R, pi)
    return [(k,t,pi)]



# returns the largest power of p dividing n
def largestDiv(p,n):
    l = 0
    while (p**l).divides(n):
        l = l+1
    return p**(l-1);


# returns the NOT completely basic divisors of an 
# extension n over GF(p^e)
def get_not_completely_basic_divisors(p,e,n):
    n = Integer(n)
    q = Integer(p**e)
    divs = []
    divsN = divisors(n)
    while len(divsN) > 0:
        d = divsN.pop(0)
        #print "d=",d
        isComplBasic = True
        for r in prime_divisors(n/d):
            #print "\tr=",r
            #print "\t\t (n/d/r)\'=",p_free_part(n/d/r,p)," ordn(_,q^d)=",\
                          #ordn(p_free_part(n/d/r,p),q**d)
            if r.divides(ordn(p_free_part(n/d/r,p),q**d)):
                #print "\t\t=> r | _"
                isComplBasic = False
                break
        divs += [d]
        if isComplBasic: 
            #print "\t -> compl basic!"
            divsN = filter(lambda k: not d.divides(k), divsN)
            #print "\t new divsN=",divsN
    return divs


# p-free part of t
def p_free_part(t,p):
    while p.divides(t):
        t /= p
    return t




# formats timedelta objects to nice string
def strfdelta(tdelta):
    d = {}
    d["hours"], rem = divmod(tdelta.seconds, 3600)
    d["hours"] += int(tdelta.days*24)
    d["minutes"], d["seconds"] = divmod(rem, 60)
    return "{hours}:{minutes}:{seconds}".format(**d)



def tau_order(x,F, factors=[], prods=[], sigmaPower=1):
    Fx = PolynomialRing(F,'x');
    E = x.parent();
    q = F.order();
    n = E.order().log(q);
    if factors == []:
        fac = (Fx.gen()**n-1).factor();
    else:
        fac = factors;
    pows = dict();
    pre = [];
    for idx,(f,mult) in enumerate(fac):
        for j in xrange(mult-1,-1,-1):
            g = f.parent().one();
            ev = pre + [j] + map(lambda i: i[1], fac[idx+1:]);
            if prods == []:
                #generate factor
                for kidx, k in enumerate(ev):
                    g *= fac[kidx][0]**k;
            else:
                g = prods[str(ev)];
            ret = E.zero();
            for i,g in enumerate(list(g)):
                if pows != []:
                    if pows.has_key(i):
                        xi = pows[i];
                    else:
                        xi = x**(q**i);
                        pows[i] = xi;
                else: xi = x**(q**i);
                try:
                    ret += g*xi;
                except:
                    h = Hom(F,E)[0];
                    ret += h(g)*xi;
            if ret != 0:
                pre += [j+1]; 
                break;
            elif j == 0: 
                pre += [0];
    if prods == []:
        g = f.parent().one();
        for jidx, j in enumerate(pre):
            g *= fac[jidx][0]**j;
    else:
        g = prods[str(pre)]
    gshifted = [Fx.zero()]*len(list(g))
    for i, gi in enumerate(g):
        if gi == 0: continue
        gshifted[int(i/sigmaPower)] = gi
    return Fx(gshifted)
